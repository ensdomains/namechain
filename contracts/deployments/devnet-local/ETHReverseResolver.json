{
  "address": "0x0e801d84fa97b50751dbf25036d067dcf18858bf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ENS",
          "name": "_ens",
          "type": "address"
        },
        {
          "internalType": "contract IStandaloneReverseRegistrar",
          "name": "addrRegistrar",
          "type": "address"
        },
        {
          "internalType": "contract IStandaloneReverseRegistrar",
          "name": "_defaultRegistrar",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "UnreachableName",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        }
      ],
      "name": "UnsupportedResolverProfile",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "chainId",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "chainRegistrar",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "coinType",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultRegistrar",
      "outputs": [
        {
          "internalType": "contract IStandaloneReverseRegistrar",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addrs",
          "type": "address[]"
        }
      ],
      "name": "resolveNames",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "names",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "ETHReverseResolver",
  "sourceName": "lib/ens-contracts/contracts/reverseResolver/ETHReverseResolver.sol",
  "bytecode": "0x610100604052348015610010575f80fd5b506040516117d03803806117d083398101604081905261002f91610068565b603c6080526001600160a01b0391821660a05291811660c0521660e0526100b2565b6001600160a01b0381168114610065575f80fd5b50565b5f805f6060848603121561007a575f80fd5b835161008581610051565b602085015190935061009681610051565b60408501519092506100a781610051565b809150509250925092565b60805160a05160c05160e0516116ae6101225f395f818161015c0152610a9901525f6108f201525f818160ab0152818161045a015281816105a701526107f701525f818160ea015281816102d1015281816102f70152818161042e0152818161055d015261065701526116ae5ff3fe608060405234801561000f575f80fd5b506004361061007a575f3560e01c80639061b923116100585780639061b9231461011a5780639a8a05921461013a578063b16eab6514610157578063e38f71381461017e575f80fd5b806301ffc9a71461007e5780630d02e00f146100a65780631fe93ea8146100e5575b5f80fd5b61009161008c3660046111ef565b61019e565b60405190151581526020015b60405180910390f35b6100cd7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161009d565b61010c7f000000000000000000000000000000000000000000000000000000000000000081565b60405190815260200161009d565b61012d610128366004611254565b61023a565b60405161009d91906112e9565b610142610651565b60405163ffffffff909116815260200161009d565b6100cd7f000000000000000000000000000000000000000000000000000000000000000081565b61019161018c366004611357565b610680565b60405161009d9190611404565b5f6001600160e01b031982167f9061b92300000000000000000000000000000000000000000000000000000000148061020057506001600160e01b031982167f6beeaa0d00000000000000000000000000000000000000000000000000000000145b8061023457507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b92915050565b60605f6102478385611466565b90507f96e0cbcf000000000000000000000000000000000000000000000000000000006001600160e01b0319821601610395575f806102ba88888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061072a92505050565b9150915081516014141580610328575063800000007f00000000000000000000000000000000000000000000000000000000000000001461031d577f00000000000000000000000000000000000000000000000000000000000000008114610326565b610326816107b0565b155b15610353578787604051635fe9a5df60e01b815260040161034a929190611496565b60405180910390fd5b5f61035d836114c4565b60601c905061036b816107d5565b60405160200161037b91906112e9565b604051602081830303815290604052945050505050610649565b7fc4c4a822000000000000000000000000000000000000000000000000000000006001600160e01b03198216016104a7575f61040587878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610b04915050565b5090508061042a578686604051635fe9a5df60e01b815260040161034a929190611496565b603c7f000000000000000000000000000000000000000000000000000000000000000014610458575f61047a565b7f00000000000000000000000000000000000000000000000000000000000000005b604080516001600160a01b0390921660208301520160405160208183030381529060405292505050610649565b7f0e3481fa000000000000000000000000000000000000000000000000000000006001600160e01b031982160161060b575f61051787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610b04915050565b5090508061053c578686604051635fe9a5df60e01b815260040161034a929190611496565b5f61054a8560048189611500565b8101906105579190611527565b915050807f00000000000000000000000000000000000000000000000000000000000000001461059457604080515f8152602081019091526105e2565b6040516bffffffffffffffffffffffff197f000000000000000000000000000000000000000000000000000000000000000060601b1660208201526034016040516020818303038152906040525b6040516020016105f291906112e9565b6040516020818303038152906040529350505050610649565b6040517f7b1c461b0000000000000000000000000000000000000000000000000000000081526001600160e01b03198216600482015260240161034a565b949350505050565b5f61067b7f0000000000000000000000000000000000000000000000000000000000000000610cce565b905090565b6060815167ffffffffffffffff81111561069c5761069c6112fb565b6040519080825280602002602001820160405280156106cf57816020015b60608152602001906001900390816106ba5790505b5090505f5b8251811015610724576106ff8382815181106106f2576106f2611547565b60200260200101516107d5565b82828151811061071157610711611547565b60209081029190910101526001016106d4565b50919050565b60605f80610738845f610cf8565b9150505f61074885600184610d25565b909450905080158061075957508351155b1561077a575f60405180602001604052805f81525090935093505050915091565b6107848583610b04565b93509050806107a9575f60405180602001604052805f81525090935093505050915091565b5050915091565b5f638000000082148061023457505f6107c883610cce565b63ffffffff161192915050565b604051634ec3bd2360e01b81526001600160a01b0382811660048301526060917f000000000000000000000000000000000000000000000000000000000000000090911690634ec3bd23906024015f60405180830381865afa15801561083d573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610864919081019061155b565b80519091501561087357919050565b5f6108b67f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e26108a185610dc9565b805190602001205f9182526020526040902090565b6040517f0178b8bf000000000000000000000000000000000000000000000000000000008152600481018290529091505f906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690630178b8bf90602401602060405180830381865afa158015610937573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061095b91906115ea565b90506001600160a01b03811615610a7a575f80826001600160a01b0316620186a08560405160240161098f91815260200190565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f691f343100000000000000000000000000000000000000000000000000000000179052516109f29190611605565b5f604051808303818686fa925050503d805f8114610a2b576040519150601f19603f3d011682016040523d82523d5f602084013e610a30565b606091505b50915091508115610a4a57610a4481610dfd565b90925090505b81610a6757505060408051602081019091525f8152949350505050565b805115610a775795945050505050565b50505b604051634ec3bd2360e01b81526001600160a01b0385811660048301527f00000000000000000000000000000000000000000000000000000000000000001690634ec3bd23906024015f60405180830381865afa158015610add573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610649919081019061155b565b5f805f80610b128686610cf8565b60408051808201909152600481527f616464720000000000000000000000000000000000000000000000000000000060209091015290925090507f1a1ebb7848707a05591e7f7176db930a822cb7ceab700d19f68c7f26724dafb68201610b7c57603c9250610c29565b60408051808201909152600781527f64656661756c74000000000000000000000000000000000000000000000000006020909101527f301183f75670b4a9a2edb381b1d7533ad1e4387f1c77824f5fd582d2a43998d88201610be45763800000009250610c29565b81610bf6575f80935093505050610cc7565b5f80610c0d88610c0789600161162f565b85610e64565b9150915080610c25575f809550955050505050610cc7565b5092505b610c338682610cf8565b60408051808201909152600781527f7265766572736500000000000000000000000000000000000000000000000000602090910152955091507fdec08c9dbbdd0890e300eb5062089b2d4b1c40e3673bbccb5423f7b37dcf9a9c8214610ca0575f80935093505050610cc7565b610caa8686610cf8565b5091508115610cc0575f80935093505050610cc7565b6001935050505b9250929050565b5f603c8203610cdf57506001919050565b6380000000918218918210610cf4575f610234565b5090565b5f805f610d058585610ed6565b9250905060ff811615610d1d57806021858701012092505b509250929050565b60605f83831015610d4657505060408051602081019091525f808252610dc1565b5f610d518585611642565b90506001610d5f828261162f565b901c67ffffffffffffffff811115610d7957610d796112fb565b6040519080825280601f01601f191660200182016040528015610da3576020820181803683370190505b50925060208587018101908401610dbb828285610f53565b93505050505b935093915050565b60408051602880825260608281019093526020820181803683375050505f839052905060208101610724600c82602861103f565b5f60605f6020905080845110610e5e575f610e1785611655565b85519281019290915082116107a9575f610e3186836110a8565b5f1c9050808301865110610e5b576001610e4f8784602001846110c6565b94509450505050915091565b50505b50915091565b5f8083831015610e7857505f905080610dc1565b5f610e838585611642565b90506040811180610e945750855184115b15610ea557505f9150819050610dc1565b858501602001610eb6815f84610f53565b92506001820160011c6020035f518160031b1c9450505050935093915050565b5f8083518310610efb578360405163ba4adc2360e01b815260040161034a91906112e9565b838381518110610f0d57610f0d611547565b016020015160f81c91505081810160010181610f2d578351811415610f33565b83518110155b15610cc7578360405163ba4adc2360e01b815260040161034a91906112e9565b5f610fb1565b811a5f602f8211603a83101615610f755750602f198101610234565b60478210604083111615610f8e57506036198101610234565b60678210606083111615610fa757506056198101610234565b5061010092915050565b50600183820182821615610feb57610fca5f8651610f59565b80855360018601955060018501945060ff811115610fe9575f92508195505b505b80851015611037578451611000600182610f59565b61100a5f83610f59565b60041b17905060ff811115611022575f925050611037565b80855350600285019450600184019350610feb565b509392505050565b8181015b808310156110a25783516101005b828510801561105f57505f81115b156110955760031901600f82821c16600a811061107f5780605701611084565b806030015b905080865350600190940193611051565b5050602084019350611043565b50505050565b5f6110bd836110b884602061162f565b611122565b50016020015190565b60608167ffffffffffffffff8111156110e1576110e16112fb565b6040519080825280601f01601f19166020018201604052801561110b576020820181803683370190505b50905061111b8484835f8661116e565b9392505050565b815181111561116a5781516040517f8a3c1cfb00000000000000000000000000000000000000000000000000000000815261034a918391600401918252602082015260400190565b5050565b61117c856110b8838761162f565b61118a836110b8838561162f565b61119f826020850101856020880101836111a6565b5050505050565b5b601f8111156111c7578151835260209283019290910190601f19016111a7565b80156111ea57815183516001602084900360031b1b5f1901801990921691161783525b505050565b5f602082840312156111ff575f80fd5b81356001600160e01b03198116811461111b575f80fd5b5f8083601f840112611226575f80fd5b50813567ffffffffffffffff81111561123d575f80fd5b602083019150836020828501011115610cc7575f80fd5b5f805f8060408587031215611267575f80fd5b843567ffffffffffffffff8082111561127e575f80fd5b61128a88838901611216565b909650945060208701359150808211156112a2575f80fd5b506112af87828801611216565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61111b60208301846112bb565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611338576113386112fb565b604052919050565b6001600160a01b0381168114611354575f80fd5b50565b5f6020808385031215611368575f80fd5b823567ffffffffffffffff8082111561137f575f80fd5b818501915085601f830112611392575f80fd5b8135818111156113a4576113a46112fb565b8060051b91506113b584830161130f565b81815291830184019184810190888411156113ce575f80fd5b938501935b838510156113f857843592506113e883611340565b82825293850193908501906113d3565b98975050505050505050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561145957603f198886030184526114478583516112bb565b9450928501929085019060010161142b565b5092979650505050505050565b6001600160e01b0319813581811691600485101561148e5780818660040360031b1b83161692505b505092915050565b60208152816020820152818360408301375f818301604090810191909152601f909201601f19160101919050565b805160208201516bffffffffffffffffffffffff1980821692919060148310156114f85780818460140360031b1b83161693505b505050919050565b5f808585111561150e575f80fd5b8386111561151a575f80fd5b5050820193919092039150565b5f8060408385031215611538575f80fd5b50508035926020909101359150565b634e487b7160e01b5f52603260045260245ffd5b5f602080838503121561156c575f80fd5b825167ffffffffffffffff80821115611583575f80fd5b818501915085601f830112611596575f80fd5b8151818111156115a8576115a86112fb565b6115ba601f8201601f1916850161130f565b915080825286848285010111156115cf575f80fd5b808484018584015e5f90820190930192909252509392505050565b5f602082840312156115fa575f80fd5b815161111b81611340565b5f82518060208501845e5f920191825250919050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156102345761023461161b565b818103818111156102345761023461161b565b80516020808301519190811015610724575f1960209190910360031b1b1691905056fea2646970667358221220aa2c89436cb8a3f91a3f17144f1aea4cb0011c3cdd091492260b1f9a0801ce9364736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b506004361061007a575f3560e01c80639061b923116100585780639061b9231461011a5780639a8a05921461013a578063b16eab6514610157578063e38f71381461017e575f80fd5b806301ffc9a71461007e5780630d02e00f146100a65780631fe93ea8146100e5575b5f80fd5b61009161008c3660046111ef565b61019e565b60405190151581526020015b60405180910390f35b6100cd7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161009d565b61010c7f000000000000000000000000000000000000000000000000000000000000000081565b60405190815260200161009d565b61012d610128366004611254565b61023a565b60405161009d91906112e9565b610142610651565b60405163ffffffff909116815260200161009d565b6100cd7f000000000000000000000000000000000000000000000000000000000000000081565b61019161018c366004611357565b610680565b60405161009d9190611404565b5f6001600160e01b031982167f9061b92300000000000000000000000000000000000000000000000000000000148061020057506001600160e01b031982167f6beeaa0d00000000000000000000000000000000000000000000000000000000145b8061023457507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b92915050565b60605f6102478385611466565b90507f96e0cbcf000000000000000000000000000000000000000000000000000000006001600160e01b0319821601610395575f806102ba88888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061072a92505050565b9150915081516014141580610328575063800000007f00000000000000000000000000000000000000000000000000000000000000001461031d577f00000000000000000000000000000000000000000000000000000000000000008114610326565b610326816107b0565b155b15610353578787604051635fe9a5df60e01b815260040161034a929190611496565b60405180910390fd5b5f61035d836114c4565b60601c905061036b816107d5565b60405160200161037b91906112e9565b604051602081830303815290604052945050505050610649565b7fc4c4a822000000000000000000000000000000000000000000000000000000006001600160e01b03198216016104a7575f61040587878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610b04915050565b5090508061042a578686604051635fe9a5df60e01b815260040161034a929190611496565b603c7f000000000000000000000000000000000000000000000000000000000000000014610458575f61047a565b7f00000000000000000000000000000000000000000000000000000000000000005b604080516001600160a01b0390921660208301520160405160208183030381529060405292505050610649565b7f0e3481fa000000000000000000000000000000000000000000000000000000006001600160e01b031982160161060b575f61051787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610b04915050565b5090508061053c578686604051635fe9a5df60e01b815260040161034a929190611496565b5f61054a8560048189611500565b8101906105579190611527565b915050807f00000000000000000000000000000000000000000000000000000000000000001461059457604080515f8152602081019091526105e2565b6040516bffffffffffffffffffffffff197f000000000000000000000000000000000000000000000000000000000000000060601b1660208201526034016040516020818303038152906040525b6040516020016105f291906112e9565b6040516020818303038152906040529350505050610649565b6040517f7b1c461b0000000000000000000000000000000000000000000000000000000081526001600160e01b03198216600482015260240161034a565b949350505050565b5f61067b7f0000000000000000000000000000000000000000000000000000000000000000610cce565b905090565b6060815167ffffffffffffffff81111561069c5761069c6112fb565b6040519080825280602002602001820160405280156106cf57816020015b60608152602001906001900390816106ba5790505b5090505f5b8251811015610724576106ff8382815181106106f2576106f2611547565b60200260200101516107d5565b82828151811061071157610711611547565b60209081029190910101526001016106d4565b50919050565b60605f80610738845f610cf8565b9150505f61074885600184610d25565b909450905080158061075957508351155b1561077a575f60405180602001604052805f81525090935093505050915091565b6107848583610b04565b93509050806107a9575f60405180602001604052805f81525090935093505050915091565b5050915091565b5f638000000082148061023457505f6107c883610cce565b63ffffffff161192915050565b604051634ec3bd2360e01b81526001600160a01b0382811660048301526060917f000000000000000000000000000000000000000000000000000000000000000090911690634ec3bd23906024015f60405180830381865afa15801561083d573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610864919081019061155b565b80519091501561087357919050565b5f6108b67f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e26108a185610dc9565b805190602001205f9182526020526040902090565b6040517f0178b8bf000000000000000000000000000000000000000000000000000000008152600481018290529091505f906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690630178b8bf90602401602060405180830381865afa158015610937573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061095b91906115ea565b90506001600160a01b03811615610a7a575f80826001600160a01b0316620186a08560405160240161098f91815260200190565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f691f343100000000000000000000000000000000000000000000000000000000179052516109f29190611605565b5f604051808303818686fa925050503d805f8114610a2b576040519150601f19603f3d011682016040523d82523d5f602084013e610a30565b606091505b50915091508115610a4a57610a4481610dfd565b90925090505b81610a6757505060408051602081019091525f8152949350505050565b805115610a775795945050505050565b50505b604051634ec3bd2360e01b81526001600160a01b0385811660048301527f00000000000000000000000000000000000000000000000000000000000000001690634ec3bd23906024015f60405180830381865afa158015610add573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610649919081019061155b565b5f805f80610b128686610cf8565b60408051808201909152600481527f616464720000000000000000000000000000000000000000000000000000000060209091015290925090507f1a1ebb7848707a05591e7f7176db930a822cb7ceab700d19f68c7f26724dafb68201610b7c57603c9250610c29565b60408051808201909152600781527f64656661756c74000000000000000000000000000000000000000000000000006020909101527f301183f75670b4a9a2edb381b1d7533ad1e4387f1c77824f5fd582d2a43998d88201610be45763800000009250610c29565b81610bf6575f80935093505050610cc7565b5f80610c0d88610c0789600161162f565b85610e64565b9150915080610c25575f809550955050505050610cc7565b5092505b610c338682610cf8565b60408051808201909152600781527f7265766572736500000000000000000000000000000000000000000000000000602090910152955091507fdec08c9dbbdd0890e300eb5062089b2d4b1c40e3673bbccb5423f7b37dcf9a9c8214610ca0575f80935093505050610cc7565b610caa8686610cf8565b5091508115610cc0575f80935093505050610cc7565b6001935050505b9250929050565b5f603c8203610cdf57506001919050565b6380000000918218918210610cf4575f610234565b5090565b5f805f610d058585610ed6565b9250905060ff811615610d1d57806021858701012092505b509250929050565b60605f83831015610d4657505060408051602081019091525f808252610dc1565b5f610d518585611642565b90506001610d5f828261162f565b901c67ffffffffffffffff811115610d7957610d796112fb565b6040519080825280601f01601f191660200182016040528015610da3576020820181803683370190505b50925060208587018101908401610dbb828285610f53565b93505050505b935093915050565b60408051602880825260608281019093526020820181803683375050505f839052905060208101610724600c82602861103f565b5f60605f6020905080845110610e5e575f610e1785611655565b85519281019290915082116107a9575f610e3186836110a8565b5f1c9050808301865110610e5b576001610e4f8784602001846110c6565b94509450505050915091565b50505b50915091565b5f8083831015610e7857505f905080610dc1565b5f610e838585611642565b90506040811180610e945750855184115b15610ea557505f9150819050610dc1565b858501602001610eb6815f84610f53565b92506001820160011c6020035f518160031b1c9450505050935093915050565b5f8083518310610efb578360405163ba4adc2360e01b815260040161034a91906112e9565b838381518110610f0d57610f0d611547565b016020015160f81c91505081810160010181610f2d578351811415610f33565b83518110155b15610cc7578360405163ba4adc2360e01b815260040161034a91906112e9565b5f610fb1565b811a5f602f8211603a83101615610f755750602f198101610234565b60478210604083111615610f8e57506036198101610234565b60678210606083111615610fa757506056198101610234565b5061010092915050565b50600183820182821615610feb57610fca5f8651610f59565b80855360018601955060018501945060ff811115610fe9575f92508195505b505b80851015611037578451611000600182610f59565b61100a5f83610f59565b60041b17905060ff811115611022575f925050611037565b80855350600285019450600184019350610feb565b509392505050565b8181015b808310156110a25783516101005b828510801561105f57505f81115b156110955760031901600f82821c16600a811061107f5780605701611084565b806030015b905080865350600190940193611051565b5050602084019350611043565b50505050565b5f6110bd836110b884602061162f565b611122565b50016020015190565b60608167ffffffffffffffff8111156110e1576110e16112fb565b6040519080825280601f01601f19166020018201604052801561110b576020820181803683370190505b50905061111b8484835f8661116e565b9392505050565b815181111561116a5781516040517f8a3c1cfb00000000000000000000000000000000000000000000000000000000815261034a918391600401918252602082015260400190565b5050565b61117c856110b8838761162f565b61118a836110b8838561162f565b61119f826020850101856020880101836111a6565b5050505050565b5b601f8111156111c7578151835260209283019290910190601f19016111a7565b80156111ea57815183516001602084900360031b1b5f1901801990921691161783525b505050565b5f602082840312156111ff575f80fd5b81356001600160e01b03198116811461111b575f80fd5b5f8083601f840112611226575f80fd5b50813567ffffffffffffffff81111561123d575f80fd5b602083019150836020828501011115610cc7575f80fd5b5f805f8060408587031215611267575f80fd5b843567ffffffffffffffff8082111561127e575f80fd5b61128a88838901611216565b909650945060208701359150808211156112a2575f80fd5b506112af87828801611216565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61111b60208301846112bb565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611338576113386112fb565b604052919050565b6001600160a01b0381168114611354575f80fd5b50565b5f6020808385031215611368575f80fd5b823567ffffffffffffffff8082111561137f575f80fd5b818501915085601f830112611392575f80fd5b8135818111156113a4576113a46112fb565b8060051b91506113b584830161130f565b81815291830184019184810190888411156113ce575f80fd5b938501935b838510156113f857843592506113e883611340565b82825293850193908501906113d3565b98975050505050505050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561145957603f198886030184526114478583516112bb565b9450928501929085019060010161142b565b5092979650505050505050565b6001600160e01b0319813581811691600485101561148e5780818660040360031b1b83161692505b505092915050565b60208152816020820152818360408301375f818301604090810191909152601f909201601f19160101919050565b805160208201516bffffffffffffffffffffffff1980821692919060148310156114f85780818460140360031b1b83161693505b505050919050565b5f808585111561150e575f80fd5b8386111561151a575f80fd5b5050820193919092039150565b5f8060408385031215611538575f80fd5b50508035926020909101359150565b634e487b7160e01b5f52603260045260245ffd5b5f602080838503121561156c575f80fd5b825167ffffffffffffffff80821115611583575f80fd5b818501915085601f830112611596575f80fd5b8151818111156115a8576115a86112fb565b6115ba601f8201601f1916850161130f565b915080825286848285010111156115cf575f80fd5b808484018584015e5f90820190930192909252509392505050565b5f602082840312156115fa575f80fd5b815161111b81611340565b5f82518060208501845e5f920191825250919050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156102345761023461161b565b818103818111156102345761023461161b565b80516020808301519190811015610724575f1960209190910360031b1b1691905056fea2646970667358221220aa2c89436cb8a3f91a3f17144f1aea4cb0011c3cdd091492260b1f9a0801ce9364736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "16592": [
      {
        "length": 32,
        "start": 234
      },
      {
        "length": 32,
        "start": 721
      },
      {
        "length": 32,
        "start": 759
      },
      {
        "length": 32,
        "start": 1070
      },
      {
        "length": 32,
        "start": 1373
      },
      {
        "length": 32,
        "start": 1623
      }
    ],
    "16595": [
      {
        "length": 32,
        "start": 171
      },
      {
        "length": 32,
        "start": 1114
      },
      {
        "length": 32,
        "start": 1447
      },
      {
        "length": 32,
        "start": 2039
      }
    ],
    "17439": [
      {
        "length": 32,
        "start": 2290
      }
    ],
    "17443": [
      {
        "length": 32,
        "start": 348
      },
      {
        "length": 32,
        "start": 2713
      }
    ]
  },
  "inputSourceName": "project/lib/ens-contracts/contracts/reverseResolver/ETHReverseResolver.sol",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ],
      "UnreachableName(bytes)": [
        {
          "details": "Error selector: `0x5fe9a5df`"
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "details": "Error selector: `0x7b1c461b`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "resolve(bytes,bytes)": {
        "details": "This function may execute over multiple steps.",
        "params": {
          "data": "The resolution data, as specified in ENSIP-10.",
          "name": "The reverse name to resolve, in normalised and DNS-encoded form."
        },
        "returns": {
          "result": "The encoded response for the requested profile."
        }
      },
      "resolveNames(address[])": {
        "details": "This function may execute over multiple steps.",
        "params": {
          "addrs": "The addresses to resolve."
        },
        "returns": {
          "names": "The resolved names."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "stateVariables": {
      "ADDR_REVERSE_NODE": {
        "details": "Namehash of \"addr.reverse\""
      }
    },
    "title": "Ethereum Reverse Resolver",
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "1161200",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "chainId()": "infinite",
        "chainRegistrar()": "infinite",
        "coinType()": "infinite",
        "defaultRegistrar()": "infinite",
        "resolve(bytes,bytes)": "infinite",
        "resolveNames(address[])": "infinite",
        "supportsInterface(bytes4)": "461"
      },
      "internal": {
        "_resolveName(address)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"contract IStandaloneReverseRegistrar\",\"name\":\"addrRegistrar\",\"type\":\"address\"},{\"internalType\":\"contract IStandaloneReverseRegistrar\",\"name\":\"_defaultRegistrar\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"UnreachableName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedResolverProfile\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRegistrar\",\"outputs\":[{\"internalType\":\"contract IStandaloneReverseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"resolveNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}],\"UnreachableName(bytes)\":[{\"details\":\"Error selector: `0x5fe9a5df`\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"details\":\"Error selector: `0x7b1c461b`\"}]},\"kind\":\"dev\",\"methods\":{\"resolve(bytes,bytes)\":{\"details\":\"This function may execute over multiple steps.\",\"params\":{\"data\":\"The resolution data, as specified in ENSIP-10.\",\"name\":\"The reverse name to resolve, in normalised and DNS-encoded form.\"},\"returns\":{\"result\":\"The encoded response for the requested profile.\"}},\"resolveNames(address[])\":{\"details\":\"This function may execute over multiple steps.\",\"params\":{\"addrs\":\"The addresses to resolve.\"},\"returns\":{\"names\":\"The resolved names.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"stateVariables\":{\"ADDR_REVERSE_NODE\":{\"details\":\"Namehash of \\\"addr.reverse\\\"\"}},\"title\":\"Ethereum Reverse Resolver\",\"version\":1},\"userdoc\":{\"errors\":{\"UnreachableName(bytes)\":[{\"notice\":\"`name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"notice\":\"`resolve()` was called with a profile other than `name()` or `addr(*)`.\"}]},\"kind\":\"user\",\"methods\":{\"chainId()\":{\"notice\":\"The EVM Chain ID derived from `coinType()`.\"},\"chainRegistrar()\":{\"notice\":\"The reverse registrar address on the corresponding chain.         The address returned by `addr(coinType)` for the resolver.\"},\"coinType()\":{\"notice\":\"The coin type for the resolver.\"},\"defaultRegistrar()\":{\"notice\":\"The reverse registrar contract for \\\"default.reverse\\\".\"},\"resolve(bytes,bytes)\":{\"notice\":\"Resolves the following profiles according to ENSIP-10:         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.         Caller should enable EIP-3668.\"},\"resolveNames(address[])\":{\"notice\":\"Resolve multiple EVM addresses to names.         Caller should enable EIP-3668.\"}},\"notice\":\"Reverses an EVM address using the first non-null response from the following sources: 1. `IStandaloneReverseRegistrar` for \\\"addr.reverse\\\" 2. `name()` from \\\"{addr}.addr.reverse\\\" in V1 Registry 3. `IStandaloneReverseRegistrar` for \\\"default.reverse\\\"\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/lib/ens-contracts/contracts/reverseResolver/ETHReverseResolver.sol\":\"ETHReverseResolver\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@ensdomains/solsha1/contracts/=project/lib/solsha1/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts-v5/=project/lib/openzeppelin-contracts/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/ens-contracts/:@unruggable/gateways/=project/lib/unruggable-gateways/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\",\"project/test/mocks/v1/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8e208b44d5dbf22552fe72d79b45c640855b84fbc9ee21f4c3bb4bfe81cbe8db\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the legacy (ETH-only) addr function.\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /// Returns the address associated with an ENS node.\\n    /// @param node The ENS node to query.\\n    /// @return The associated address.\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the new (multicoin) addr function.\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x8da5dd0fc1c5ab4f47e03c23126976a86d4b2dbeac161e70e3af9e2a13330cf0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /// Returns the name associated with an ENS node, for reverse records.\\n    /// Defined in EIP181.\\n    /// @param node The ENS node to query.\\n    /// @return The associated name.\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x3ab986332e0baad7aeb4b426aace3aa1c235be5efff8db4b6f1ce501bcdd9e68\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseRegistrar/IStandaloneReverseRegistrar.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Interface for a standalone reverse registrar.\\ninterface IStandaloneReverseRegistrar {\\n    /// @notice Emitted when the name for an address is changed.\\n    ///\\n    /// @param addr The address of the reverse record.\\n    /// @param name The name of the reverse record.\\n    event NameForAddrChanged(address indexed addr, string name);\\n\\n    /// @notice Returns the name for an address.\\n    ///\\n    /// @param addr The address to get the name for.\\n    /// @return The name for the address.\\n    function nameForAddr(address addr) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x693ab3a5dcd95a80a2a4a2418ce48092d20d11da1e39d17c87ab3f1641ceaf6e\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseResolver/AbstractReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ERC165} from \\\"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\\\";\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IAddressResolver} from \\\"../resolvers/profiles/IAddressResolver.sol\\\";\\nimport {IAddrResolver} from \\\"../resolvers/profiles/IAddrResolver.sol\\\";\\nimport {INameResolver} from \\\"../resolvers/profiles/INameResolver.sol\\\";\\nimport {INameReverser} from \\\"./INameReverser.sol\\\";\\nimport {ENSIP19, COIN_TYPE_DEFAULT, COIN_TYPE_ETH} from \\\"../utils/ENSIP19.sol\\\";\\n\\nabstract contract AbstractReverseResolver is\\n    IExtendedResolver,\\n    INameReverser,\\n    ERC165\\n{\\n    /// @inheritdoc INameReverser\\n    uint256 public immutable coinType;\\n\\n\\t/// @inheritdoc INameReverser\\n    address public immutable chainRegistrar;\\n\\n    /// @notice `resolve()` was called with a profile other than `name()` or `addr(*)`.\\n    /// @dev Error selector: `0x7b1c461b`\\n    error UnsupportedResolverProfile(bytes4 selector);\\n\\n    /// @notice `name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\\n    /// @dev Error selector: `0x5fe9a5df`\\n    error UnreachableName(bytes name);\\n\\n    constructor(uint256 _coinType, address registrar) {\\n        coinType = _coinType;\\n        chainRegistrar = registrar;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IExtendedResolver).interfaceId ||\\n            interfaceId == type(INameReverser).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc INameReverser\\n    function chainId() external view returns (uint32) {\\n        return ENSIP19.chainFromCoinType(coinType);\\n    }\\n\\n    /// @dev Resolve one address to a name.\\n    ///      If this reverts `OffchainLookup`, it must return an abi-encoded result since\\n    ///      it is invoked during `resolve()`.\\n    function _resolveName(\\n        address addr\\n    ) internal view virtual returns (string memory name);\\n\\n    /// @notice Resolves the following profiles according to ENSIP-10:\\n    ///         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.\\n    ///         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.\\n    ///         Caller should enable EIP-3668.\\n    /// @dev This function may execute over multiple steps.\\n    /// @param name The reverse name to resolve, in normalised and DNS-encoded form.\\n    /// @param data The resolution data, as specified in ENSIP-10.\\n    /// @return result The encoded response for the requested profile.\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory result) {\\n        bytes4 selector = bytes4(data);\\n        if (selector == INameResolver.name.selector) {\\n            (bytes memory a, uint256 ct) = ENSIP19.parse(name);\\n            if (\\n                a.length != 20 ||\\n                !(\\n                    coinType == COIN_TYPE_DEFAULT\\n                        ? ENSIP19.isEVMCoinType(ct)\\n                        : ct == coinType\\n                )\\n            ) {\\n                revert UnreachableName(name);\\n            }\\n            address addr = address(bytes20(a));\\n            return abi.encode(_resolveName(addr));\\n        } else if (selector == IAddrResolver.addr.selector) {\\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\\n            if (!valid) revert UnreachableName(name);\\n            return\\n                abi.encode(coinType == COIN_TYPE_ETH ? chainRegistrar : address(0));\\n        } else if (selector == IAddressResolver.addr.selector) {\\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\\n            if (!valid) revert UnreachableName(name);\\n            (, uint256 ct) = abi.decode(data[4:], (bytes32, uint256));\\n            return\\n                abi.encode(\\n                    coinType == ct ? abi.encodePacked(chainRegistrar) : new bytes(0)\\n                );\\n        } else {\\n            revert UnsupportedResolverProfile(selector);\\n        }\\n    }\\n\\n    // `INameReverser.resolveNames()` is not implemented here because it causes\\n    // an incorrect \\\"Unreachable code\\\" compiler warning if `_resolveName()` reverts.\\n    // https://github.com/ethereum/solidity/issues/15426#issuecomment-2917868211\\n    //\\n    // /// @inheritdoc INameReverser\\n    // function resolveNames(\\n    //     address[] memory addrs,\\n    //     uint8 /*perPage*/\\n    // ) external view returns (string[] memory names) {\\n    //     names = new string[](addrs.length);\\n    //     for (uint256 i; i < addrs.length; i++) {\\n    //         names[i] = _resolveName(addrs[i]);\\n    //     }\\n    // }\\n}\\n\",\"keccak256\":\"0x492aa5a5e0d184035247aae2e8ed6e283068e2a9f2ec03b02851d240ffe6960f\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseResolver/ETHReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {AbstractReverseResolver} from \\\"./AbstractReverseResolver.sol\\\";\\nimport {ENS} from \\\"../registry/ENS.sol\\\";\\nimport {INameResolver} from \\\"../resolvers/profiles/INameResolver.sol\\\";\\nimport {IStandaloneReverseRegistrar} from \\\"../reverseRegistrar/IStandaloneReverseRegistrar.sol\\\";\\nimport {INameReverser} from \\\"./INameReverser.sol\\\";\\nimport {COIN_TYPE_ETH} from \\\"../utils/ENSIP19.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\nimport {LibABI} from \\\"../utils/LibABI.sol\\\";\\n\\n/// @title Ethereum Reverse Resolver\\n/// @notice Reverses an EVM address using the first non-null response from the following sources:\\n///\\n/// 1. `IStandaloneReverseRegistrar` for \\\"addr.reverse\\\"\\n/// 2. `name()` from \\\"{addr}.addr.reverse\\\" in V1 Registry\\n/// 3. `IStandaloneReverseRegistrar` for \\\"default.reverse\\\"\\n///\\ncontract ETHReverseResolver is AbstractReverseResolver {\\n    /// @dev Namehash of \\\"addr.reverse\\\"\\n    bytes32 constant ADDR_REVERSE_NODE =\\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n    /// @notice The ENS registry contract.\\n    ENS immutable ens;\\n\\n    /// @notice The reverse registrar contract for \\\"default.reverse\\\".\\n    IStandaloneReverseRegistrar public immutable defaultRegistrar;\\n\\n    constructor(\\n        ENS _ens,\\n        IStandaloneReverseRegistrar addrRegistrar,\\n        IStandaloneReverseRegistrar _defaultRegistrar\\n    ) AbstractReverseResolver(COIN_TYPE_ETH, address(addrRegistrar)) {\\n        ens = _ens;\\n        defaultRegistrar = _defaultRegistrar;\\n    }\\n\\n    /// @inheritdoc AbstractReverseResolver\\n    function _resolveName(\\n        address addr\\n    ) internal view override returns (string memory name) {\\n        name = IStandaloneReverseRegistrar(chainRegistrar).nameForAddr(addr);\\n        if (bytes(name).length > 0) {\\n            return name;\\n        }\\n        bytes32 node = NameCoder.namehash(\\n            ADDR_REVERSE_NODE,\\n            keccak256(bytes(HexUtils.addressToHex(addr)))\\n        );\\n        address resolver = ens.resolver(node);\\n        if (resolver != address(0)) {\\n            // note: this only supports onchain direct calls (no extended, no offchain)\\n            (bool ok, bytes memory v) = resolver.staticcall{gas: 100_000}(\\n                abi.encodeCall(INameResolver.name, (node))\\n            );\\n            if (ok) {\\n                (ok, v) = LibABI.tryDecodeBytes(v);\\n            }\\n            if (!ok) {\\n                return \\\"\\\"; // terminate on revert or decode failure\\n            }\\n            if (v.length > 0) {\\n                return string(v);\\n            }\\n        }\\n        return defaultRegistrar.nameForAddr(addr);\\n    }\\n\\n    /// @inheritdoc INameReverser\\n    function resolveNames(\\n        address[] memory addrs\\n    ) external view returns (string[] memory names) {\\n        names = new string[](addrs.length);\\n        for (uint256 i; i < addrs.length; ++i) {\\n            names[i] = _resolveName(addrs[i]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd7f355693c4c04683830a28d5795257b68bc8ef9fbf3932ac5fea99a0f0f0cd1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseResolver/INameReverser.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice A resolver for primary name resolution.\\n/// @dev Interface selector: `0x6beeaa0d`\\ninterface INameReverser {\\n    /// @notice Resolve multiple EVM addresses to names.\\n    ///         Caller should enable EIP-3668.\\n    /// @dev This function may execute over multiple steps.\\n    /// @param addrs The addresses to resolve.\\n    /// @return names The resolved names.\\n    function resolveNames(\\n        address[] memory addrs\\n    ) external view returns (string[] memory names);\\n\\n    /// @notice The coin type for the resolver.\\n    function coinType() external view returns (uint256);\\n\\n    /// @notice The EVM Chain ID derived from `coinType()`.\\n    function chainId() external view returns (uint32);\\n\\n    /// @notice The reverse registrar address on the corresponding chain.\\n    ///         The address returned by `addr(coinType)` for the resolver.\\n    function chainRegistrar() external view returns (address);\\n}\\n\",\"keccak256\":\"0x74873da2d0f06ff236802bf9378aee03db8f2793c7113015cafe7515c3e61244\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/ENSIP19.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nuint32 constant CHAIN_ID_ETH = 1;\\n\\nuint256 constant COIN_TYPE_ETH = 60;\\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\\n\\nstring constant SLUG_ETH = \\\"addr\\\"; // <=> COIN_TYPE_ETH\\nstring constant SLUG_DEFAULT = \\\"default\\\"; // <=> COIN_TYPE_DEFAULT\\nstring constant TLD_REVERSE = \\\"reverse\\\";\\n\\n/// @dev Library for generating reverse names according to ENSIP-19.\\n/// https://docs.ens.domains/ensip/19\\nlibrary ENSIP19 {\\n    /// @dev The supplied address was `0x`.\\n    ///      Error selector: `0x7138356f`\\n    error EmptyAddress();\\n\\n    /// @dev Extract Chain ID from `coinType`.\\n    /// @param coinType The coin type.\\n    /// @return The Chain ID or 0 if non-EVM Chain.\\n    function chainFromCoinType(\\n        uint256 coinType\\n    ) internal pure returns (uint32) {\\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\\n        coinType ^= COIN_TYPE_DEFAULT;\\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\\n    }\\n\\n    /// @dev Determine if Coin Type is for an EVM address.\\n    /// @param coinType The coin type.\\n    /// @return True if coin type represents an EVM address.\\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\\n    }\\n\\n    /// @dev Generate Reverse Name from Address + Coin Type.\\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\\n    /// @param addressBytes The input address.\\n    /// @param coinType The coin type.\\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\\n    function reverseName(\\n        bytes memory addressBytes,\\n        uint256 coinType\\n    ) internal pure returns (string memory) {\\n        if (addressBytes.length == 0) {\\n            revert EmptyAddress();\\n        }\\n        return\\n            string(\\n                abi.encodePacked(\\n                    HexUtils.bytesToHex(addressBytes),\\n                    bytes1(\\\".\\\"),\\n                    coinType == COIN_TYPE_ETH\\n                        ? SLUG_ETH\\n                        : coinType == COIN_TYPE_DEFAULT\\n                            ? SLUG_DEFAULT\\n                            : HexUtils.unpaddedUintToHex(coinType, true),\\n                    bytes1(\\\".\\\"),\\n                    TLD_REVERSE\\n                )\\n            );\\n    }\\n\\n    /// @dev Parse Reverse Name into Address + Coin Type.\\n    ///      Matches: `/^[0-9a-fA-F]+\\\\.([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @return addressBytes The address or empty if invalid.\\n    /// @return coinType The coin type.\\n    function parse(\\n        bytes memory name\\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\\n        bool valid;\\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\\n        if (!valid || addressBytes.length == 0) return (\\\"\\\", 0); // addressBytes not 1+ hex\\n        (valid, coinType) = parseNamespace(name, offset);\\n        if (!valid) return (\\\"\\\", 0); // invalid namespace\\n    }\\n\\n    /// @dev Parse Reverse Namespace into Coin Type.\\n    ///      Matches: `/^([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset to begin parsing.\\n    /// @return valid True if a valid reverse namespace.\\n    /// @return coinType The coin type.\\n    function parseNamespace(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bool valid, uint256 coinType) {\\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\\n            name,\\n            offset\\n        );\\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\\n            coinType = COIN_TYPE_ETH;\\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\\n            coinType = COIN_TYPE_DEFAULT;\\n        } else if (labelHash == bytes32(0)) {\\n            return (false, 0); // no slug\\n        } else {\\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\\n                name,\\n                1 + offset,\\n                offsetTLD\\n            );\\n            if (!validHex) return (false, 0); // invalid coinType or too long\\n            coinType = uint256(word);\\n        }\\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\\n        (labelHash, ) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\\n        valid = true;\\n    }\\n}\\n\",\"keccak256\":\"0xd1af09b014028de4c50489bd58ae424273180bb96d95353d8eefd14845f31824\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary HexUtils {\\n    /// @dev Convert `hexString[off:end]` to `bytes32`.\\n    ///      Accepts 0-64 hex-chars.\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return word The parsed bytes32.\\n    /// @return valid True if the parse was successful.\\n    function hexStringToBytes32(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes32 word, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        if (nibbles > 64 || end > hexString.length) {\\n            return (bytes32(0), false); // too large or out of bounds\\n        }\\n        uint256 src;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n        }\\n        valid = unsafeBytes(src, 0, nibbles);\\n        assembly {\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\n            word := shr(shl(3, pad), mload(0)) // right align\\n        }\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `address`.\\n    ///      Accepts exactly 40 hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return addr The parsed address.\\n    /// @return valid True if the parse was successful.\\n    function hexToAddress(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (address addr, bool valid) {\\n        if (off + 40 != end) return (address(0), false); // wrong length\\n        bytes32 word;\\n        (word, valid) = hexStringToBytes32(hexString, off, end);\\n        addr = address(uint160(uint256(word)));\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `bytes`.\\n    ///      Accepts 0+ hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return v The parsed bytes.\\n    /// @return valid True if the parse was successful.\\n    function hexToBytes(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes memory v, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        v = new bytes((1 + nibbles) >> 1); // round up\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n            dst := add(v, 32)\\n        }\\n        valid = unsafeBytes(src, dst, nibbles);\\n    }\\n\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\n    ///      Matches: `/^[0-9a-f]*$/i`.\\n    /// @param src The memory offset of first hex-char of input.\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\n    /// @param nibbles The number of hex-chars to convert.\\n    /// @return valid True if all characters were hex.\\n    function unsafeBytes(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure returns (bool valid) {\\n        assembly {\\n            function getHex(c, i) -> ascii {\\n                c := byte(i, c)\\n                // chars 48-57: 0-9\\n                if and(gt(c, 47), lt(c, 58)) {\\n                    ascii := sub(c, 48)\\n                    leave\\n                }\\n                // chars 65-70: A-F\\n                if and(gt(c, 64), lt(c, 71)) {\\n                    ascii := add(sub(c, 65), 10)\\n                    leave\\n                }\\n                // chars 97-102: a-f\\n                if and(gt(c, 96), lt(c, 103)) {\\n                    ascii := add(sub(c, 97), 10)\\n                    leave\\n                }\\n                // invalid char\\n                ascii := 0x100\\n            }\\n            valid := true\\n            let end := add(src, nibbles)\\n            if and(nibbles, 1) {\\n                let b := getHex(mload(src), 0) // \\\"f\\\" -> 15\\n                mstore8(dst, b) // write ascii byte\\n                src := add(src, 1) // update pointers\\n                dst := add(dst, 1)\\n                if gt(b, 255) {\\n                    valid := false\\n                    src := end // terminate loop\\n                }\\n            }\\n            // prettier-ignore\\n            for {} lt(src, end) {\\n                src := add(src, 2) // 2 nibbles\\n                dst := add(dst, 1) // per byte\\n            } {\\n                let word := mload(src) // read word (left aligned)\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\"ff\\\" -> 255\\n                if gt(b, 255) {\\n                    valid := false\\n                    break\\n                }\\n                mstore8(dst, b) // write ascii byte\\n            }\\n        }\\n    }\\n\\n    /// @dev Format `address` as a hex string.\\n    /// @param addr The address to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function addressToHex(\\n        address addr\\n    ) internal pure returns (string memory hexString) {\\n        // return bytesToHex(abi.encodePacked(addr));\\n        hexString = new string(40);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, addr)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(12, dst, 40);\\n    }\\n\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\n    /// * unpaddedUintToHex(0, true)  = \\\"0\\\"\\n    /// * unpaddedUintToHex(1, true)  = \\\"1\\\"\\n    /// * unpaddedUintToHex(0, false) = \\\"00\\\"\\n    /// * unpaddedUintToHex(1, false) = \\\"01\\\"\\n    /// @param value The number to format.\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\n    function unpaddedUintToHex(\\n        uint256 value,\\n        bool dropZeroNibble\\n    ) internal pure returns (string memory hexString) {\\n        uint256 temp = value;\\n        uint256 shift;\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\n            if (temp < (1 << b)) {\\n                shift += b; // number of zero upper bits\\n            } else {\\n                temp >>= b; // shift away lower half\\n            }\\n        }\\n        if (dropZeroNibble && temp < 16) shift += 4;\\n        uint256 nibbles = 64 - (shift >> 2);\\n        hexString = new string(nibbles);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, shl(shift, value)) // left-align\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(0, dst, nibbles);\\n    }\\n\\n    /// @dev Format `bytes` as a hex string.\\n    /// @param v The bytes to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function bytesToHex(\\n        bytes memory v\\n    ) internal pure returns (string memory hexString) {\\n        uint256 nibbles = v.length << 1;\\n        hexString = new string(nibbles);\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(v, 32)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(src, dst, nibbles);\\n    }\\n\\n    /// @dev Converts arbitrary memory to a hex string.\\n    /// @param src The memory offset of first nibble of input.\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\n    function unsafeHex(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure {\\n        unchecked {\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(src)\\n                }\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\"a\\\" - 10) => 0x57\\n                    assembly {\\n                        mstore8(dst, b)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab784cab15b7a06154be3555edf0d25bcdad8e6bf116aa2016119a233875b02b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibABI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\nlibrary LibABI {\\n    /// @dev Safely decode abi-encoded `bytes`.\\n    function tryDecodeBytes(\\n        bytes memory v\\n    ) internal pure returns (bool ok, bytes memory value) {\\n        unchecked {\\n            uint256 need = 32;\\n            if (v.length >= need) {\\n                uint256 offset = uint256(bytes32(v));\\n                need += offset;\\n                if (v.length >= need) {\\n                    uint256 size = uint256(BytesUtils.readBytes32(v, offset));\\n                    if (v.length >= need + size) {\\n                        return (\\n                            true,\\n                            BytesUtils.substring(v, offset + 32, size)\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb7b1016151f46e66df989dca91c80278343cb23e13162d0ba51278b0d360a8fb\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "UnreachableName(bytes)": [
        {
          "notice": "`name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace."
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "notice": "`resolve()` was called with a profile other than `name()` or `addr(*)`."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "chainId()": {
        "notice": "The EVM Chain ID derived from `coinType()`."
      },
      "chainRegistrar()": {
        "notice": "The reverse registrar address on the corresponding chain.         The address returned by `addr(coinType)` for the resolver."
      },
      "coinType()": {
        "notice": "The coin type for the resolver."
      },
      "defaultRegistrar()": {
        "notice": "The reverse registrar contract for \"default.reverse\"."
      },
      "resolve(bytes,bytes)": {
        "notice": "Resolves the following profiles according to ENSIP-10:         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.         Caller should enable EIP-3668."
      },
      "resolveNames(address[])": {
        "notice": "Resolve multiple EVM addresses to names.         Caller should enable EIP-3668."
      }
    },
    "notice": "Reverses an EVM address using the first non-null response from the following sources: 1. `IStandaloneReverseRegistrar` for \"addr.reverse\" 2. `name()` from \"{addr}.addr.reverse\" in V1 Registry 3. `IStandaloneReverseRegistrar` for \"default.reverse\"",
    "version": 1
  },
  "argsData": "0x000000000000000000000000cf7ed3acca5a467e9e704c703e8d87f634fb0fc90000000000000000000000000165878a594ca255338adfa4d48449f69242eb8f000000000000000000000000f5059a5d33d5853360d16c683c16e67980206f36",
  "transaction": {
    "hash": "0x59a3e50c5e04a918e9d413f93fecbfd187de4351edd4db6082f3c632eac4ca99",
    "nonce": "0x2b",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x1899e69105de8e35ddd7f8ad421c4de899900ea870183d947bc803627bcecc65",
    "blockNumber": "0x30",
    "transactionIndex": "0x0"
  }
}
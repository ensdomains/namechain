{
  "address": "0x2bdcc0de6be1f7d2ee689a0342d76f52e8efaba3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract INameWrapper",
          "name": "nameWrapper",
          "type": "address"
        },
        {
          "internalType": "contract IPermissionedRegistry",
          "name": "ethRegistry",
          "type": "address"
        },
        {
          "internalType": "contract VerifiableFactory",
          "name": "factory",
          "type": "address"
        },
        {
          "internalType": "contract IRegistryDatastore",
          "name": "datastore",
          "type": "address"
        },
        {
          "internalType": "contract IHCAFactoryBasic",
          "name": "hcaFactory",
          "type": "address"
        },
        {
          "internalType": "contract IRegistryMetadata",
          "name": "metadataProvider",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "fallbackResolver",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "AccessDenied",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "AddressEmptyCode",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "oldExpiration",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "newExpiration",
          "type": "uint64"
        }
      ],
      "name": "CannotReduceExpiration",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "expiry",
          "type": "uint64"
        }
      ],
      "name": "CannotSetPastExpiration",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "EACCannotGrantRoles",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "EACCannotRevokeRoles",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EACInvalidAccount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        }
      ],
      "name": "EACInvalidRoleBitmap",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "role",
          "type": "uint256"
        }
      ],
      "name": "EACMaxAssignees",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "role",
          "type": "uint256"
        }
      ],
      "name": "EACMinAssignees",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EACRootResourceNotAllowed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "EACUnauthorizedAccountRoles",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "needed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC1155InsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "approver",
          "type": "address"
        }
      ],
      "name": "ERC1155InvalidApprover",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "idsLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "valuesLength",
          "type": "uint256"
        }
      ],
      "name": "ERC1155InvalidArrayLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "ERC1155InvalidOperator",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "ERC1155InvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ERC1155InvalidSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "ERC1155MissingApprovalForAll",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "ERC1967InvalidImplementation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC1967NonPayable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "label",
          "type": "string"
        }
      ],
      "name": "LabelNotMigrated",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "label",
          "type": "string"
        }
      ],
      "name": "NameAlreadyRegistered",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "NameExpired",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "NameNotEmancipated",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoParentDomain",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        }
      ],
      "name": "ParentNotMigrated",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        }
      ],
      "name": "TransferDisallowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UUPSUnauthorizedCallContext",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "slot",
          "type": "bytes32"
        }
      ],
      "name": "UUPSUnsupportedProxiableUUID",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "UnauthorizedCaller",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldRoleBitmap",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newRoleBitmap",
          "type": "uint256"
        }
      ],
      "name": "EACRolesChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newExpiry",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "changedBy",
          "type": "address"
        }
      ],
      "name": "ExpiryUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "label",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "expiry",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "registeredBy",
          "type": "address"
        }
      ],
      "name": "NameRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        }
      ],
      "name": "ResolverUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "contract IRegistry",
          "name": "subregistry",
          "type": "address"
        }
      ],
      "name": "SubregistryUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "oldTokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "newTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "resource",
          "type": "uint256"
        }
      ],
      "name": "TokenRegenerated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "TransferBatch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TransferSingle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "value",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "URI",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DATASTORE",
      "outputs": [
        {
          "internalType": "contract IRegistryDatastore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ETH_REGISTRY",
      "outputs": [
        {
          "internalType": "contract IPermissionedRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FACTORY",
      "outputs": [
        {
          "internalType": "contract VerifiableFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FALLBACK_RESOLVER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HCA_FACTORY",
      "outputs": [
        {
          "internalType": "contract IHCAFactoryBasic",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "METADATA_PROVIDER",
      "outputs": [
        {
          "internalType": "contract IRegistryMetadata",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "NAME_WRAPPER",
      "outputs": [
        {
          "internalType": "contract INameWrapper",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_RESOURCE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "UPGRADE_INTERFACE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "accounts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        }
      ],
      "name": "balanceOfBatch",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        }
      ],
      "name": "getAssigneeCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "counts",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "mask",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        }
      ],
      "name": "getEntry",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "expiry",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "tokenVersionId",
              "type": "uint32"
            },
            {
              "internalType": "contract IRegistry",
              "name": "subregistry",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "eacVersionId",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "resolver",
              "type": "address"
            }
          ],
          "internalType": "struct IRegistryDatastore.Entry",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        }
      ],
      "name": "getExpiry",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "label",
          "type": "string"
        }
      ],
      "name": "getNameData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "expiry",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "tokenVersionId",
              "type": "uint32"
            },
            {
              "internalType": "contract IRegistry",
              "name": "subregistry",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "eacVersionId",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "resolver",
              "type": "address"
            }
          ],
          "internalType": "struct IRegistryDatastore.Entry",
          "name": "entry",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "label",
          "type": "string"
        }
      ],
      "name": "getResolver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        }
      ],
      "name": "getResource",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "label",
          "type": "string"
        }
      ],
      "name": "getSubregistry",
      "outputs": [
        {
          "internalType": "contract IRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        }
      ],
      "name": "getTokenId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRoles",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRootRoles",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        }
      ],
      "name": "hasAssignees",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "rolesBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRoles",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "rolesBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRootRoles",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "parentDnsEncodedName_",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "ownerAddress_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "ownerRoles_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "registrarAddress_",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "latestOwnerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "parentDnsEncodedName",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "label",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "contract IRegistry",
          "name": "registry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "expires",
          "type": "uint64"
        }
      ],
      "name": "register",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "newExpiry",
          "type": "uint64"
        }
      ],
      "name": "renew",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRoles",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "roleBitmap",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRootRoles",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        }
      ],
      "name": "roleCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "roles",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeBatchTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        }
      ],
      "name": "setResolver",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "anyId",
          "type": "uint256"
        },
        {
          "internalType": "contract IRegistry",
          "name": "registry",
          "type": "address"
        }
      ],
      "name": "setSubregistry",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "uri",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "MigratedWrappedNameRegistry",
  "sourceName": "src/registry/MigratedWrappedNameRegistry.sol",
  "bytecode": "0x6101806040523060e052348015610014575f80fd5b5060405161671f38038061671f83398101604081905261003391610ec9565b83838361003e6100a2565b6001600160a01b0380841660805280851660a052821660c0525f610064818084816100b0565b5050506001600160a01b03808b16610100528981166101405288811661012052841661016052506100969150506101b4565b50505050505050611228565b5f6100ab610251565b905090565b5f6100ba846102ee565b6001600160a01b0383166100e15760405163761fe2c960e11b815260040160405180910390fd5b5f8581526002602090815260408083206001600160a01b03871684529091529020548481178082146101a6575f8781526002602090815260408083206001600160a01b038916845290915290208190558119861661014188826001610337565b841561015457610154888785858b610467565b60408051848152602081018490526001600160a01b038816918a917f0d35bf721a39b614de00ca5038e1deb0cb0c69a278645e83405a7226cf80ba3c910160405180910390a3600193505050506101ac565b5f925050505b949350505050565b5f6101bd610477565b805490915068010000000000000000900460ff16156101ef5760405163f92ee8a960e01b815260040160405180910390fd5b80546001600160401b039081161461024e5780546001600160401b0319166001600160401b0390811782556040519081527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50565b6080515f906001600160a01b031661026857503390565b60805160405163110ac5cb60e21b81523360048201525f916001600160a01b03169063442b172c90602401602060405180830381865afa1580156102ae573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102d29190610f60565b90506001600160a01b0381166102e9573391505090565b919050565b7feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81161561024e57604051630153d96960e51b8152600481018290526024015b60405180910390fd5b5f610341836104a1565b905081156103d7575f848152600360205260409020546103879082161980195f805160206166ff83398151915291909101165f805160206166df83398151915216151590565b156103af57604051631f22ca6960e31b8152600481018590526024810184905260440161032e565b5f84815260036020526040812080548592906103cc908490610f96565b909155506104619050565b5f84815260036020526040902054610416901982161980195f805160206166ff83398151915291909101165f805160206166df83398151915216151590565b1561043e57604051631f80c19b60e01b8152600481018590526024810184905260440161032e565b5f848152600360205260408120805485929061045b908490610fa9565b90915550505b50505050565b610470856104bb565b5050505050565b5f807ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005b92915050565b5f6104ab826102ee565b50600181901b17600281901b1790565b5f6104c58261063f565b80519091506001600160401b031642101561063b575f6104e583836106d5565b5f818152602081905260409020549091506001600160a01b0316801561046157610511818360016106f9565b82602001805161052090610fbc565b63ffffffff90811690915260a0516040805163c0f8a73160e01b81526004810186905286516001600160401b03166024820152602087015184166044820152908601516001600160a01b039081166064830152606087015190931660848201526080860151831660a482015291169063c0f8a7319060c4015f604051808303815f87803b1580156105af575f80fd5b505af11580156105c1573d5f803e3d5ffd5b505050505f6105d683856106d560201b60201c565b90506105f98282600160405180602001604052805f81525061075f60201b60201c565b80837f88d074c8fc078bb1c0b9cfa9e3ca1f65a96141df8b0da854fe3083df813cbcca61062682886107c2565b60405190815260200160405180910390a35050505b5050565b6040805160a080820183525f808352602083018190528284018190526060830181905260808301525191516305c53a0760e51b81523060048201526024810184905290916001600160a01b03169063b8a740e09060440160a060405180830381865afa1580156106b1573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061049b9190610ff1565b60208101515f9063ffffffff166106f18463ffffffff81161890565b179392505050565b6001600160a01b03831661072157604051626a0d4560e21b81525f600482015260240161032e565b604080516001808252602082018590528183019081526060820184905260a082019092525f6080820181815291929161047091879185908590610805565b6001600160a01b03841661078857604051632bfa23e760e11b81525f600482015260240161032e565b604080516001808252602082018690528183019081526060820185905260808201909252906107ba5f87848487610805565b505050505050565b80515f906001600160401b03164210156107e05781606001516107f0565b60608201516107f0906001611093565b63ffffffff166106f18463ffffffff81161890565b61081185858585610861565b6001600160a01b03841615610470575f6108296100a2565b90508351600103610853576020848101519084015161084c838989858589610971565b50506107ba565b6107ba818787878787610a9b565b5f6001600160a01b0384161580159061088257506001600160a01b03851615155b90508015610919575f5b8351811015610917576108c38482815181106108aa576108aa6110b7565b6020026020010151600160901b88610b8260201b60201c565b61090f578381815181106108d9576108d96110b7565b6020026020010151866040516372c7b6ad60e11b815260040161032e9291909182526001600160a01b0316602082015260400190565b60010161088c565b505b61092585858585610be1565b8015610470575f5b83518110156107ba5761096961096185838151811061094e5761094e6110b7565b6020026020010151610dea60201b60201c565b87875f610dfd565b60010161092d565b6001600160a01b0384163b156107ba5760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e61906109b590899089908890889088906004016110f9565b6020604051808303815f875af19250505080156109ef575060408051601f3d908101601f191682019092526109ec9181019061113d565b60015b610a56573d808015610a1c576040519150601f19603f3d011682016040523d82523d5f602084013e610a21565b606091505b5080515f03610a4e57604051632bfa23e760e11b81526001600160a01b038616600482015260240161032e565b805181602001fd5b6001600160e01b0319811663f23a6e6160e01b14610a9257604051632bfa23e760e11b81526001600160a01b038616600482015260240161032e565b50505050505050565b6001600160a01b0384163b156107ba5760405163bc197c8160e01b81526001600160a01b0385169063bc197c8190610adf908990899088908890889060040161119e565b6020604051808303815f875af1925050508015610b19575060408051601f3d908101601f19168201909252610b169181019061113d565b60015b610b46573d808015610a1c576040519150601f19603f3d011682016040523d82523d5f602084013e610a21565b6001600160e01b0319811663bc197c8160e01b14610a9257604051632bfa23e760e11b81526001600160a01b038616600482015260240161032e565b5f6101ac610b8f85610dea565b5f9081526002602090815260408083206001600160a01b03871684528252808320547fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b90925290912054178416841490565b8051825114610c105781518151604051635b05999160e01b81526004810192909252602482015260440161032e565b5f610c196100a2565b90505f5b8351811015610d0c576020818102858101820151908501909101518015610d02575f828152602081905260409020546001600160a01b039081169089168114610c98576040516303dee4c560e01b81526001600160a01b038a1660048201525f6024820152604481018390526064810184905260840161032e565b6001821115610cda576040516303dee4c560e01b81526001600160a01b038a16600482015260016024820152604481018390526064810184905260840161032e565b505f82815260208190526040902080546001600160a01b0319166001600160a01b0389161790555b5050600101610c1d565b508251600103610d8c5760208301515f906020840151909150856001600160a01b0316876001600160a01b0316846001600160a01b03167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f628585604051610d7d929190918252602082015260400190565b60405180910390a45050610470565b836001600160a01b0316856001600160a01b0316826001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb8686604051610ddb9291906111fb565b60405180910390a45050505050565b5f61049b82610df88161063f565b6107c2565b5f8481526002602090815260408083206001600160a01b0387168452909152902054801561047057610e3185828685610e3e565b506107ba858285856100b0565b5f610e48846102ee565b5f8581526002602090815260408083206001600160a01b0387168452909152902054841981168082146101a6575f8781526002602090815260408083206001600160a01b03891684529091528120829055868316906101419089908390610337565b6001600160a01b038116811461024e575f80fd5b80516102e981610eaa565b5f805f805f805f60e0888a031215610edf575f80fd5b8751610eea81610eaa565b6020890151909750610efb81610eaa565b6040890151909650610f0c81610eaa565b6060890151909550610f1d81610eaa565b6080890151909450610f2e81610eaa565b60a0890151909350610f3f81610eaa565b60c0890151909250610f5081610eaa565b8091505092959891949750929550565b5f60208284031215610f70575f80fd5b8151610f7b81610eaa565b9392505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561049b5761049b610f82565b8181038181111561049b5761049b610f82565b5f63ffffffff808316818103610fd457610fd4610f82565b6001019392505050565b805163ffffffff811681146102e9575f80fd5b5f60a08284031215611001575f80fd5b60405160a081016001600160401b03808211838310171561103057634e487b7160e01b5f52604160045260245ffd5b81604052845191508082168214611045575f80fd5b50815261105460208401610fde565b602082015261106560408401610ebe565b604082015261107660608401610fde565b606082015261108760808401610ebe565b60808201529392505050565b63ffffffff8181168382160190808211156110b0576110b0610f82565b5092915050565b634e487b7160e01b5f52603260045260245ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f90611132908301846110cb565b979650505050505050565b5f6020828403121561114d575f80fd5b81516001600160e01b031981168114610f7b575f80fd5b5f815180845260208085019450602084015f5b8381101561119357815187529582019590820190600101611177565b509495945050505050565b6001600160a01b0386811682528516602082015260a0604082018190525f906111c990830186611164565b82810360608401526111db8186611164565b905082810360808401526111ef81856110cb565b98975050505050505050565b604081525f61120d6040830185611164565b828103602084015261121f8185611164565b95945050505050565b60805160a05160c05160e051610100516101205161014051610160516153b461132b5f395f81816109ff01526117f901525f8181610618015261312f01525f81816104cd01526124da01525f81816104500152818161145f0152818161175e015281816118420152818161219101528181612231015281816123ce015281816126050152818161321201526132aa01525f8181611ee501528181611f0e015261209c01525f818161069e01528181611c780152611ce601525f81816105e501528181610c5e01528181610f49015281816113ea0152818161153401528181612e3901526137fa01525f81816105400152818161294501526129a601526153b45ff3fe6080604052600436106102ec575f3560e01c8063531b9d6d11610186578063bae78d7b116100dc578063dfa70d8b11610087578063f23a6e6111610062578063f23a6e61146109b0578063f242432a146109cf578063fa7e0fd3146109ee575f80fd5b8063dfa70d8b1461092b578063e4ae7d771461094a578063e985e9c514610969575f80fd5b8063bd242bcb116100b7578063bd242bcb146108ce578063ce156e82146108ed578063d3bf89b11461090c575f80fd5b8063bae78d7b1461084b578063bc197c8114610877578063bc7b6d62146108af575f80fd5b806378430b5a1161013c578063a22cb46511610117578063a22cb465146107c5578063ad3cb1cc146107e4578063b08a2c9c1461082c575f80fd5b806378430b5a146107735780637c3005861461078757806385f3e643146107a6575f80fd5b80635adf47241161016c5780635adf4724146106df5780636352211e146106fe578063781ef8db1461071d575f80fd5b8063531b9d6d1461068d5780635569f33d146106c0575f80fd5b80632dd31000116102465780633634f911116101f15780634e1273f4116101cc5780634e1273f41461063a5780634f1ef2861461066657806352d1902d14610679575f80fd5b80633634f911146105a05780633f7cefce146105d45780634750070814610607575f80fd5b8063319c22bb11610221578063319c22bb1461052f578063341ec5591461056257806335af621614610581575f80fd5b80632dd31000146104bc5780632eb2c2d6146104ef5780632f27fa2414610510575f80fd5b806311b8e00a116102a6578063192cf07d11610281578063192cf07d1461043f5780631c3fc3eb1461048a5780631e8fca2d1461049d575f80fd5b806311b8e00a146103c957806313c72608146103e857806314ff5ea314610420575f80fd5b8063072d5d77116102d6578063072d5d77146103515780630a796374146103705780630e89341c1461039d575f80fd5b8062fdd58e146102f057806301ffc9a714610322575b5f80fd5b3480156102fb575f80fd5b5061030f61030a3660046142c7565b610a21565b6040519081526020015b60405180910390f35b34801561032d575f80fd5b5061034161033c366004614306565b610a58565b6040519015158152602001610319565b34801561035c575f80fd5b5061034161036b366004614321565b610a95565b34801561037b575f80fd5b5061038f61038a366004614442565b610ac0565b604051610319929190614487565b3480156103a8575f80fd5b506103bc6103b73660046144ec565b610b12565b6040516103199190614531565b3480156103d4575f80fd5b506103416103e3366004614543565b610b1d565b3480156103f3575f80fd5b506104076104023660046144ec565b610b37565b60405167ffffffffffffffff9091168152602001610319565b34801561042b575f80fd5b5061030f61043a3660046144ec565b610b48565b34801561044a575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610319565b348015610495575f80fd5b5061030f5f81565b3480156104a8575f80fd5b5061030f6104b73660046144ec565b610b5b565b3480156104c7575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b3480156104fa575f80fd5b5061050e61050936600461460b565b610b6e565b005b34801561051b575f80fd5b5061030f61052a3660046144ec565b610c0b565b34801561053a575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b34801561056d575f80fd5b5061050e61057c366004614321565b610c29565b34801561058c575f80fd5b5061047261059b3660046146f0565b610d07565b3480156105ab575f80fd5b506105bf6105ba366004614543565b610d74565b60408051928352602083019190915201610319565b3480156105df575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b348015610612575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b348015610645575f80fd5b5061065961065436600461472f565b610d94565b6040516103199190614825565b61050e610674366004614837565b610e5f565b348015610684575f80fd5b5061030f610e7e565b348015610698575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b3480156106cb575f80fd5b5061050e6106da36600461489a565b610eac565b3480156106ea575f80fd5b5061030f6106f9366004614321565b611000565b348015610709575f80fd5b506104726107183660046144ec565b611032565b348015610728575f80fd5b50610341610737366004614321565b6001600160a01b03165f9081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205481161490565b34801561077e575f80fd5b506103bc61108f565b348015610792575f80fd5b506103416107a13660046148bd565b61111b565b3480156107b1575f80fd5b5061030f6107c03660046148f3565b61112f565b3480156107d0575f80fd5b5061050e6107df366004614993565b611196565b3480156107ef575f80fd5b506103bc6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b348015610837575f80fd5b5061050e6108463660046149bf565b6111a8565b348015610856575f80fd5b5061086a6108653660046144ec565b611387565b6040516103199190614a2e565b348015610882575f80fd5b50610896610891366004614ace565b611453565b6040516001600160e01b03199091168152602001610319565b3480156108ba575f80fd5b5061050e6108c9366004614321565b611501565b3480156108d9575f80fd5b506104726108e83660046144ec565b6115d3565b3480156108f8575f80fd5b50610341610907366004614321565b6115ef565b348015610917575f80fd5b506103416109263660046148bd565b611611565b348015610936575f80fd5b506103416109453660046148bd565b611670565b348015610955575f80fd5b506104726109643660046146f0565b611684565b348015610974575f80fd5b50610341610983366004614b85565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205460ff1690565b3480156109bb575f80fd5b506108966109ca366004614bb1565b611836565b3480156109da575f80fd5b5061050e6109e9366004614c28565b61197e565b3480156109f9575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b5f826001600160a01b0316610a3583611032565b6001600160a01b031614610a49575f610a4c565b60015b60ff1690505b92915050565b5f6001600160e01b031982167f4e2312e0000000000000000000000000000000000000000000000000000000001480610a525750610a5282611a0e565b5f8083610aaa8282610aa5611a4b565b611a59565b610ab75f86866001611b20565b95945050505050565b6040805160a0810182525f8082526020820181905291810182905260608101829052608081018290525f610af384611c3b565b9050610afe81611387565b9150610b0a8183611c51565b925050915091565b6060610a5282611c74565b5f610b30610b2a84610b5b565b83611d59565b9392505050565b5f610b4182611387565b5192915050565b5f610a5282610b5684611387565b611c51565b5f610a5282610b6984611387565b611d70565b5f610b77611a4b565b9050806001600160a01b0316866001600160a01b031614158015610bc057506001600160a01b038087165f9081526001602090815260408083209385168352929052205460ff16155b15610bf65760405163711bec9160e11b81526001600160a01b038083166004830152871660248201526044015b60405180910390fd5b610c038686868686611db4565b505050505050565b5f610a52610c1883610b5b565b5f9081526003602052604090205490565b5f80610c3784610100611e19565b6001600160a01b038086166040808401919091525163c0f8a73160e01b81529294509092507f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a73190610c959085908590600401614487565b5f604051808303815f87803b158015610cac575f80fd5b505af1158015610cbe573d5f803e3d5ffd5b50506040516001600160a01b03861681528492507fca01ade22fed8a886bda52d1fb12deaff178499347b6c13b1a892a60985a51e291506020015b60405180910390a250505050565b5f80610d4a61086585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611c3b92505050565b805190915067ffffffffffffffff16421015610d6a578060400151610d6c565b5f5b949350505050565b5f80610d88610d8285610b5b565b84611eb7565b915091505b9250929050565b60608151835114610dc55781518351604051635b05999160e01b815260048101929092526024820152604401610bed565b5f835167ffffffffffffffff811115610de057610de061434f565b604051908082528060200260200182016040528015610e09578160200160208202803683370190505b5090505f5b8451811015610e5757602080820286010151610e3290602080840287010151610a21565b828281518110610e4457610e44614c8c565b6020908102919091010152600101610e0e565b509392505050565b610e67611eda565b610e7082611f93565b610e7a8282611fa4565b5050565b5f610e87612091565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b5f80610eb9846010611e19565b91509150805f015167ffffffffffffffff168367ffffffffffffffff161015610f255780516040517f9967595a00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff91821660048201529084166024820152604401610bed565b67ffffffffffffffff8316815260405163c0f8a73160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a73190610f809085908590600401614487565b5f604051808303815f87803b158015610f97575f80fd5b505af1158015610fa9573d5f803e3d5ffd5b50505050817f3260962d42d8f7ae0af25cbfdb2983c214a859cfa2ac6df8ea29b534c267d42984610fd8611a4b565b6040805167ffffffffffffffff90931683526001600160a01b03909116602083015201610cf9565b5f610b3061100d84610b5b565b5f9081526002602090815260408083206001600160a01b038716845290915290205490565b5f8061103d83611387565b90506110498382611c51565b831415806110625750805167ffffffffffffffff164210155b611087575f838152602081905260409020546001600160a01b0316610b30565b610b30565b5f9392505050565b6004805461109c90614ca0565b80601f01602080910402602001604051908101604052809291908181526020018280546110c890614ca0565b80156111135780601f106110ea57610100808354040283529160200191611113565b820191905f5260205f20905b8154815290600101906020018083116110f657829003601f168201915b505050505081565b5f610d6c61112885610b5b565b84846120da565b5f60016111445f8261113f611a4b565b612115565b61118989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b92508a9150899050888861216f565b9998505050505050505050565b610e7a6111a1611a4b565b83836122ea565b5f6111b1612398565b805490915060ff68010000000000000000820416159067ffffffffffffffff165f811580156111dd5750825b90505f8267ffffffffffffffff1660011480156111f95750303b155b905081158015611207575080155b1561123e576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561127257845468ff00000000000000001916680100000000000000001785555b6001600160a01b0388166112e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4f776e65722063616e6e6f74206265207a65726f2061646472657373000000006044820152606401610bed565b60046112ef8a8c83614d1c565b506113115f721000000000000000000000000000000010000089178a82611b20565b506001600160a01b038616156113305761132e5f6001885f611b20565b505b831561137b57845468ff000000000000000019168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50505050505050505050565b6040805160a0810182525f8082526020820181905281830181905260608201819052608082015290517fb8a740e0000000000000000000000000000000000000000000000000000000008152306004820152602481018390526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063b8a740e09060440160a060405180830381865afa15801561142f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a529190614de9565b5f336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461149f5760405163d86ad9cf60e01b8152336004820152602401610bed565b5f6114ac83850185614f57565b90506114eb8888808060200260200160405190810160405280939291908181526020018383602002808284375f920191909152508592506123c0915050565b5063bc197c8160e01b9998505050505050505050565b5f8061150f84611000611e19565b6001600160a01b03808616608083015260405163c0f8a73160e01b81529294509092507f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a7319061156b9085908590600401614487565b5f604051808303815f87803b158015611582575f80fd5b505af1158015611594573d5f803e3d5ffd5b50506040516001600160a01b03861681528492507f3c055b8ebff34805cc0c0216cfd96bfe2613c75002ce000f6268324952541d069150602001610cf9565b5f818152602081905260408120546001600160a01b0316610a52565b5f808361160482826115ff611a4b565b612655565b610ab75f8686600161273e565b5f610d6c61161e85610b5b565b5f9081526002602090815260408083206001600160a01b03871684528252808320547fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b90925290912054178416841490565b5f610d6c61167d85610b5b565b84846127aa565b5f8061174161171b6004805461169990614ca0565b80601f01602080910402602001604051908101604052809291908181526020018280546116c590614ca0565b80156117105780601f106116e757610100808354040283529160200191611710565b820191905f5260205f20905b8154815290600101906020018083116116f357829003601f168201915b50505050505f6127e5565b858560405161172b929190615001565b60405180910390205f9182526020526040902090565b604051630178fe3f60e01b8152600481018290529091505f9081907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630178fe3f90602401606060405180830381865afa1580156117ab573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117cf9190615010565b5090925090506001600160a01b03821630148015906117f2575062010000811615155b15611822577f00000000000000000000000000000000000000000000000000000000000000009350505050610a52565b61182c8686612816565b9695505050505050565b5f336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146118825760405163d86ad9cf60e01b8152336004820152602401610bed565b5f61188f8385018561504b565b6040805160018082528183019092529192505f9190816020015b604080516101008101825260609181018281525f9282018390526080820183905260a0820183905260c0820183905260e08201839052815260208101919091528152602001906001900390816118a957905050905081815f8151811061191157611911614c8c565b60209081029190910101526040805160018082528183019092525f9181602001602082028036833701905050905087815f8151811061195257611952614c8c565b60200260200101818152505061196881836123c0565b5063f23a6e6160e01b9998505050505050505050565b5f611987611a4b565b9050806001600160a01b0316866001600160a01b0316141580156119d057506001600160a01b038087165f9081526001602090815260408083209385168352929052205460ff16155b15611a015760405163711bec9160e11b81526001600160a01b03808316600483015287166024820152604401610bed565b610c038686868686612879565b5f6001600160e01b031982167f07ca514a000000000000000000000000000000000000000000000000000000001480610a525750610a5282612905565b5f611a54612942565b905090565b5f611ac484836001600160a01b03165f8181527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b60209081526040808320549483526002825280832093835292905220546f11111111111111111111111111111111911760801c1690565b90508019831615611b1a576040517fd1a3b35500000000000000000000000000000000000000000000000000000000815260048101859052602481018490526001600160a01b0383166044820152606401610bed565b50505050565b5f611b2a84612a33565b6001600160a01b038316611b6a576040517fec3fc59200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8581526002602090815260408083206001600160a01b0387168452909152902054848117808214611c2f575f8781526002602090815260408083206001600160a01b0389168452909152902081905581198616611bca88826001612a93565b8415611bdd57611bdd888785858b612c28565b60408051848152602081018490526001600160a01b038816918a917f0d35bf721a39b614de00ca5038e1deb0cb0c69a278645e83405a7226cf80ba3c910160405180910390a360019350505050610d6c565b505f9695505050505050565b805160208201205f9063ffffffff811618610a52565b5f816020015163ffffffff16611c6c8463ffffffff81161890565b179392505050565b60607f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316611cb757505060408051602081019091525f815290565b6040517f1675f455000000000000000000000000000000000000000000000000000000008152600481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631675f455906024015f60405180830381865afa158015611d32573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a52919081019061507d565b5f80611d658484610d74565b501515949350505050565b80515f9067ffffffffffffffff16421015611d8f578160600151611d9f565b6060820151611d9f906001615106565b63ffffffff16611c6c8463ffffffff81161890565b6001600160a01b038416611ddd57604051632bfa23e760e11b81525f6004820152602401610bed565b6001600160a01b038516611e0557604051626a0d4560e21b81525f6004820152602401610bed565b611e128585858585612c31565b5050505050565b6040805160a0810182525f808252602082018190529181018290526060810182905260808101829052611e4b84611387565b9050611e578482611c51565b815190925067ffffffffffffffff164210611ea1576040517f0c23d84000000000000000000000000000000000000000000000000000000000815260048101839052602401610bed565b610d8d611eae8583611d70565b8461113f611a4b565b5f80611ec283612c8d565b5f948552600360205260409094205484169492505050565b306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161480611f7357507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316611f677f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b6001600160a01b031614155b15611f915760405163703e46dd60e11b815260040160405180910390fd5b565b62100000610e7a5f8261113f611a4b565b816001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611ffe575060408051601f3d908101601f19168201909252611ffb9181019061512a565b60015b61202657604051634c9c8ce360e01b81526001600160a01b0383166004820152602401610bed565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114612082576040517faa1d49a400000000000000000000000000000000000000000000000000000000815260048101829052602401610bed565b61208c8383612ca7565b505050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611f915760405163703e46dd60e11b815260040160405180910390fd5b5f83836120ea8282610aa5611a4b565b8561210857604051631850848b60e31b815260040160405180910390fd5b61182c8686866001611b20565b612120838383611611565b61208c576040517f4b27a13300000000000000000000000000000000000000000000000000000000815260048101849052602481018390526001600160a01b0382166044820152606401610bed565b85516020870120604051630178fe3f60e01b8152600481018290525f919082907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630178fe3f90602401606060405180830381865afa1580156121de573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906122029190615010565b50915050620100008116156122dc576040516331a9108f60e11b81526004810183905230906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636352211e90602401602060405180830381865afa158015612276573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061229a9190615141565b6001600160a01b0316146122dc57886040517f3a7216b7000000000000000000000000000000000000000000000000000000008152600401610bed9190614531565b611189898989898989612cfc565b6001600160a01b03821661232c576040517fced3e1000000000000000000000000000000000000000000000000000000000081525f6004820152602401610bed565b6001600160a01b038381165f81815260016020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b5f807ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00610a52565b5f5b825181101561208c575f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316630178fe3f85848151811061240d5761240d614c8c565b60200260200101516040518263ffffffff1660e01b815260040161243391815260200190565b606060405180830381865afa15801561244e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124729190615010565b509150506124998185848151811061248c5761248c614c8c565b6020026020010151612f9b565b5f6124c38484815181106124af576124af614c8c565b60200260200101515f01515f01515f612fdc565b90505f806124d0846133f6565b915091505f61258f7f000000000000000000000000000000000000000000000000000000000000000061252a7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b89898151811061253c5761253c614c8c565b60200260200101515f015160200151858b8b8151811061255e5761255e614c8c565b6020026020010151602001518c8c8151811061257c5761257c614c8c565b60200260200101515f01515f01516134c7565b90506125ff848888815181106125a7576125a7614c8c565b60200260200101515f015160200151838a8a815181106125c9576125c9614c8c565b60200260200101515f015160600151878c8c815181106125eb576125eb614c8c565b60200260200101515f015160a0015161216f565b506126447f000000000000000000000000000000000000000000000000000000000000000089888151811061263657612636614c8c565b6020026020010151876135ce565b5050600190930192506123c2915050565b5f6126e884836001600160a01b03165f8181527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b60209081526040808320549483526002825280832093835292905220547f1111111111111111111111111111111100000000000000000000000000000000911790811660809190911c6f11111111111111111111111111111111161790565b90508019831615611b1a576040517fa604e31800000000000000000000000000000000000000000000000000000000815260048101859052602481018490526001600160a01b0383166044820152606401610bed565b5f61274884612a33565b5f8581526002602090815260408083206001600160a01b038716845290915290205484198116808214611c2f575f8781526002602090815260408083206001600160a01b0389168452909152812082905586831690611bca9089908390612a93565b5f83836127ba82826115ff611a4b565b856127d857604051631850848b60e31b815260040160405180910390fd5b61182c868686600161273e565b5f6127f083836136d5565b925090508015610a5257610b3061280784846127e5565b825f9182526020526040902090565b5f8061285961086585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611c3b92505050565b805190915067ffffffffffffffff16421015610d6a578060800151610d6c565b6001600160a01b0384166128a257604051632bfa23e760e11b81525f6004820152602401610bed565b6001600160a01b0385166128ca57604051626a0d4560e21b81525f6004820152602401610bed565b604080516001808252602082018690528183019081526060820185905260808201909252906128fc8787848487612c31565b50505050505050565b5f6001600160e01b031982167f8f452d62000000000000000000000000000000000000000000000000000000001480610a525750610a5282613702565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661297657503390565b6040517f442b172c0000000000000000000000000000000000000000000000000000000081523360048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063442b172c90602401602060405180830381865afa1580156129f3573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612a179190615141565b90506001600160a01b038116612a2e573391505090565b919050565b7feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee811615612a90576040517f2a7b2d2000000000000000000000000000000000000000000000000000000000815260048101829052602401610bed565b50565b5f612a9d83612c8d565b90508115612b66575f848152600360205260409020547f888888888888888888888888888888888888888888888888888888888888888890821680197feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef01161615612b3e576040517ff91653480000000000000000000000000000000000000000000000000000000081526004810185905260248101849052604401610bed565b5f8481526003602052604081208054859290612b5b90849061515c565b90915550611b1a9050565b5f848152600360205260409020547f88888888888888888888888888888888888888888888888888888888888888889019821680197feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef01161615612c00576040517f1f80c19b0000000000000000000000000000000000000000000000000000000081526004810185905260248101849052604401610bed565b5f8481526003602052604081208054859290612c1d90849061516f565b909155505050505050565b611e1285613775565b612c3d858585856138cb565b6001600160a01b03841615611e12575f612c55611a4b565b90508351600103612c7f5760208481015190840151612c788389898585896139f7565b5050610c03565b610c03818787878787613b18565b5f612c9782612a33565b50600181901b17600281901b1790565b612cb082613bff565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a2805115612cf45761208c8282613c82565b610e7a613ceb565b5f612d0687611c3b565b90505f612d1282611387565b805190915067ffffffffffffffff16421015612d4357876040516306dbb87d60e41b8152600401610bed9190614531565b67ffffffffffffffff83164210612d92576040517f6a0147dc00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff84166004820152602401610bed565b612d9c8282611c51565b5f818152602081905260409020549092506001600160a01b03168015612e0357612dc881846001613d23565b816060018051612dd790615182565b63ffffffff169052602082018051612dee90615182565b63ffffffff169052612e008383611c51565b92505b67ffffffffffffffff841682526001600160a01b0380881660408085019190915287821660808501525163c0f8a73160e01b81527f00000000000000000000000000000000000000000000000000000000000000009091169063c0f8a73190612e729086908690600401614487565b5f604051808303815f87803b158015612e89575f80fd5b505af1158015612e9b573d5f803e3d5ffd5b50505050827fd9d0e8edd77eacdd7bd3f1d10259814b1aa244f74019f036046bbcc622fdcf598a86612ecb611a4b565b604051612eda939291906151a4565b60405180910390a2612efd8884600160405180602001604052805f815250613d89565b612f12612f0a8484611d70565b868a5f611b20565b506040516001600160a01b038816815283907fca01ade22fed8a886bda52d1fb12deaff178499347b6c13b1a892a60985a51e29060200160405180910390a26040516001600160a01b038716815283907f3c055b8ebff34805cc0c0216cfd96bfe2613c75002ce000f6268324952541d069060200160405180910390a250509695505050505050565b6201000082165f03610e7a576040517ff7d2a5a800000000000000000000000000000000000000000000000000000000815260048101829052602401610bed565b60605f612fe98484613de4565b8551919350915084908290811061300257613002614c8c565b01602001517fff00000000000000000000000000000000000000000000000000000000000000165f03613061576040517fd169740700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8061306d8684613de4565b60408051808201909152600381527f657468000000000000000000000000000000000000000000000000000000000060209182015282519083012091935091507f4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f014801561311157508581815181106130e8576130e8614c8c565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b156131d557604051631ad7b10b60e11b81525f906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906335af621690613164908890600401614531565b602060405180830381865afa15801561317f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906131a39190615141565b90506001600160a01b038116156131cf57846040516306dbb87d60e41b8152600401610bed9190614531565b506133ed565b5f6131e087856127e5565b6040517ffd0cd0d9000000000000000000000000000000000000000000000000000000008152600481018290529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063fd0cd0d990602401602060405180830381865afa15801561325f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061328391906151df565b158061331f57506040516331a9108f60e11b81526004810182905230906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636352211e90602401602060405180830381865afa1580156132ef573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906133139190615141565b6001600160a01b031614155b1561335a5786846040517f26d8c94f000000000000000000000000000000000000000000000000000000008152600401610bed9291906151fa565b604051631ad7b10b60e11b81525f9030906335af62169061337f908990600401614531565b602060405180830381865afa15801561339a573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906133be9190615141565b90506001600160a01b038116156133ea57856040516306dbb87d60e41b8152600401610bed9190614531565b50505b50505092915050565b5f806002831615156204000084161561342c576010831792508061342c5770100000000000000000000000000000000092909217915b600884165f0361345b57611000831792508061345b577110000000000000000000000000000000000092909217915b600484165f0361347e577201000000000000000000000000000000000000831792505b602084165f036134ab57600182179150806134ab5770010000000000000000000000000000000091909117905b5090927010000000000000000000000000000000109091179150565b5f808286865f6040516024016134e0949392919061521b565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fb08a2c9c00000000000000000000000000000000000000000000000000000000179052517f5d84121a0000000000000000000000000000000000000000000000000000000081529091506001600160a01b03891690635d84121a90613582908a9088908690600401615256565b6020604051808303815f875af115801561359e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906135c29190615141565b98975050505050505050565b600881165f0361364d576040517f1896f70a000000000000000000000000000000000000000000000000000000008152600481018390525f60248201526001600160a01b03841690631896f70a906044015f604051808303815f87803b158015613636575f80fd5b505af1158015613648573d5f803e3d5ffd5b505050505b6040517f402906fc00000000000000000000000000000000000000000000000000000000815260048101839052603f60248201526001600160a01b0384169063402906fc906044016020604051808303815f875af11580156136b1573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b1a919061527d565b5f805f6136e28585613e61565b9250905060ff8116156136fa57806021858701012092505b509250929050565b5f6001600160e01b03198216636cdb3d1360e11b148061373257506001600160e01b031982166303a24d0760e21b145b8061376657506001600160e01b031982167fd1011f6100000000000000000000000000000000000000000000000000000000145b80610a525750610a5282613ede565b5f61377f82611387565b805190915067ffffffffffffffff16421015610e7a575f6137a08383611c51565b5f818152602081905260409020549091506001600160a01b03168015611b1a576137cc81836001613d23565b8260200180516137db90615182565b63ffffffff16905260405163c0f8a73160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a731906138319085908790600401614487565b5f604051808303815f87803b158015613848575f80fd5b505af115801561385a573d5f803e3d5ffd5b505050505f6138698385611c51565b90506138868282600160405180602001604052805f815250613d89565b80837f88d074c8fc078bb1c0b9cfa9e3ca1f65a96141df8b0da854fe3083df813cbcca6138b38688611d70565b60405190815260200160405180910390a35050505050565b5f6001600160a01b038416158015906138ec57506001600160a01b03851615155b905080156139a5575f5b83518110156139a35761393684828151811061391457613914614c8c565b6020026020010151720100000000000000000000000000000000000088611611565b61399b5783818151811061394c5761394c614c8c565b6020026020010151866040517fe58f6d5a000000000000000000000000000000000000000000000000000000008152600401610bed9291909182526001600160a01b0316602082015260400190565b6001016138f6565b505b6139b185858585613f61565b8015611e12575f5b8351811015610c03576139ef6139e78583815181106139da576139da614c8c565b6020026020010151610b5b565b87875f614177565b6001016139b9565b6001600160a01b0384163b15610c035760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e6190613a3b9089908990889088908890600401615296565b6020604051808303815f875af1925050508015613a75575060408051601f3d908101601f19168201909252613a72918101906152d8565b60015b613adc573d808015613aa2576040519150601f19603f3d011682016040523d82523d5f602084013e613aa7565b606091505b5080515f03613ad457604051632bfa23e760e11b81526001600160a01b0386166004820152602401610bed565b805181602001fd5b6001600160e01b0319811663f23a6e6160e01b146128fc57604051632bfa23e760e11b81526001600160a01b0386166004820152602401610bed565b6001600160a01b0384163b15610c035760405163bc197c8160e01b81526001600160a01b0385169063bc197c8190613b5c90899089908890889088906004016152f3565b6020604051808303815f875af1925050508015613b96575060408051601f3d908101601f19168201909252613b93918101906152d8565b60015b613bc3573d808015613aa2576040519150601f19603f3d011682016040523d82523d5f602084013e613aa7565b6001600160e01b0319811663bc197c8160e01b146128fc57604051632bfa23e760e11b81526001600160a01b0386166004820152602401610bed565b806001600160a01b03163b5f03613c3457604051634c9c8ce360e01b81526001600160a01b0382166004820152602401610bed565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b60605f80846001600160a01b031684604051613c9e9190615344565b5f60405180830381855af49150503d805f8114613cd6576040519150601f19603f3d011682016040523d82523d5f602084013e613cdb565b606091505b5091509150610ab78583836141b8565b3415611f91576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b038316613d4b57604051626a0d4560e21b81525f6004820152602401610bed565b604080516001808252602082018590528183019081526060820184905260a082019092525f60808201818152919291611e1291879185908590612c31565b6001600160a01b038416613db257604051632bfa23e760e11b81525f6004820152602401610bed565b60408051600180825260208201869052818301908152606082018590526080820190925290610c035f87848487612c31565b60605f80613df28585613e61565b925090505f60ff821667ffffffffffffffff811115613e1357613e1361434f565b6040519080825280601f01601f191660200182016040528015613e3d576020820181803683370190505b509050613e566020820160218888010160ff8516614228565b959194509092505050565b5f8083518310613e86578360405163ba4adc2360e01b8152600401610bed9190614531565b838381518110613e9857613e98614c8c565b016020015160f81c91505081810160010181613eb8578351811415613ebe565b83518110155b15610d8d578360405163ba4adc2360e01b8152600401610bed9190614531565b5f6001600160e01b03198216636cdb3d1360e11b1480613f0e57506001600160e01b031982166331a9108f60e11b145b80613f2957506001600160e01b031982166303a24d0760e21b145b80610a5257507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b0319831614610a52565b8051825114613f905781518151604051635b05999160e01b815260048101929092526024820152604401610bed565b5f613f99611a4b565b90505f5b835181101561409957602081810285810182015190850190910151801561408f575f828152602081905260409020546001600160a01b039081169089168114614018576040516303dee4c560e01b81526001600160a01b038a1660048201525f60248201526044810183905260648101849052608401610bed565b600182111561405a576040516303dee4c560e01b81526001600160a01b038a166004820152600160248201526044810183905260648101849052608401610bed565b505f828152602081905260409020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0389161790555b5050600101613f9d565b5082516001036141195760208301515f906020840151909150856001600160a01b0316876001600160a01b0316846001600160a01b03167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62858560405161410a929190918252602082015260400190565b60405180910390a45050611e12565b836001600160a01b0316856001600160a01b0316826001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb868660405161416892919061535a565b60405180910390a45050505050565b5f8481526002602090815260408083206001600160a01b03871684529091529020548015611e12576141ab8582868561273e565b50610c0385828585611b20565b6060826141c85761108282614271565b81511580156141df57506001600160a01b0384163b155b15614221576040517f9996b3150000000000000000000000000000000000000000000000000000000081526001600160a01b0385166004820152602401610bed565b5080610b30565b5b601f811115614249578151835260209283019290910190601f1901614229565b801561208c5790518251600160209390930360031b9290921b5f190180199091169116179052565b8051156142815780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b0381168114612a90575f80fd5b5f80604083850312156142d8575f80fd5b82356142e3816142b3565b946020939093013593505050565b6001600160e01b031981168114612a90575f80fd5b5f60208284031215614316575f80fd5b8135610b30816142f1565b5f8060408385031215614332575f80fd5b823591506020830135614344816142b3565b809150509250929050565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156143865761438661434f565b60405290565b60405160c0810167ffffffffffffffff811182821017156143865761438661434f565b604051601f8201601f1916810167ffffffffffffffff811182821017156143d8576143d861434f565b604052919050565b5f67ffffffffffffffff8211156143f9576143f961434f565b50601f01601f191660200190565b5f614419614414846143e0565b6143af565b905082815283838301111561442c575f80fd5b828260208301375f602084830101529392505050565b5f60208284031215614452575f80fd5b813567ffffffffffffffff811115614468575f80fd5b8201601f81018413614478575f80fd5b610d6c84823560208401614407565b82815260c08101610b30602083018467ffffffffffffffff8151168252602081015163ffffffff8082166020850152604083015191506001600160a01b0380831660408601528160608501511660608601528060808501511660808601525050505050565b5f602082840312156144fc575f80fd5b5035919050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610b306020830184614503565b5f8060408385031215614554575f80fd5b50508035926020909101359150565b5f67ffffffffffffffff82111561457c5761457c61434f565b5060051b60200190565b5f82601f830112614595575f80fd5b813560206145a561441483614563565b8083825260208201915060208460051b8701019350868411156145c6575f80fd5b602086015b848110156145e257803583529183019183016145cb565b509695505050505050565b5f82601f8301126145fc575f80fd5b610b3083833560208501614407565b5f805f805f60a0868803121561461f575f80fd5b853561462a816142b3565b9450602086013561463a816142b3565b9350604086013567ffffffffffffffff80821115614656575f80fd5b61466289838a01614586565b94506060880135915080821115614677575f80fd5b61468389838a01614586565b93506080880135915080821115614698575f80fd5b506146a5888289016145ed565b9150509295509295909350565b5f8083601f8401126146c2575f80fd5b50813567ffffffffffffffff8111156146d9575f80fd5b602083019150836020828501011115610d8d575f80fd5b5f8060208385031215614701575f80fd5b823567ffffffffffffffff811115614717575f80fd5b614723858286016146b2565b90969095509350505050565b5f8060408385031215614740575f80fd5b823567ffffffffffffffff80821115614757575f80fd5b818501915085601f83011261476a575f80fd5b8135602061477a61441483614563565b82815260059290921b84018101918181019089841115614798575f80fd5b948201945b838610156147bf5785356147b0816142b3565b8252948201949082019061479d565b965050860135925050808211156147d4575f80fd5b506147e185828601614586565b9150509250929050565b5f815180845260208085019450602084015f5b8381101561481a578151875295820195908201906001016147fe565b509495945050505050565b602081525f610b3060208301846147eb565b5f8060408385031215614848575f80fd5b8235614853816142b3565b9150602083013567ffffffffffffffff81111561486e575f80fd5b6147e1858286016145ed565b67ffffffffffffffff81168114612a90575f80fd5b8035612a2e8161487a565b5f80604083850312156148ab575f80fd5b8235915060208301356143448161487a565b5f805f606084860312156148cf575f80fd5b833592506020840135915060408401356148e8816142b3565b809150509250925092565b5f805f805f805f60c0888a031215614909575f80fd5b873567ffffffffffffffff81111561491f575f80fd5b61492b8a828b016146b2565b909850965050602088013561493f816142b3565b9450604088013561494f816142b3565b9350606088013561495f816142b3565b92506080880135915060a08801356149768161487a565b8091505092959891949750929550565b8015158114612a90575f80fd5b5f80604083850312156149a4575f80fd5b82356149af816142b3565b9150602083013561434481614986565b5f805f805f608086880312156149d3575f80fd5b853567ffffffffffffffff8111156149e9575f80fd5b6149f5888289016146b2565b9096509450506020860135614a09816142b3565b9250604086013591506060860135614a20816142b3565b809150509295509295909350565b60a08101610a52828467ffffffffffffffff8151168252602081015163ffffffff8082166020850152604083015191506001600160a01b0380831660408601528160608501511660608601528060808501511660808601525050505050565b5f8083601f840112614a9d575f80fd5b50813567ffffffffffffffff811115614ab4575f80fd5b6020830191508360208260051b8501011115610d8d575f80fd5b5f805f805f805f8060a0898b031215614ae5575f80fd5b8835614af0816142b3565b97506020890135614b00816142b3565b9650604089013567ffffffffffffffff80821115614b1c575f80fd5b614b288c838d01614a8d565b909850965060608b0135915080821115614b40575f80fd5b614b4c8c838d01614a8d565b909650945060808b0135915080821115614b64575f80fd5b50614b718b828c016146b2565b999c989b5096995094979396929594505050565b5f8060408385031215614b96575f80fd5b8235614ba1816142b3565b91506020830135614344816142b3565b5f805f805f8060a08789031215614bc6575f80fd5b8635614bd1816142b3565b95506020870135614be1816142b3565b94506040870135935060608701359250608087013567ffffffffffffffff811115614c0a575f80fd5b614c1689828a016146b2565b979a9699509497509295939492505050565b5f805f805f60a08688031215614c3c575f80fd5b8535614c47816142b3565b94506020860135614c57816142b3565b93506040860135925060608601359150608086013567ffffffffffffffff811115614c80575f80fd5b6146a5888289016145ed565b634e487b7160e01b5f52603260045260245ffd5b600181811c90821680614cb457607f821691505b602082108103614cd257634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561208c57805f5260205f20601f840160051c81016020851015614cfd5750805b601f840160051c820191505b81811015611e12575f8155600101614d09565b67ffffffffffffffff831115614d3457614d3461434f565b614d4883614d428354614ca0565b83614cd8565b5f601f841160018114614d79575f8515614d625750838201355b5f19600387901b1c1916600186901b178355611e12565b5f83815260208120601f198716915b82811015614da85786850135825560209485019460019092019101614d88565b5086821015614dc4575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b805163ffffffff81168114612a2e575f80fd5b5f60a08284031215614df9575f80fd5b60405160a0810181811067ffffffffffffffff82111715614e1c57614e1c61434f565b6040528251614e2a8161487a565b8152614e3860208401614dd6565b60208201526040830151614e4b816142b3565b6040820152614e5c60608401614dd6565b60608201526080830151614e6f816142b3565b60808201529392505050565b5f60408284031215614e8b575f80fd5b614e93614363565b9050813567ffffffffffffffff80821115614eac575f80fd5b9083019060c08286031215614ebf575f80fd5b614ec761438c565b823582811115614ed5575f80fd5b614ee1878286016145ed565b82525060208301359150614ef4826142b3565b81602082015260408301359150614f0a826142b3565b81604082015260608301359150614f20826142b3565b81606082015260808301356080820152614f3c60a0840161488f565b60a08201528084525050506020820135602082015292915050565b5f6020808385031215614f68575f80fd5b823567ffffffffffffffff80821115614f7f575f80fd5b818501915085601f830112614f92575f80fd5b8135614fa061441482614563565b81815260059190911b83018401908481019088831115614fbe575f80fd5b8585015b83811015614ff457803585811115614fd8575f80fd5b614fe68b89838a0101614e7b565b845250918601918601614fc2565b5098975050505050505050565b818382375f9101908152919050565b5f805f60608486031215615022575f80fd5b835161502d816142b3565b925061503b60208501614dd6565b915060408401516148e88161487a565b5f6020828403121561505b575f80fd5b813567ffffffffffffffff811115615071575f80fd5b610d6c84828501614e7b565b5f6020828403121561508d575f80fd5b815167ffffffffffffffff8111156150a3575f80fd5b8201601f810184136150b3575f80fd5b80516150c1614414826143e0565b8181528560208385010111156150d5575f80fd5b8160208401602083015e5f91810160200191909152949350505050565b634e487b7160e01b5f52601160045260245ffd5b63ffffffff818116838216019080821115615123576151236150f2565b5092915050565b5f6020828403121561513a575f80fd5b5051919050565b5f60208284031215615151575f80fd5b8151610b30816142b3565b80820180821115610a5257610a526150f2565b81810381811115610a5257610a526150f2565b5f63ffffffff80831681810361519a5761519a6150f2565b6001019392505050565b606081525f6151b66060830186614503565b905067ffffffffffffffff841660208301526001600160a01b0383166040830152949350505050565b5f602082840312156151ef575f80fd5b8151610b3081614986565b604081525f61520c6040830185614503565b90508260208301529392505050565b608081525f61522d6080830187614503565b6001600160a01b0395861660208401526040830194909452509216606090920191909152919050565b6001600160a01b0384168152826020820152606060408201525f610ab76060830184614503565b5f6020828403121561528d575f80fd5b610b3082614dd6565b5f6001600160a01b03808816835280871660208401525084604083015283606083015260a060808301526152cd60a0830184614503565b979650505050505050565b5f602082840312156152e8575f80fd5b8151610b30816142f1565b5f6001600160a01b03808816835280871660208401525060a0604083015261531e60a08301866147eb565b828103606084015261533081866147eb565b905082810360808401526135c28185614503565b5f82518060208501845e5f920191825250919050565b604081525f61536c60408301856147eb565b8281036020840152610ab781856147eb56fea2646970667358221220595559c1c9c8e6125adcc17ed68b30483fe7d4961939b8e861bcb1556061787e64736f6c634300081900338888888888888888888888888888888888888888888888888888888888888888eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef",
  "deployedBytecode": "0x6080604052600436106102ec575f3560e01c8063531b9d6d11610186578063bae78d7b116100dc578063dfa70d8b11610087578063f23a6e6111610062578063f23a6e61146109b0578063f242432a146109cf578063fa7e0fd3146109ee575f80fd5b8063dfa70d8b1461092b578063e4ae7d771461094a578063e985e9c514610969575f80fd5b8063bd242bcb116100b7578063bd242bcb146108ce578063ce156e82146108ed578063d3bf89b11461090c575f80fd5b8063bae78d7b1461084b578063bc197c8114610877578063bc7b6d62146108af575f80fd5b806378430b5a1161013c578063a22cb46511610117578063a22cb465146107c5578063ad3cb1cc146107e4578063b08a2c9c1461082c575f80fd5b806378430b5a146107735780637c3005861461078757806385f3e643146107a6575f80fd5b80635adf47241161016c5780635adf4724146106df5780636352211e146106fe578063781ef8db1461071d575f80fd5b8063531b9d6d1461068d5780635569f33d146106c0575f80fd5b80632dd31000116102465780633634f911116101f15780634e1273f4116101cc5780634e1273f41461063a5780634f1ef2861461066657806352d1902d14610679575f80fd5b80633634f911146105a05780633f7cefce146105d45780634750070814610607575f80fd5b8063319c22bb11610221578063319c22bb1461052f578063341ec5591461056257806335af621614610581575f80fd5b80632dd31000146104bc5780632eb2c2d6146104ef5780632f27fa2414610510575f80fd5b806311b8e00a116102a6578063192cf07d11610281578063192cf07d1461043f5780631c3fc3eb1461048a5780631e8fca2d1461049d575f80fd5b806311b8e00a146103c957806313c72608146103e857806314ff5ea314610420575f80fd5b8063072d5d77116102d6578063072d5d77146103515780630a796374146103705780630e89341c1461039d575f80fd5b8062fdd58e146102f057806301ffc9a714610322575b5f80fd5b3480156102fb575f80fd5b5061030f61030a3660046142c7565b610a21565b6040519081526020015b60405180910390f35b34801561032d575f80fd5b5061034161033c366004614306565b610a58565b6040519015158152602001610319565b34801561035c575f80fd5b5061034161036b366004614321565b610a95565b34801561037b575f80fd5b5061038f61038a366004614442565b610ac0565b604051610319929190614487565b3480156103a8575f80fd5b506103bc6103b73660046144ec565b610b12565b6040516103199190614531565b3480156103d4575f80fd5b506103416103e3366004614543565b610b1d565b3480156103f3575f80fd5b506104076104023660046144ec565b610b37565b60405167ffffffffffffffff9091168152602001610319565b34801561042b575f80fd5b5061030f61043a3660046144ec565b610b48565b34801561044a575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610319565b348015610495575f80fd5b5061030f5f81565b3480156104a8575f80fd5b5061030f6104b73660046144ec565b610b5b565b3480156104c7575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b3480156104fa575f80fd5b5061050e61050936600461460b565b610b6e565b005b34801561051b575f80fd5b5061030f61052a3660046144ec565b610c0b565b34801561053a575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b34801561056d575f80fd5b5061050e61057c366004614321565b610c29565b34801561058c575f80fd5b5061047261059b3660046146f0565b610d07565b3480156105ab575f80fd5b506105bf6105ba366004614543565b610d74565b60408051928352602083019190915201610319565b3480156105df575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b348015610612575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b348015610645575f80fd5b5061065961065436600461472f565b610d94565b6040516103199190614825565b61050e610674366004614837565b610e5f565b348015610684575f80fd5b5061030f610e7e565b348015610698575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b3480156106cb575f80fd5b5061050e6106da36600461489a565b610eac565b3480156106ea575f80fd5b5061030f6106f9366004614321565b611000565b348015610709575f80fd5b506104726107183660046144ec565b611032565b348015610728575f80fd5b50610341610737366004614321565b6001600160a01b03165f9081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205481161490565b34801561077e575f80fd5b506103bc61108f565b348015610792575f80fd5b506103416107a13660046148bd565b61111b565b3480156107b1575f80fd5b5061030f6107c03660046148f3565b61112f565b3480156107d0575f80fd5b5061050e6107df366004614993565b611196565b3480156107ef575f80fd5b506103bc6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b348015610837575f80fd5b5061050e6108463660046149bf565b6111a8565b348015610856575f80fd5b5061086a6108653660046144ec565b611387565b6040516103199190614a2e565b348015610882575f80fd5b50610896610891366004614ace565b611453565b6040516001600160e01b03199091168152602001610319565b3480156108ba575f80fd5b5061050e6108c9366004614321565b611501565b3480156108d9575f80fd5b506104726108e83660046144ec565b6115d3565b3480156108f8575f80fd5b50610341610907366004614321565b6115ef565b348015610917575f80fd5b506103416109263660046148bd565b611611565b348015610936575f80fd5b506103416109453660046148bd565b611670565b348015610955575f80fd5b506104726109643660046146f0565b611684565b348015610974575f80fd5b50610341610983366004614b85565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205460ff1690565b3480156109bb575f80fd5b506108966109ca366004614bb1565b611836565b3480156109da575f80fd5b5061050e6109e9366004614c28565b61197e565b3480156109f9575f80fd5b506104727f000000000000000000000000000000000000000000000000000000000000000081565b5f826001600160a01b0316610a3583611032565b6001600160a01b031614610a49575f610a4c565b60015b60ff1690505b92915050565b5f6001600160e01b031982167f4e2312e0000000000000000000000000000000000000000000000000000000001480610a525750610a5282611a0e565b5f8083610aaa8282610aa5611a4b565b611a59565b610ab75f86866001611b20565b95945050505050565b6040805160a0810182525f8082526020820181905291810182905260608101829052608081018290525f610af384611c3b565b9050610afe81611387565b9150610b0a8183611c51565b925050915091565b6060610a5282611c74565b5f610b30610b2a84610b5b565b83611d59565b9392505050565b5f610b4182611387565b5192915050565b5f610a5282610b5684611387565b611c51565b5f610a5282610b6984611387565b611d70565b5f610b77611a4b565b9050806001600160a01b0316866001600160a01b031614158015610bc057506001600160a01b038087165f9081526001602090815260408083209385168352929052205460ff16155b15610bf65760405163711bec9160e11b81526001600160a01b038083166004830152871660248201526044015b60405180910390fd5b610c038686868686611db4565b505050505050565b5f610a52610c1883610b5b565b5f9081526003602052604090205490565b5f80610c3784610100611e19565b6001600160a01b038086166040808401919091525163c0f8a73160e01b81529294509092507f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a73190610c959085908590600401614487565b5f604051808303815f87803b158015610cac575f80fd5b505af1158015610cbe573d5f803e3d5ffd5b50506040516001600160a01b03861681528492507fca01ade22fed8a886bda52d1fb12deaff178499347b6c13b1a892a60985a51e291506020015b60405180910390a250505050565b5f80610d4a61086585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611c3b92505050565b805190915067ffffffffffffffff16421015610d6a578060400151610d6c565b5f5b949350505050565b5f80610d88610d8285610b5b565b84611eb7565b915091505b9250929050565b60608151835114610dc55781518351604051635b05999160e01b815260048101929092526024820152604401610bed565b5f835167ffffffffffffffff811115610de057610de061434f565b604051908082528060200260200182016040528015610e09578160200160208202803683370190505b5090505f5b8451811015610e5757602080820286010151610e3290602080840287010151610a21565b828281518110610e4457610e44614c8c565b6020908102919091010152600101610e0e565b509392505050565b610e67611eda565b610e7082611f93565b610e7a8282611fa4565b5050565b5f610e87612091565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b5f80610eb9846010611e19565b91509150805f015167ffffffffffffffff168367ffffffffffffffff161015610f255780516040517f9967595a00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff91821660048201529084166024820152604401610bed565b67ffffffffffffffff8316815260405163c0f8a73160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a73190610f809085908590600401614487565b5f604051808303815f87803b158015610f97575f80fd5b505af1158015610fa9573d5f803e3d5ffd5b50505050817f3260962d42d8f7ae0af25cbfdb2983c214a859cfa2ac6df8ea29b534c267d42984610fd8611a4b565b6040805167ffffffffffffffff90931683526001600160a01b03909116602083015201610cf9565b5f610b3061100d84610b5b565b5f9081526002602090815260408083206001600160a01b038716845290915290205490565b5f8061103d83611387565b90506110498382611c51565b831415806110625750805167ffffffffffffffff164210155b611087575f838152602081905260409020546001600160a01b0316610b30565b610b30565b5f9392505050565b6004805461109c90614ca0565b80601f01602080910402602001604051908101604052809291908181526020018280546110c890614ca0565b80156111135780601f106110ea57610100808354040283529160200191611113565b820191905f5260205f20905b8154815290600101906020018083116110f657829003601f168201915b505050505081565b5f610d6c61112885610b5b565b84846120da565b5f60016111445f8261113f611a4b565b612115565b61118989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b92508a9150899050888861216f565b9998505050505050505050565b610e7a6111a1611a4b565b83836122ea565b5f6111b1612398565b805490915060ff68010000000000000000820416159067ffffffffffffffff165f811580156111dd5750825b90505f8267ffffffffffffffff1660011480156111f95750303b155b905081158015611207575080155b1561123e576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561127257845468ff00000000000000001916680100000000000000001785555b6001600160a01b0388166112e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4f776e65722063616e6e6f74206265207a65726f2061646472657373000000006044820152606401610bed565b60046112ef8a8c83614d1c565b506113115f721000000000000000000000000000000010000089178a82611b20565b506001600160a01b038616156113305761132e5f6001885f611b20565b505b831561137b57845468ff000000000000000019168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50505050505050505050565b6040805160a0810182525f8082526020820181905281830181905260608201819052608082015290517fb8a740e0000000000000000000000000000000000000000000000000000000008152306004820152602481018390526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063b8a740e09060440160a060405180830381865afa15801561142f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a529190614de9565b5f336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461149f5760405163d86ad9cf60e01b8152336004820152602401610bed565b5f6114ac83850185614f57565b90506114eb8888808060200260200160405190810160405280939291908181526020018383602002808284375f920191909152508592506123c0915050565b5063bc197c8160e01b9998505050505050505050565b5f8061150f84611000611e19565b6001600160a01b03808616608083015260405163c0f8a73160e01b81529294509092507f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a7319061156b9085908590600401614487565b5f604051808303815f87803b158015611582575f80fd5b505af1158015611594573d5f803e3d5ffd5b50506040516001600160a01b03861681528492507f3c055b8ebff34805cc0c0216cfd96bfe2613c75002ce000f6268324952541d069150602001610cf9565b5f818152602081905260408120546001600160a01b0316610a52565b5f808361160482826115ff611a4b565b612655565b610ab75f8686600161273e565b5f610d6c61161e85610b5b565b5f9081526002602090815260408083206001600160a01b03871684528252808320547fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b90925290912054178416841490565b5f610d6c61167d85610b5b565b84846127aa565b5f8061174161171b6004805461169990614ca0565b80601f01602080910402602001604051908101604052809291908181526020018280546116c590614ca0565b80156117105780601f106116e757610100808354040283529160200191611710565b820191905f5260205f20905b8154815290600101906020018083116116f357829003601f168201915b50505050505f6127e5565b858560405161172b929190615001565b60405180910390205f9182526020526040902090565b604051630178fe3f60e01b8152600481018290529091505f9081907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630178fe3f90602401606060405180830381865afa1580156117ab573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117cf9190615010565b5090925090506001600160a01b03821630148015906117f2575062010000811615155b15611822577f00000000000000000000000000000000000000000000000000000000000000009350505050610a52565b61182c8686612816565b9695505050505050565b5f336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146118825760405163d86ad9cf60e01b8152336004820152602401610bed565b5f61188f8385018561504b565b6040805160018082528183019092529192505f9190816020015b604080516101008101825260609181018281525f9282018390526080820183905260a0820183905260c0820183905260e08201839052815260208101919091528152602001906001900390816118a957905050905081815f8151811061191157611911614c8c565b60209081029190910101526040805160018082528183019092525f9181602001602082028036833701905050905087815f8151811061195257611952614c8c565b60200260200101818152505061196881836123c0565b5063f23a6e6160e01b9998505050505050505050565b5f611987611a4b565b9050806001600160a01b0316866001600160a01b0316141580156119d057506001600160a01b038087165f9081526001602090815260408083209385168352929052205460ff16155b15611a015760405163711bec9160e11b81526001600160a01b03808316600483015287166024820152604401610bed565b610c038686868686612879565b5f6001600160e01b031982167f07ca514a000000000000000000000000000000000000000000000000000000001480610a525750610a5282612905565b5f611a54612942565b905090565b5f611ac484836001600160a01b03165f8181527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b60209081526040808320549483526002825280832093835292905220546f11111111111111111111111111111111911760801c1690565b90508019831615611b1a576040517fd1a3b35500000000000000000000000000000000000000000000000000000000815260048101859052602481018490526001600160a01b0383166044820152606401610bed565b50505050565b5f611b2a84612a33565b6001600160a01b038316611b6a576040517fec3fc59200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8581526002602090815260408083206001600160a01b0387168452909152902054848117808214611c2f575f8781526002602090815260408083206001600160a01b0389168452909152902081905581198616611bca88826001612a93565b8415611bdd57611bdd888785858b612c28565b60408051848152602081018490526001600160a01b038816918a917f0d35bf721a39b614de00ca5038e1deb0cb0c69a278645e83405a7226cf80ba3c910160405180910390a360019350505050610d6c565b505f9695505050505050565b805160208201205f9063ffffffff811618610a52565b5f816020015163ffffffff16611c6c8463ffffffff81161890565b179392505050565b60607f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316611cb757505060408051602081019091525f815290565b6040517f1675f455000000000000000000000000000000000000000000000000000000008152600481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631675f455906024015f60405180830381865afa158015611d32573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a52919081019061507d565b5f80611d658484610d74565b501515949350505050565b80515f9067ffffffffffffffff16421015611d8f578160600151611d9f565b6060820151611d9f906001615106565b63ffffffff16611c6c8463ffffffff81161890565b6001600160a01b038416611ddd57604051632bfa23e760e11b81525f6004820152602401610bed565b6001600160a01b038516611e0557604051626a0d4560e21b81525f6004820152602401610bed565b611e128585858585612c31565b5050505050565b6040805160a0810182525f808252602082018190529181018290526060810182905260808101829052611e4b84611387565b9050611e578482611c51565b815190925067ffffffffffffffff164210611ea1576040517f0c23d84000000000000000000000000000000000000000000000000000000000815260048101839052602401610bed565b610d8d611eae8583611d70565b8461113f611a4b565b5f80611ec283612c8d565b5f948552600360205260409094205484169492505050565b306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161480611f7357507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316611f677f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b6001600160a01b031614155b15611f915760405163703e46dd60e11b815260040160405180910390fd5b565b62100000610e7a5f8261113f611a4b565b816001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611ffe575060408051601f3d908101601f19168201909252611ffb9181019061512a565b60015b61202657604051634c9c8ce360e01b81526001600160a01b0383166004820152602401610bed565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114612082576040517faa1d49a400000000000000000000000000000000000000000000000000000000815260048101829052602401610bed565b61208c8383612ca7565b505050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611f915760405163703e46dd60e11b815260040160405180910390fd5b5f83836120ea8282610aa5611a4b565b8561210857604051631850848b60e31b815260040160405180910390fd5b61182c8686866001611b20565b612120838383611611565b61208c576040517f4b27a13300000000000000000000000000000000000000000000000000000000815260048101849052602481018390526001600160a01b0382166044820152606401610bed565b85516020870120604051630178fe3f60e01b8152600481018290525f919082907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630178fe3f90602401606060405180830381865afa1580156121de573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906122029190615010565b50915050620100008116156122dc576040516331a9108f60e11b81526004810183905230906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636352211e90602401602060405180830381865afa158015612276573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061229a9190615141565b6001600160a01b0316146122dc57886040517f3a7216b7000000000000000000000000000000000000000000000000000000008152600401610bed9190614531565b611189898989898989612cfc565b6001600160a01b03821661232c576040517fced3e1000000000000000000000000000000000000000000000000000000000081525f6004820152602401610bed565b6001600160a01b038381165f81815260016020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b5f807ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00610a52565b5f5b825181101561208c575f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316630178fe3f85848151811061240d5761240d614c8c565b60200260200101516040518263ffffffff1660e01b815260040161243391815260200190565b606060405180830381865afa15801561244e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124729190615010565b509150506124998185848151811061248c5761248c614c8c565b6020026020010151612f9b565b5f6124c38484815181106124af576124af614c8c565b60200260200101515f01515f01515f612fdc565b90505f806124d0846133f6565b915091505f61258f7f000000000000000000000000000000000000000000000000000000000000000061252a7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b89898151811061253c5761253c614c8c565b60200260200101515f015160200151858b8b8151811061255e5761255e614c8c565b6020026020010151602001518c8c8151811061257c5761257c614c8c565b60200260200101515f01515f01516134c7565b90506125ff848888815181106125a7576125a7614c8c565b60200260200101515f015160200151838a8a815181106125c9576125c9614c8c565b60200260200101515f015160600151878c8c815181106125eb576125eb614c8c565b60200260200101515f015160a0015161216f565b506126447f000000000000000000000000000000000000000000000000000000000000000089888151811061263657612636614c8c565b6020026020010151876135ce565b5050600190930192506123c2915050565b5f6126e884836001600160a01b03165f8181527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b60209081526040808320549483526002825280832093835292905220547f1111111111111111111111111111111100000000000000000000000000000000911790811660809190911c6f11111111111111111111111111111111161790565b90508019831615611b1a576040517fa604e31800000000000000000000000000000000000000000000000000000000815260048101859052602481018490526001600160a01b0383166044820152606401610bed565b5f61274884612a33565b5f8581526002602090815260408083206001600160a01b038716845290915290205484198116808214611c2f575f8781526002602090815260408083206001600160a01b0389168452909152812082905586831690611bca9089908390612a93565b5f83836127ba82826115ff611a4b565b856127d857604051631850848b60e31b815260040160405180910390fd5b61182c868686600161273e565b5f6127f083836136d5565b925090508015610a5257610b3061280784846127e5565b825f9182526020526040902090565b5f8061285961086585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611c3b92505050565b805190915067ffffffffffffffff16421015610d6a578060800151610d6c565b6001600160a01b0384166128a257604051632bfa23e760e11b81525f6004820152602401610bed565b6001600160a01b0385166128ca57604051626a0d4560e21b81525f6004820152602401610bed565b604080516001808252602082018690528183019081526060820185905260808201909252906128fc8787848487612c31565b50505050505050565b5f6001600160e01b031982167f8f452d62000000000000000000000000000000000000000000000000000000001480610a525750610a5282613702565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661297657503390565b6040517f442b172c0000000000000000000000000000000000000000000000000000000081523360048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063442b172c90602401602060405180830381865afa1580156129f3573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612a179190615141565b90506001600160a01b038116612a2e573391505090565b919050565b7feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee811615612a90576040517f2a7b2d2000000000000000000000000000000000000000000000000000000000815260048101829052602401610bed565b50565b5f612a9d83612c8d565b90508115612b66575f848152600360205260409020547f888888888888888888888888888888888888888888888888888888888888888890821680197feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef01161615612b3e576040517ff91653480000000000000000000000000000000000000000000000000000000081526004810185905260248101849052604401610bed565b5f8481526003602052604081208054859290612b5b90849061515c565b90915550611b1a9050565b5f848152600360205260409020547f88888888888888888888888888888888888888888888888888888888888888889019821680197feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef01161615612c00576040517f1f80c19b0000000000000000000000000000000000000000000000000000000081526004810185905260248101849052604401610bed565b5f8481526003602052604081208054859290612c1d90849061516f565b909155505050505050565b611e1285613775565b612c3d858585856138cb565b6001600160a01b03841615611e12575f612c55611a4b565b90508351600103612c7f5760208481015190840151612c788389898585896139f7565b5050610c03565b610c03818787878787613b18565b5f612c9782612a33565b50600181901b17600281901b1790565b612cb082613bff565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a2805115612cf45761208c8282613c82565b610e7a613ceb565b5f612d0687611c3b565b90505f612d1282611387565b805190915067ffffffffffffffff16421015612d4357876040516306dbb87d60e41b8152600401610bed9190614531565b67ffffffffffffffff83164210612d92576040517f6a0147dc00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff84166004820152602401610bed565b612d9c8282611c51565b5f818152602081905260409020549092506001600160a01b03168015612e0357612dc881846001613d23565b816060018051612dd790615182565b63ffffffff169052602082018051612dee90615182565b63ffffffff169052612e008383611c51565b92505b67ffffffffffffffff841682526001600160a01b0380881660408085019190915287821660808501525163c0f8a73160e01b81527f00000000000000000000000000000000000000000000000000000000000000009091169063c0f8a73190612e729086908690600401614487565b5f604051808303815f87803b158015612e89575f80fd5b505af1158015612e9b573d5f803e3d5ffd5b50505050827fd9d0e8edd77eacdd7bd3f1d10259814b1aa244f74019f036046bbcc622fdcf598a86612ecb611a4b565b604051612eda939291906151a4565b60405180910390a2612efd8884600160405180602001604052805f815250613d89565b612f12612f0a8484611d70565b868a5f611b20565b506040516001600160a01b038816815283907fca01ade22fed8a886bda52d1fb12deaff178499347b6c13b1a892a60985a51e29060200160405180910390a26040516001600160a01b038716815283907f3c055b8ebff34805cc0c0216cfd96bfe2613c75002ce000f6268324952541d069060200160405180910390a250509695505050505050565b6201000082165f03610e7a576040517ff7d2a5a800000000000000000000000000000000000000000000000000000000815260048101829052602401610bed565b60605f612fe98484613de4565b8551919350915084908290811061300257613002614c8c565b01602001517fff00000000000000000000000000000000000000000000000000000000000000165f03613061576040517fd169740700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8061306d8684613de4565b60408051808201909152600381527f657468000000000000000000000000000000000000000000000000000000000060209182015282519083012091935091507f4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f014801561311157508581815181106130e8576130e8614c8c565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b156131d557604051631ad7b10b60e11b81525f906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906335af621690613164908890600401614531565b602060405180830381865afa15801561317f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906131a39190615141565b90506001600160a01b038116156131cf57846040516306dbb87d60e41b8152600401610bed9190614531565b506133ed565b5f6131e087856127e5565b6040517ffd0cd0d9000000000000000000000000000000000000000000000000000000008152600481018290529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063fd0cd0d990602401602060405180830381865afa15801561325f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061328391906151df565b158061331f57506040516331a9108f60e11b81526004810182905230906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636352211e90602401602060405180830381865afa1580156132ef573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906133139190615141565b6001600160a01b031614155b1561335a5786846040517f26d8c94f000000000000000000000000000000000000000000000000000000008152600401610bed9291906151fa565b604051631ad7b10b60e11b81525f9030906335af62169061337f908990600401614531565b602060405180830381865afa15801561339a573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906133be9190615141565b90506001600160a01b038116156133ea57856040516306dbb87d60e41b8152600401610bed9190614531565b50505b50505092915050565b5f806002831615156204000084161561342c576010831792508061342c5770100000000000000000000000000000000092909217915b600884165f0361345b57611000831792508061345b577110000000000000000000000000000000000092909217915b600484165f0361347e577201000000000000000000000000000000000000831792505b602084165f036134ab57600182179150806134ab5770010000000000000000000000000000000091909117905b5090927010000000000000000000000000000000109091179150565b5f808286865f6040516024016134e0949392919061521b565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fb08a2c9c00000000000000000000000000000000000000000000000000000000179052517f5d84121a0000000000000000000000000000000000000000000000000000000081529091506001600160a01b03891690635d84121a90613582908a9088908690600401615256565b6020604051808303815f875af115801561359e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906135c29190615141565b98975050505050505050565b600881165f0361364d576040517f1896f70a000000000000000000000000000000000000000000000000000000008152600481018390525f60248201526001600160a01b03841690631896f70a906044015f604051808303815f87803b158015613636575f80fd5b505af1158015613648573d5f803e3d5ffd5b505050505b6040517f402906fc00000000000000000000000000000000000000000000000000000000815260048101839052603f60248201526001600160a01b0384169063402906fc906044016020604051808303815f875af11580156136b1573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b1a919061527d565b5f805f6136e28585613e61565b9250905060ff8116156136fa57806021858701012092505b509250929050565b5f6001600160e01b03198216636cdb3d1360e11b148061373257506001600160e01b031982166303a24d0760e21b145b8061376657506001600160e01b031982167fd1011f6100000000000000000000000000000000000000000000000000000000145b80610a525750610a5282613ede565b5f61377f82611387565b805190915067ffffffffffffffff16421015610e7a575f6137a08383611c51565b5f818152602081905260409020549091506001600160a01b03168015611b1a576137cc81836001613d23565b8260200180516137db90615182565b63ffffffff16905260405163c0f8a73160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c0f8a731906138319085908790600401614487565b5f604051808303815f87803b158015613848575f80fd5b505af115801561385a573d5f803e3d5ffd5b505050505f6138698385611c51565b90506138868282600160405180602001604052805f815250613d89565b80837f88d074c8fc078bb1c0b9cfa9e3ca1f65a96141df8b0da854fe3083df813cbcca6138b38688611d70565b60405190815260200160405180910390a35050505050565b5f6001600160a01b038416158015906138ec57506001600160a01b03851615155b905080156139a5575f5b83518110156139a35761393684828151811061391457613914614c8c565b6020026020010151720100000000000000000000000000000000000088611611565b61399b5783818151811061394c5761394c614c8c565b6020026020010151866040517fe58f6d5a000000000000000000000000000000000000000000000000000000008152600401610bed9291909182526001600160a01b0316602082015260400190565b6001016138f6565b505b6139b185858585613f61565b8015611e12575f5b8351811015610c03576139ef6139e78583815181106139da576139da614c8c565b6020026020010151610b5b565b87875f614177565b6001016139b9565b6001600160a01b0384163b15610c035760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e6190613a3b9089908990889088908890600401615296565b6020604051808303815f875af1925050508015613a75575060408051601f3d908101601f19168201909252613a72918101906152d8565b60015b613adc573d808015613aa2576040519150601f19603f3d011682016040523d82523d5f602084013e613aa7565b606091505b5080515f03613ad457604051632bfa23e760e11b81526001600160a01b0386166004820152602401610bed565b805181602001fd5b6001600160e01b0319811663f23a6e6160e01b146128fc57604051632bfa23e760e11b81526001600160a01b0386166004820152602401610bed565b6001600160a01b0384163b15610c035760405163bc197c8160e01b81526001600160a01b0385169063bc197c8190613b5c90899089908890889088906004016152f3565b6020604051808303815f875af1925050508015613b96575060408051601f3d908101601f19168201909252613b93918101906152d8565b60015b613bc3573d808015613aa2576040519150601f19603f3d011682016040523d82523d5f602084013e613aa7565b6001600160e01b0319811663bc197c8160e01b146128fc57604051632bfa23e760e11b81526001600160a01b0386166004820152602401610bed565b806001600160a01b03163b5f03613c3457604051634c9c8ce360e01b81526001600160a01b0382166004820152602401610bed565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b60605f80846001600160a01b031684604051613c9e9190615344565b5f60405180830381855af49150503d805f8114613cd6576040519150601f19603f3d011682016040523d82523d5f602084013e613cdb565b606091505b5091509150610ab78583836141b8565b3415611f91576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b038316613d4b57604051626a0d4560e21b81525f6004820152602401610bed565b604080516001808252602082018590528183019081526060820184905260a082019092525f60808201818152919291611e1291879185908590612c31565b6001600160a01b038416613db257604051632bfa23e760e11b81525f6004820152602401610bed565b60408051600180825260208201869052818301908152606082018590526080820190925290610c035f87848487612c31565b60605f80613df28585613e61565b925090505f60ff821667ffffffffffffffff811115613e1357613e1361434f565b6040519080825280601f01601f191660200182016040528015613e3d576020820181803683370190505b509050613e566020820160218888010160ff8516614228565b959194509092505050565b5f8083518310613e86578360405163ba4adc2360e01b8152600401610bed9190614531565b838381518110613e9857613e98614c8c565b016020015160f81c91505081810160010181613eb8578351811415613ebe565b83518110155b15610d8d578360405163ba4adc2360e01b8152600401610bed9190614531565b5f6001600160e01b03198216636cdb3d1360e11b1480613f0e57506001600160e01b031982166331a9108f60e11b145b80613f2957506001600160e01b031982166303a24d0760e21b145b80610a5257507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b0319831614610a52565b8051825114613f905781518151604051635b05999160e01b815260048101929092526024820152604401610bed565b5f613f99611a4b565b90505f5b835181101561409957602081810285810182015190850190910151801561408f575f828152602081905260409020546001600160a01b039081169089168114614018576040516303dee4c560e01b81526001600160a01b038a1660048201525f60248201526044810183905260648101849052608401610bed565b600182111561405a576040516303dee4c560e01b81526001600160a01b038a166004820152600160248201526044810183905260648101849052608401610bed565b505f828152602081905260409020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0389161790555b5050600101613f9d565b5082516001036141195760208301515f906020840151909150856001600160a01b0316876001600160a01b0316846001600160a01b03167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62858560405161410a929190918252602082015260400190565b60405180910390a45050611e12565b836001600160a01b0316856001600160a01b0316826001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb868660405161416892919061535a565b60405180910390a45050505050565b5f8481526002602090815260408083206001600160a01b03871684529091529020548015611e12576141ab8582868561273e565b50610c0385828585611b20565b6060826141c85761108282614271565b81511580156141df57506001600160a01b0384163b155b15614221576040517f9996b3150000000000000000000000000000000000000000000000000000000081526001600160a01b0385166004820152602401610bed565b5080610b30565b5b601f811115614249578151835260209283019290910190601f1901614229565b801561208c5790518251600160209390930360031b9290921b5f190180199091169116179052565b8051156142815780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b0381168114612a90575f80fd5b5f80604083850312156142d8575f80fd5b82356142e3816142b3565b946020939093013593505050565b6001600160e01b031981168114612a90575f80fd5b5f60208284031215614316575f80fd5b8135610b30816142f1565b5f8060408385031215614332575f80fd5b823591506020830135614344816142b3565b809150509250929050565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156143865761438661434f565b60405290565b60405160c0810167ffffffffffffffff811182821017156143865761438661434f565b604051601f8201601f1916810167ffffffffffffffff811182821017156143d8576143d861434f565b604052919050565b5f67ffffffffffffffff8211156143f9576143f961434f565b50601f01601f191660200190565b5f614419614414846143e0565b6143af565b905082815283838301111561442c575f80fd5b828260208301375f602084830101529392505050565b5f60208284031215614452575f80fd5b813567ffffffffffffffff811115614468575f80fd5b8201601f81018413614478575f80fd5b610d6c84823560208401614407565b82815260c08101610b30602083018467ffffffffffffffff8151168252602081015163ffffffff8082166020850152604083015191506001600160a01b0380831660408601528160608501511660608601528060808501511660808601525050505050565b5f602082840312156144fc575f80fd5b5035919050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610b306020830184614503565b5f8060408385031215614554575f80fd5b50508035926020909101359150565b5f67ffffffffffffffff82111561457c5761457c61434f565b5060051b60200190565b5f82601f830112614595575f80fd5b813560206145a561441483614563565b8083825260208201915060208460051b8701019350868411156145c6575f80fd5b602086015b848110156145e257803583529183019183016145cb565b509695505050505050565b5f82601f8301126145fc575f80fd5b610b3083833560208501614407565b5f805f805f60a0868803121561461f575f80fd5b853561462a816142b3565b9450602086013561463a816142b3565b9350604086013567ffffffffffffffff80821115614656575f80fd5b61466289838a01614586565b94506060880135915080821115614677575f80fd5b61468389838a01614586565b93506080880135915080821115614698575f80fd5b506146a5888289016145ed565b9150509295509295909350565b5f8083601f8401126146c2575f80fd5b50813567ffffffffffffffff8111156146d9575f80fd5b602083019150836020828501011115610d8d575f80fd5b5f8060208385031215614701575f80fd5b823567ffffffffffffffff811115614717575f80fd5b614723858286016146b2565b90969095509350505050565b5f8060408385031215614740575f80fd5b823567ffffffffffffffff80821115614757575f80fd5b818501915085601f83011261476a575f80fd5b8135602061477a61441483614563565b82815260059290921b84018101918181019089841115614798575f80fd5b948201945b838610156147bf5785356147b0816142b3565b8252948201949082019061479d565b965050860135925050808211156147d4575f80fd5b506147e185828601614586565b9150509250929050565b5f815180845260208085019450602084015f5b8381101561481a578151875295820195908201906001016147fe565b509495945050505050565b602081525f610b3060208301846147eb565b5f8060408385031215614848575f80fd5b8235614853816142b3565b9150602083013567ffffffffffffffff81111561486e575f80fd5b6147e1858286016145ed565b67ffffffffffffffff81168114612a90575f80fd5b8035612a2e8161487a565b5f80604083850312156148ab575f80fd5b8235915060208301356143448161487a565b5f805f606084860312156148cf575f80fd5b833592506020840135915060408401356148e8816142b3565b809150509250925092565b5f805f805f805f60c0888a031215614909575f80fd5b873567ffffffffffffffff81111561491f575f80fd5b61492b8a828b016146b2565b909850965050602088013561493f816142b3565b9450604088013561494f816142b3565b9350606088013561495f816142b3565b92506080880135915060a08801356149768161487a565b8091505092959891949750929550565b8015158114612a90575f80fd5b5f80604083850312156149a4575f80fd5b82356149af816142b3565b9150602083013561434481614986565b5f805f805f608086880312156149d3575f80fd5b853567ffffffffffffffff8111156149e9575f80fd5b6149f5888289016146b2565b9096509450506020860135614a09816142b3565b9250604086013591506060860135614a20816142b3565b809150509295509295909350565b60a08101610a52828467ffffffffffffffff8151168252602081015163ffffffff8082166020850152604083015191506001600160a01b0380831660408601528160608501511660608601528060808501511660808601525050505050565b5f8083601f840112614a9d575f80fd5b50813567ffffffffffffffff811115614ab4575f80fd5b6020830191508360208260051b8501011115610d8d575f80fd5b5f805f805f805f8060a0898b031215614ae5575f80fd5b8835614af0816142b3565b97506020890135614b00816142b3565b9650604089013567ffffffffffffffff80821115614b1c575f80fd5b614b288c838d01614a8d565b909850965060608b0135915080821115614b40575f80fd5b614b4c8c838d01614a8d565b909650945060808b0135915080821115614b64575f80fd5b50614b718b828c016146b2565b999c989b5096995094979396929594505050565b5f8060408385031215614b96575f80fd5b8235614ba1816142b3565b91506020830135614344816142b3565b5f805f805f8060a08789031215614bc6575f80fd5b8635614bd1816142b3565b95506020870135614be1816142b3565b94506040870135935060608701359250608087013567ffffffffffffffff811115614c0a575f80fd5b614c1689828a016146b2565b979a9699509497509295939492505050565b5f805f805f60a08688031215614c3c575f80fd5b8535614c47816142b3565b94506020860135614c57816142b3565b93506040860135925060608601359150608086013567ffffffffffffffff811115614c80575f80fd5b6146a5888289016145ed565b634e487b7160e01b5f52603260045260245ffd5b600181811c90821680614cb457607f821691505b602082108103614cd257634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561208c57805f5260205f20601f840160051c81016020851015614cfd5750805b601f840160051c820191505b81811015611e12575f8155600101614d09565b67ffffffffffffffff831115614d3457614d3461434f565b614d4883614d428354614ca0565b83614cd8565b5f601f841160018114614d79575f8515614d625750838201355b5f19600387901b1c1916600186901b178355611e12565b5f83815260208120601f198716915b82811015614da85786850135825560209485019460019092019101614d88565b5086821015614dc4575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b805163ffffffff81168114612a2e575f80fd5b5f60a08284031215614df9575f80fd5b60405160a0810181811067ffffffffffffffff82111715614e1c57614e1c61434f565b6040528251614e2a8161487a565b8152614e3860208401614dd6565b60208201526040830151614e4b816142b3565b6040820152614e5c60608401614dd6565b60608201526080830151614e6f816142b3565b60808201529392505050565b5f60408284031215614e8b575f80fd5b614e93614363565b9050813567ffffffffffffffff80821115614eac575f80fd5b9083019060c08286031215614ebf575f80fd5b614ec761438c565b823582811115614ed5575f80fd5b614ee1878286016145ed565b82525060208301359150614ef4826142b3565b81602082015260408301359150614f0a826142b3565b81604082015260608301359150614f20826142b3565b81606082015260808301356080820152614f3c60a0840161488f565b60a08201528084525050506020820135602082015292915050565b5f6020808385031215614f68575f80fd5b823567ffffffffffffffff80821115614f7f575f80fd5b818501915085601f830112614f92575f80fd5b8135614fa061441482614563565b81815260059190911b83018401908481019088831115614fbe575f80fd5b8585015b83811015614ff457803585811115614fd8575f80fd5b614fe68b89838a0101614e7b565b845250918601918601614fc2565b5098975050505050505050565b818382375f9101908152919050565b5f805f60608486031215615022575f80fd5b835161502d816142b3565b925061503b60208501614dd6565b915060408401516148e88161487a565b5f6020828403121561505b575f80fd5b813567ffffffffffffffff811115615071575f80fd5b610d6c84828501614e7b565b5f6020828403121561508d575f80fd5b815167ffffffffffffffff8111156150a3575f80fd5b8201601f810184136150b3575f80fd5b80516150c1614414826143e0565b8181528560208385010111156150d5575f80fd5b8160208401602083015e5f91810160200191909152949350505050565b634e487b7160e01b5f52601160045260245ffd5b63ffffffff818116838216019080821115615123576151236150f2565b5092915050565b5f6020828403121561513a575f80fd5b5051919050565b5f60208284031215615151575f80fd5b8151610b30816142b3565b80820180821115610a5257610a526150f2565b81810381811115610a5257610a526150f2565b5f63ffffffff80831681810361519a5761519a6150f2565b6001019392505050565b606081525f6151b66060830186614503565b905067ffffffffffffffff841660208301526001600160a01b0383166040830152949350505050565b5f602082840312156151ef575f80fd5b8151610b3081614986565b604081525f61520c6040830185614503565b90508260208301529392505050565b608081525f61522d6080830187614503565b6001600160a01b0395861660208401526040830194909452509216606090920191909152919050565b6001600160a01b0384168152826020820152606060408201525f610ab76060830184614503565b5f6020828403121561528d575f80fd5b610b3082614dd6565b5f6001600160a01b03808816835280871660208401525084604083015283606083015260a060808301526152cd60a0830184614503565b979650505050505050565b5f602082840312156152e8575f80fd5b8151610b30816142f1565b5f6001600160a01b03808816835280871660208401525060a0604083015261531e60a08301866147eb565b828103606084015261533081866147eb565b905082810360808401526135c28185614503565b5f82518060208501845e5f920191825250919050565b604081525f61536c60408301856147eb565b8281036020840152610ab781856147eb56fea2646970667358221220595559c1c9c8e6125adcc17ed68b30483fe7d4961939b8e861bcb1556061787e64736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "13192": [
      {
        "length": 32,
        "start": 7909
      },
      {
        "length": 32,
        "start": 7950
      },
      {
        "length": 32,
        "start": 8348
      }
    ],
    "26166": [
      {
        "length": 32,
        "start": 1344
      },
      {
        "length": 32,
        "start": 10565
      },
      {
        "length": 32,
        "start": 10662
      }
    ],
    "27031": [
      {
        "length": 32,
        "start": 1509
      },
      {
        "length": 32,
        "start": 3166
      },
      {
        "length": 32,
        "start": 3913
      },
      {
        "length": 32,
        "start": 5098
      },
      {
        "length": 32,
        "start": 5428
      },
      {
        "length": 32,
        "start": 11833
      },
      {
        "length": 32,
        "start": 14330
      }
    ],
    "27162": [
      {
        "length": 32,
        "start": 1694
      },
      {
        "length": 32,
        "start": 7288
      },
      {
        "length": 32,
        "start": 7398
      }
    ],
    "27272": [
      {
        "length": 32,
        "start": 1104
      },
      {
        "length": 32,
        "start": 5215
      },
      {
        "length": 32,
        "start": 5982
      },
      {
        "length": 32,
        "start": 6210
      },
      {
        "length": 32,
        "start": 8593
      },
      {
        "length": 32,
        "start": 8753
      },
      {
        "length": 32,
        "start": 9166
      },
      {
        "length": 32,
        "start": 9733
      },
      {
        "length": 32,
        "start": 12818
      },
      {
        "length": 32,
        "start": 12970
      }
    ],
    "27275": [
      {
        "length": 32,
        "start": 1229
      },
      {
        "length": 32,
        "start": 9434
      }
    ],
    "27278": [
      {
        "length": 32,
        "start": 1560
      },
      {
        "length": 32,
        "start": 12591
      }
    ],
    "27280": [
      {
        "length": 32,
        "start": 2559
      },
      {
        "length": 32,
        "start": 6137
      }
    ]
  },
  "inputSourceName": "project/src/registry/MigratedWrappedNameRegistry.sol",
  "devdoc": {
    "details": "A registry for migrated wrapped names that inherits from PermissionedRegistry and is upgradeable using the UUPS pattern. This contract provides resolver fallback to the universal resolver for names that haven't been migrated yet. It also handles subdomain migration by receiving NFT transfers from the NameWrapper.",
    "errors": {
      "AddressEmptyCode(address)": [
        {
          "details": "There's no code at `target` (it is not a contract)."
        }
      ],
      "CannotReduceExpiration(uint64,uint64)": [
        {
          "details": "Error emitted when a name cannot be reduced in expiration."
        }
      ],
      "CannotSetPastExpiration(uint64)": [
        {
          "details": "Error emitted when a name cannot be set to a past expiration."
        }
      ],
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "ERC1155InsufficientBalance(address,uint256,uint256,uint256)": [
        {
          "details": "Indicates an error related to the current `balance` of a `sender`. Used in transfers.",
          "params": {
            "balance": "Current balance for the interacting account.",
            "needed": "Minimum amount required to perform a transfer.",
            "sender": "Address whose tokens are being transferred.",
            "tokenId": "Identifier number of a token."
          }
        }
      ],
      "ERC1155InvalidApprover(address)": [
        {
          "details": "Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
          "params": {
            "approver": "Address initiating an approval operation."
          }
        }
      ],
      "ERC1155InvalidArrayLength(uint256,uint256)": [
        {
          "details": "Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation. Used in batch transfers.",
          "params": {
            "idsLength": "Length of the array of token identifiers",
            "valuesLength": "Length of the array of token amounts"
          }
        }
      ],
      "ERC1155InvalidOperator(address)": [
        {
          "details": "Indicates a failure with the `operator` to be approved. Used in approvals.",
          "params": {
            "operator": "Address that may be allowed to operate on tokens without being their owner."
          }
        }
      ],
      "ERC1155InvalidReceiver(address)": [
        {
          "details": "Indicates a failure with the token `receiver`. Used in transfers.",
          "params": {
            "receiver": "Address to which tokens are being transferred."
          }
        }
      ],
      "ERC1155InvalidSender(address)": [
        {
          "details": "Indicates a failure with the token `sender`. Used in transfers.",
          "params": {
            "sender": "Address whose tokens are being transferred."
          }
        }
      ],
      "ERC1155MissingApprovalForAll(address,address)": [
        {
          "details": "Indicates a failure with the `operator`s approval. Used in transfers.",
          "params": {
            "operator": "Address that may be allowed to operate on tokens without being their owner.",
            "owner": "Address of the current owner of a token."
          }
        }
      ],
      "ERC1967InvalidImplementation(address)": [
        {
          "details": "The `implementation` of the proxy is invalid."
        }
      ],
      "ERC1967NonPayable()": [
        {
          "details": "An upgrade function sees `msg.value > 0` that may be lost."
        }
      ],
      "FailedCall()": [
        {
          "details": "A call to an address target failed. The target may have reverted."
        }
      ],
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "LabelNotMigrated(string)": [
        {
          "details": "Thrown when attempting to register a label that has an emancipated NFT in the old system but hasn't been migrated",
          "params": {
            "label": "The label that needs to be migrated first"
          }
        }
      ],
      "NameAlreadyRegistered(string)": [
        {
          "details": "Error emitted when a name is already registered."
        }
      ],
      "NameExpired(uint256)": [
        {
          "details": "Error emitted when a name has expired."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ],
      "ParentNotMigrated(bytes,uint256)": [
        {
          "details": "Thrown when attempting to migrate a subdomain whose parent has not been migrated",
          "params": {
            "name": "The DNS-encoded name being migrated",
            "offset": "The byte offset where the parent domain starts in the name"
          }
        }
      ],
      "TransferDisallowed(uint256,address)": [
        {
          "details": "Error emitted when a transfer is not allowed due to missing transfer admin role."
        }
      ],
      "UUPSUnauthorizedCallContext()": [
        {
          "details": "The call is from an unauthorized context."
        }
      ],
      "UUPSUnsupportedProxiableUUID(bytes32)": [
        {
          "details": "The storage `slot` is unsupported as a UUID."
        }
      ],
      "UnauthorizedCaller(address)": [
        {
          "details": "Thrown when a caller is not authorized to perform the requested operation",
          "params": {
            "caller": "The address that attempted the unauthorized operation"
          }
        }
      ]
    },
    "events": {
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."
      },
      "ExpiryUpdated(uint256,uint64,address)": {
        "details": "Error selector: `0x`"
      },
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "NameRegistered(uint256,string,uint64,address)": {
        "details": "SHOULD be emitted when a new label is registered"
      },
      "TransferBatch(address,address,address,uint256[],uint256[])": {
        "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
      },
      "TransferSingle(address,address,address,uint256,uint256)": {
        "details": "Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`."
      },
      "URI(string,uint256)": {
        "details": "Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."
      },
      "Upgraded(address)": {
        "details": "Emitted when the implementation is upgraded."
      }
    },
    "kind": "dev",
    "methods": {
      "balanceOf(address,uint256)": {
        "details": "See {IERC1155-balanceOf}."
      },
      "balanceOfBatch(address[],uint256[])": {
        "details": "See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length."
      },
      "getEntry(uint256)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource."
        },
        "returns": {
          "_0": "The datastore entry."
        }
      },
      "getExpiry(uint256)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource."
        },
        "returns": {
          "_0": "The expiry for name."
        }
      },
      "getNameData(string)": {
        "details": "Fetches the name data for a label.",
        "params": {
          "label": "The label to fetch the name data for."
        },
        "returns": {
          "entry": "The entry data for the name.",
          "tokenId": "The token ID of the name."
        }
      },
      "getResolver(string)": {
        "details": "Restore the latest resolver to `FALLBACK_RESOLVER` upon visiting migratable children.",
        "params": {
          "label": "The label to fetch a resolver for."
        },
        "returns": {
          "_0": "resolver The address of a resolver responsible for this name, or `address(0)` if none exists."
        }
      },
      "getResource(uint256)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource."
        },
        "returns": {
          "_0": "The resource."
        }
      },
      "getSubregistry(string)": {
        "details": "Fetches the registry for a subdomain.",
        "params": {
          "label": "The label to resolve."
        },
        "returns": {
          "_0": "The address of the registry for this subdomain, or `address(0)` if none exists."
        }
      },
      "getTokenId(uint256)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource."
        },
        "returns": {
          "_0": "The token ID."
        }
      },
      "grantRoles(uint256,uint256,address)": {
        "details": "Grants all roles in the given role bitmap to `account`."
      },
      "grantRootRoles(uint256,address)": {
        "details": "Grants all roles in the given role bitmap to `account` in the ROOT_RESOURCE. The caller must have all the necessary admin roles for the roles being granted.",
        "params": {
          "account": "The account to grant roles to.",
          "roleBitmap": "The roles bitmap to grant."
        },
        "returns": {
          "_0": "`true` if the roles were granted, `false` otherwise."
        }
      },
      "hasRootRoles(uint256,address)": {
        "details": "Returns `true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`.",
        "params": {
          "account": "The account to check.",
          "rolesBitmap": "The roles bitmap to check."
        },
        "returns": {
          "_0": "`true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`, `false` otherwise."
        }
      },
      "initialize(bytes,address,uint256,address)": {
        "details": "Initializes the MigratedWrappedNameRegistry contract.",
        "params": {
          "ownerAddress_": "The address that will own this registry.",
          "ownerRoles_": "The roles to grant to the owner.",
          "parentDnsEncodedName_": "The DNS-encoded name of the parent domain.",
          "registrarAddress_": "Optional address to grant ROLE_REGISTRAR permissions (typically for testing)."
        }
      },
      "isApprovedForAll(address,address)": {
        "details": "See {IERC1155-isApprovedForAll}."
      },
      "latestOwnerOf(uint256)": {
        "params": {
          "tokenId": "The token ID to query."
        },
        "returns": {
          "_0": "The latest owner address."
        }
      },
      "proxiableUUID()": {
        "details": "Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."
      },
      "register(string,address,address,address,uint256,uint64)": {
        "details": "Registers a new name.",
        "params": {
          "expires": "The expiration date of the name.",
          "label": "The label to register.",
          "owner": "The address of the owner of the name.",
          "registry": "The registry to set as the name.",
          "resolver": "The resolver to set for the name.",
          "roleBitmap": "The role bitmap to set for the name."
        }
      },
      "renew(uint256,uint64)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource.",
          "newExpiry": "The new expiration."
        }
      },
      "revokeRoles(uint256,uint256,address)": {
        "details": "Revokes all roles in the given role bitmap from `account`."
      },
      "revokeRootRoles(uint256,address)": {
        "details": "Revokes all roles in the given role bitmap from `account` in the ROOT_RESOURCE. The caller must have all the necessary admin roles for the roles being revoked.",
        "params": {
          "account": "The account to revoke roles from.",
          "roleBitmap": "The roles bitmap to revoke."
        },
        "returns": {
          "_0": "`true` if the roles were revoked, `false` otherwise."
        }
      },
      "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": {
        "details": "See {IERC1155-safeBatchTransferFrom}."
      },
      "safeTransferFrom(address,address,uint256,uint256,bytes)": {
        "details": "See {IERC1155-safeTransferFrom}."
      },
      "setApprovalForAll(address,bool)": {
        "details": "See {IERC1155-setApprovalForAll}."
      },
      "setResolver(uint256,address)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource.",
          "resolver": "The new resolver."
        }
      },
      "setSubregistry(uint256,address)": {
        "params": {
          "anyId": "The labelhash, token ID, or resource.",
          "registry": "The new registry."
        }
      },
      "upgradeToAndCall(address,bytes)": {
        "custom:oz-upgrades-unsafe-allow-reachable": "delegatecall",
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      }
    },
    "title": "MigratedWrappedNameRegistry",
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "4285600",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "DATASTORE()": "infinite",
        "ETH_REGISTRY()": "infinite",
        "FACTORY()": "infinite",
        "FALLBACK_RESOLVER()": "infinite",
        "HCA_FACTORY()": "infinite",
        "METADATA_PROVIDER()": "infinite",
        "NAME_WRAPPER()": "infinite",
        "ROOT_RESOURCE()": "272",
        "UPGRADE_INTERFACE_VERSION()": "infinite",
        "balanceOf(address,uint256)": "infinite",
        "balanceOfBatch(address[],uint256[])": "infinite",
        "getAssigneeCount(uint256,uint256)": "infinite",
        "getEntry(uint256)": "infinite",
        "getExpiry(uint256)": "infinite",
        "getNameData(string)": "infinite",
        "getResolver(string)": "infinite",
        "getResource(uint256)": "infinite",
        "getSubregistry(string)": "infinite",
        "getTokenId(uint256)": "infinite",
        "grantRoles(uint256,uint256,address)": "infinite",
        "grantRootRoles(uint256,address)": "infinite",
        "hasAssignees(uint256,uint256)": "infinite",
        "hasRoles(uint256,uint256,address)": "infinite",
        "hasRootRoles(uint256,address)": "2686",
        "initialize(bytes,address,uint256,address)": "infinite",
        "isApprovedForAll(address,address)": "infinite",
        "latestOwnerOf(uint256)": "2575",
        "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": "infinite",
        "onERC1155Received(address,address,uint256,uint256,bytes)": "infinite",
        "ownerOf(uint256)": "infinite",
        "parentDnsEncodedName()": "infinite",
        "proxiableUUID()": "infinite",
        "register(string,address,address,address,uint256,uint64)": "infinite",
        "renew(uint256,uint64)": "infinite",
        "revokeRoles(uint256,uint256,address)": "infinite",
        "revokeRootRoles(uint256,address)": "infinite",
        "roleCount(uint256)": "infinite",
        "roles(uint256,address)": "infinite",
        "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": "infinite",
        "safeTransferFrom(address,address,uint256,uint256,bytes)": "infinite",
        "setApprovalForAll(address,bool)": "infinite",
        "setResolver(uint256,address)": "infinite",
        "setSubregistry(uint256,address)": "infinite",
        "supportsInterface(bytes4)": "infinite",
        "upgradeToAndCall(address,bytes)": "infinite",
        "uri(uint256)": "infinite"
      },
      "internal": {
        "_authorizeUpgrade(address)": "infinite",
        "_migrateSubdomains(uint256[] memory,struct MigrationData memory[] memory)": "infinite",
        "_register(string memory,address,contract IRegistry,address,uint256,uint64)": "infinite",
        "_validateHierarchy(bytes memory,uint256)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract INameWrapper\",\"name\":\"nameWrapper\",\"type\":\"address\"},{\"internalType\":\"contract IPermissionedRegistry\",\"name\":\"ethRegistry\",\"type\":\"address\"},{\"internalType\":\"contract VerifiableFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IRegistryDatastore\",\"name\":\"datastore\",\"type\":\"address\"},{\"internalType\":\"contract IHCAFactoryBasic\",\"name\":\"hcaFactory\",\"type\":\"address\"},{\"internalType\":\"contract IRegistryMetadata\",\"name\":\"metadataProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fallbackResolver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"oldExpiration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"newExpiration\",\"type\":\"uint64\"}],\"name\":\"CannotReduceExpiration\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"}],\"name\":\"CannotSetPastExpiration\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"EACCannotGrantRoles\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"EACCannotRevokeRoles\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EACInvalidAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"}],\"name\":\"EACInvalidRoleBitmap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"EACMaxAssignees\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"EACMinAssignees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EACRootResourceNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"EACUnauthorizedAccountRoles\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC1155InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valuesLength\",\"type\":\"uint256\"}],\"name\":\"ERC1155InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC1155MissingApprovalForAll\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ERC1967InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967NonPayable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"LabelNotMigrated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"NameAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NameExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NameNotEmancipated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoParentDomain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ParentNotMigrated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"TransferDisallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRoleBitmap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoleBitmap\",\"type\":\"uint256\"}],\"name\":\"EACRolesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newExpiry\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"ExpiryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registeredBy\",\"type\":\"address\"}],\"name\":\"NameRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"ResolverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract IRegistry\",\"name\":\"subregistry\",\"type\":\"address\"}],\"name\":\"SubregistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resource\",\"type\":\"uint256\"}],\"name\":\"TokenRegenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DATASTORE\",\"outputs\":[{\"internalType\":\"contract IRegistryDatastore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IPermissionedRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract VerifiableFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FALLBACK_RESOLVER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HCA_FACTORY\",\"outputs\":[{\"internalType\":\"contract IHCAFactoryBasic\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"METADATA_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IRegistryMetadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME_WRAPPER\",\"outputs\":[{\"internalType\":\"contract INameWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_RESOURCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_INTERFACE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"}],\"name\":\"getAssigneeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mask\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"tokenVersionId\",\"type\":\"uint32\"},{\"internalType\":\"contract IRegistry\",\"name\":\"subregistry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"eacVersionId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"internalType\":\"struct IRegistryDatastore.Entry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"}],\"name\":\"getExpiry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"getNameData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"tokenVersionId\",\"type\":\"uint32\"},{\"internalType\":\"contract IRegistry\",\"name\":\"subregistry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"eacVersionId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"internalType\":\"struct IRegistryDatastore.Entry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"getResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"}],\"name\":\"getResource\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"getSubregistry\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"}],\"name\":\"getTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRootRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"}],\"name\":\"hasAssignees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolesBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rolesBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRootRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"parentDnsEncodedName_\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"ownerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ownerRoles_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"registrarAddress_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"latestOwnerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parentDnsEncodedName\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract IRegistry\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"expires\",\"type\":\"uint64\"}],\"name\":\"register\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"newExpiry\",\"type\":\"uint64\"}],\"name\":\"renew\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleBitmap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRootRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"}],\"name\":\"roleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anyId\",\"type\":\"uint256\"},{\"internalType\":\"contract IRegistry\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"setSubregistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"A registry for migrated wrapped names that inherits from PermissionedRegistry and is upgradeable using the UUPS pattern. This contract provides resolver fallback to the universal resolver for names that haven't been migrated yet. It also handles subdomain migration by receiving NFT transfers from the NameWrapper.\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"CannotReduceExpiration(uint64,uint64)\":[{\"details\":\"Error emitted when a name cannot be reduced in expiration.\"}],\"CannotSetPastExpiration(uint64)\":[{\"details\":\"Error emitted when a name cannot be set to a past expiration.\"}],\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"ERC1155InsufficientBalance(address,uint256,uint256,uint256)\":[{\"details\":\"Indicates an error related to the current `balance` of a `sender`. Used in transfers.\",\"params\":{\"balance\":\"Current balance for the interacting account.\",\"needed\":\"Minimum amount required to perform a transfer.\",\"sender\":\"Address whose tokens are being transferred.\",\"tokenId\":\"Identifier number of a token.\"}}],\"ERC1155InvalidApprover(address)\":[{\"details\":\"Indicates a failure with the `approver` of a token to be approved. Used in approvals.\",\"params\":{\"approver\":\"Address initiating an approval operation.\"}}],\"ERC1155InvalidArrayLength(uint256,uint256)\":[{\"details\":\"Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation. Used in batch transfers.\",\"params\":{\"idsLength\":\"Length of the array of token identifiers\",\"valuesLength\":\"Length of the array of token amounts\"}}],\"ERC1155InvalidOperator(address)\":[{\"details\":\"Indicates a failure with the `operator` to be approved. Used in approvals.\",\"params\":{\"operator\":\"Address that may be allowed to operate on tokens without being their owner.\"}}],\"ERC1155InvalidReceiver(address)\":[{\"details\":\"Indicates a failure with the token `receiver`. Used in transfers.\",\"params\":{\"receiver\":\"Address to which tokens are being transferred.\"}}],\"ERC1155InvalidSender(address)\":[{\"details\":\"Indicates a failure with the token `sender`. Used in transfers.\",\"params\":{\"sender\":\"Address whose tokens are being transferred.\"}}],\"ERC1155MissingApprovalForAll(address,address)\":[{\"details\":\"Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\",\"params\":{\"operator\":\"Address that may be allowed to operate on tokens without being their owner.\",\"owner\":\"Address of the current owner of a token.\"}}],\"ERC1967InvalidImplementation(address)\":[{\"details\":\"The `implementation` of the proxy is invalid.\"}],\"ERC1967NonPayable()\":[{\"details\":\"An upgrade function sees `msg.value > 0` that may be lost.\"}],\"FailedCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"LabelNotMigrated(string)\":[{\"details\":\"Thrown when attempting to register a label that has an emancipated NFT in the old system but hasn't been migrated\",\"params\":{\"label\":\"The label that needs to be migrated first\"}}],\"NameAlreadyRegistered(string)\":[{\"details\":\"Error emitted when a name is already registered.\"}],\"NameExpired(uint256)\":[{\"details\":\"Error emitted when a name has expired.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}],\"ParentNotMigrated(bytes,uint256)\":[{\"details\":\"Thrown when attempting to migrate a subdomain whose parent has not been migrated\",\"params\":{\"name\":\"The DNS-encoded name being migrated\",\"offset\":\"The byte offset where the parent domain starts in the name\"}}],\"TransferDisallowed(uint256,address)\":[{\"details\":\"Error emitted when a transfer is not allowed due to missing transfer admin role.\"}],\"UUPSUnauthorizedCallContext()\":[{\"details\":\"The call is from an unauthorized context.\"}],\"UUPSUnsupportedProxiableUUID(bytes32)\":[{\"details\":\"The storage `slot` is unsupported as a UUID.\"}],\"UnauthorizedCaller(address)\":[{\"details\":\"Thrown when a caller is not authorized to perform the requested operation\",\"params\":{\"caller\":\"The address that attempted the unauthorized operation\"}}]},\"events\":{\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`.\"},\"ExpiryUpdated(uint256,uint64,address)\":{\"details\":\"Error selector: `0x`\"},\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"NameRegistered(uint256,string,uint64,address)\":{\"details\":\"SHOULD be emitted when a new label is registered\"},\"TransferBatch(address,address,address,uint256[],uint256[])\":{\"details\":\"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers.\"},\"TransferSingle(address,address,address,uint256,uint256)\":{\"details\":\"Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\"},\"URI(string,uint256)\":{\"details\":\"Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}.\"},\"Upgraded(address)\":{\"details\":\"Emitted when the implementation is upgraded.\"}},\"kind\":\"dev\",\"methods\":{\"balanceOf(address,uint256)\":{\"details\":\"See {IERC1155-balanceOf}.\"},\"balanceOfBatch(address[],uint256[])\":{\"details\":\"See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.\"},\"getEntry(uint256)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\"},\"returns\":{\"_0\":\"The datastore entry.\"}},\"getExpiry(uint256)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\"},\"returns\":{\"_0\":\"The expiry for name.\"}},\"getNameData(string)\":{\"details\":\"Fetches the name data for a label.\",\"params\":{\"label\":\"The label to fetch the name data for.\"},\"returns\":{\"entry\":\"The entry data for the name.\",\"tokenId\":\"The token ID of the name.\"}},\"getResolver(string)\":{\"details\":\"Restore the latest resolver to `FALLBACK_RESOLVER` upon visiting migratable children.\",\"params\":{\"label\":\"The label to fetch a resolver for.\"},\"returns\":{\"_0\":\"resolver The address of a resolver responsible for this name, or `address(0)` if none exists.\"}},\"getResource(uint256)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\"},\"returns\":{\"_0\":\"The resource.\"}},\"getSubregistry(string)\":{\"details\":\"Fetches the registry for a subdomain.\",\"params\":{\"label\":\"The label to resolve.\"},\"returns\":{\"_0\":\"The address of the registry for this subdomain, or `address(0)` if none exists.\"}},\"getTokenId(uint256)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\"},\"returns\":{\"_0\":\"The token ID.\"}},\"grantRoles(uint256,uint256,address)\":{\"details\":\"Grants all roles in the given role bitmap to `account`.\"},\"grantRootRoles(uint256,address)\":{\"details\":\"Grants all roles in the given role bitmap to `account` in the ROOT_RESOURCE. The caller must have all the necessary admin roles for the roles being granted.\",\"params\":{\"account\":\"The account to grant roles to.\",\"roleBitmap\":\"The roles bitmap to grant.\"},\"returns\":{\"_0\":\"`true` if the roles were granted, `false` otherwise.\"}},\"hasRootRoles(uint256,address)\":{\"details\":\"Returns `true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`.\",\"params\":{\"account\":\"The account to check.\",\"rolesBitmap\":\"The roles bitmap to check.\"},\"returns\":{\"_0\":\"`true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`, `false` otherwise.\"}},\"initialize(bytes,address,uint256,address)\":{\"details\":\"Initializes the MigratedWrappedNameRegistry contract.\",\"params\":{\"ownerAddress_\":\"The address that will own this registry.\",\"ownerRoles_\":\"The roles to grant to the owner.\",\"parentDnsEncodedName_\":\"The DNS-encoded name of the parent domain.\",\"registrarAddress_\":\"Optional address to grant ROLE_REGISTRAR permissions (typically for testing).\"}},\"isApprovedForAll(address,address)\":{\"details\":\"See {IERC1155-isApprovedForAll}.\"},\"latestOwnerOf(uint256)\":{\"params\":{\"tokenId\":\"The token ID to query.\"},\"returns\":{\"_0\":\"The latest owner address.\"}},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"register(string,address,address,address,uint256,uint64)\":{\"details\":\"Registers a new name.\",\"params\":{\"expires\":\"The expiration date of the name.\",\"label\":\"The label to register.\",\"owner\":\"The address of the owner of the name.\",\"registry\":\"The registry to set as the name.\",\"resolver\":\"The resolver to set for the name.\",\"roleBitmap\":\"The role bitmap to set for the name.\"}},\"renew(uint256,uint64)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\",\"newExpiry\":\"The new expiration.\"}},\"revokeRoles(uint256,uint256,address)\":{\"details\":\"Revokes all roles in the given role bitmap from `account`.\"},\"revokeRootRoles(uint256,address)\":{\"details\":\"Revokes all roles in the given role bitmap from `account` in the ROOT_RESOURCE. The caller must have all the necessary admin roles for the roles being revoked.\",\"params\":{\"account\":\"The account to revoke roles from.\",\"roleBitmap\":\"The roles bitmap to revoke.\"},\"returns\":{\"_0\":\"`true` if the roles were revoked, `false` otherwise.\"}},\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\":{\"details\":\"See {IERC1155-safeBatchTransferFrom}.\"},\"safeTransferFrom(address,address,uint256,uint256,bytes)\":{\"details\":\"See {IERC1155-safeTransferFrom}.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"See {IERC1155-setApprovalForAll}.\"},\"setResolver(uint256,address)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\",\"resolver\":\"The new resolver.\"}},\"setSubregistry(uint256,address)\":{\"params\":{\"anyId\":\"The labelhash, token ID, or resource.\",\"registry\":\"The new registry.\"}},\"upgradeToAndCall(address,bytes)\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"title\":\"MigratedWrappedNameRegistry\",\"version\":1},\"userdoc\":{\"events\":{\"ExpiryUpdated(uint256,uint64,address)\":{\"notice\":\"Expiry was changed.\"},\"ResolverUpdated(uint256,address)\":{\"notice\":\"Resolver was changed.\"},\"SubregistryUpdated(uint256,address)\":{\"notice\":\"Subregistry was changed.\"},\"TokenRegenerated(uint256,uint256,uint256)\":{\"notice\":\"Token was regenerated with a new token ID.         This occurs when roles are granted or revoked to maintain ERC1155 compliance.\"}},\"kind\":\"user\",\"methods\":{\"HCA_FACTORY()\":{\"notice\":\"The HCA factory contract\"},\"METADATA_PROVIDER()\":{\"notice\":\"The metadata provider contract\"},\"ROOT_RESOURCE()\":{\"notice\":\"The `ROOT_RESOURCE`.\"},\"getEntry(uint256)\":{\"notice\":\"Get datastore `Entry` from `anyId`.\"},\"getExpiry(uint256)\":{\"notice\":\"Get expiry of name.\"},\"getResource(uint256)\":{\"notice\":\"Get `resource` from `anyId`.\"},\"getTokenId(uint256)\":{\"notice\":\"Get `tokenId` from `anyId`.\"},\"latestOwnerOf(uint256)\":{\"notice\":\"Get the latest owner of a token.         If the token was burned, returns null.\"},\"renew(uint256,uint64)\":{\"notice\":\"Renew a subdomain.\"},\"setResolver(uint256,address)\":{\"notice\":\"Change resolver of name.\"},\"setSubregistry(uint256,address)\":{\"notice\":\"Change registry of name.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/registry/MigratedWrappedNameRegistry.sol\":\"MigratedWrappedNameRegistry\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/ethregistrar/IBaseRegistrar.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IBaseRegistrar is IERC721 {\\n    event ControllerAdded(address indexed controller);\\n    event ControllerRemoved(address indexed controller);\\n    event NameMigrated(\\n        uint256 indexed id,\\n        address indexed owner,\\n        uint256 expires\\n    );\\n    event NameRegistered(\\n        uint256 indexed id,\\n        address indexed owner,\\n        uint256 expires\\n    );\\n    event NameRenewed(uint256 indexed id, uint256 expires);\\n\\n    // Authorises a controller, who can register and renew domains.\\n    function addController(address controller) external;\\n\\n    // Revoke controller permission for an address.\\n    function removeController(address controller) external;\\n\\n    // Set the resolver for the TLD this registrar manages.\\n    function setResolver(address resolver) external;\\n\\n    // Returns the expiration timestamp of the specified label hash.\\n    function nameExpires(uint256 id) external view returns (uint256);\\n\\n    // Returns true if the specified name is available for registration.\\n    function available(uint256 id) external view returns (bool);\\n\\n    /// @dev Register a name.\\n    function register(\\n        uint256 id,\\n        address owner,\\n        uint256 duration\\n    ) external returns (uint256);\\n\\n    function renew(uint256 id, uint256 duration) external returns (uint256);\\n\\n    /// @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\\n    function reclaim(uint256 id, address owner) external;\\n}\\n\",\"keccak256\":\"0x984447817adfb8fc76447da9c24a492379bcfa4cd4e7ed8e795ea1981be3db83\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8e208b44d5dbf22552fe72d79b45c640855b84fbc9ee21f4c3bb4bfe81cbe8db\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/wrapper/IMetadataService.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\ninterface IMetadataService {\\n    function uri(uint256) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xb3f1cf6df01ed7b15e5f2318f6823afbdb586ca38c2124c67955c645647ae9a2\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/wrapper/INameWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"../ethregistrar/IBaseRegistrar.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"./IMetadataService.sol\\\";\\nimport \\\"./INameWrapperUpgrade.sol\\\";\\n\\nuint32 constant CANNOT_UNWRAP = 1;\\nuint32 constant CANNOT_BURN_FUSES = 2;\\nuint32 constant CANNOT_TRANSFER = 4;\\nuint32 constant CANNOT_SET_RESOLVER = 8;\\nuint32 constant CANNOT_SET_TTL = 16;\\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\\nuint32 constant CANNOT_APPROVE = 64;\\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\\nuint32 constant IS_DOT_ETH = 1 << 17;\\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\\nuint32 constant CAN_DO_EVERYTHING = 0;\\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\\n// all fuses apart from IS_DOT_ETH\\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\\n\\ninterface INameWrapper is IERC1155 {\\n    event NameWrapped(\\n        bytes32 indexed node,\\n        bytes name,\\n        address owner,\\n        uint32 fuses,\\n        uint64 expiry\\n    );\\n\\n    event NameUnwrapped(bytes32 indexed node, address owner);\\n\\n    event FusesSet(bytes32 indexed node, uint32 fuses);\\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\\n\\n    function ens() external view returns (ENS);\\n\\n    function registrar() external view returns (IBaseRegistrar);\\n\\n    function metadataService() external view returns (IMetadataService);\\n\\n    function names(bytes32) external view returns (bytes memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function upgradeContract() external view returns (INameWrapperUpgrade);\\n\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n\\n    function wrap(\\n        bytes calldata name,\\n        address wrappedOwner,\\n        address resolver\\n    ) external;\\n\\n    function wrapETH2LD(\\n        string calldata label,\\n        address wrappedOwner,\\n        uint16 ownerControlledFuses,\\n        address resolver\\n    ) external returns (uint64 expires);\\n\\n    function registerAndWrapETH2LD(\\n        string calldata label,\\n        address wrappedOwner,\\n        uint256 duration,\\n        address resolver,\\n        uint16 ownerControlledFuses\\n    ) external returns (uint256 registrarExpiry);\\n\\n    function renew(\\n        uint256 labelHash,\\n        uint256 duration\\n    ) external returns (uint256 expires);\\n\\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\\n\\n    function unwrapETH2LD(\\n        bytes32 label,\\n        address newRegistrant,\\n        address newController\\n    ) external;\\n\\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\\n\\n    function setFuses(\\n        bytes32 node,\\n        uint16 ownerControlledFuses\\n    ) external returns (uint32 newFuses);\\n\\n    function setChildFuses(\\n        bytes32 parentNode,\\n        bytes32 labelhash,\\n        uint32 fuses,\\n        uint64 expiry\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        string calldata label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl,\\n        uint32 fuses,\\n        uint64 expiry\\n    ) external returns (bytes32);\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        string calldata label,\\n        address newOwner,\\n        uint32 fuses,\\n        uint64 expiry\\n    ) external returns (bytes32);\\n\\n    function extendExpiry(\\n        bytes32 node,\\n        bytes32 labelhash,\\n        uint64 expiry\\n    ) external returns (uint64);\\n\\n    function canModifyName(\\n        bytes32 node,\\n        address addr\\n    ) external view returns (bool);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function ownerOf(uint256 id) external view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function getData(\\n        uint256 id\\n    ) external view returns (address, uint32, uint64);\\n\\n    function setMetadataService(IMetadataService _metadataService) external;\\n\\n    function uri(uint256 tokenId) external view returns (string memory);\\n\\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\\n\\n    function allFusesBurned(\\n        bytes32 node,\\n        uint32 fuseMask\\n    ) external view returns (bool);\\n\\n    function isWrapped(bytes32) external view returns (bool);\\n\\n    function isWrapped(bytes32, bytes32) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x70310eb67146d7290731c31841399640ac3b6a949eadc6598bc150123d185c57\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/wrapper/INameWrapperUpgrade.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\ninterface INameWrapperUpgrade {\\n    function wrapFromUpgrade(\\n        bytes calldata name,\\n        address wrappedOwner,\\n        uint32 fuses,\\n        uint64 expiry,\\n        address approved,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x42e0cec6cd9d1a62d51d45b678f69d3e4ad5555e659b197e41257b308346bb8a\",\"license\":\"MIT\"},\"project/lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, int256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,int256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0x4bbf47eb762cef93729d6ef15e78789957147039b113e5d4df48e3d3fd16d0f5\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x13c2d19041c51b246233f96874a66c0094b8a5ff78af3b85ea27867f302dcbbb\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.22;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC-1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe1448f559716952220b5c696a5cc34d1f11f958bfbfcd05988543f6fd8bfff96\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0xb25a4f11fa80c702bf5cd85adec90e6f6f507f32f4a8e6f5dbc31e8c10029486\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xc42facb5094f2f35f066a7155bda23545e39a3156faef3ddc00185544443ba7d\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.22;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {IERC1967} from \\\"../../interfaces/IERC1967.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This library provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit IERC1967.Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit IERC1967.BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8decfa54cec979c824b044b8128cd91d713f72c71fd7dfa54974624d8c949898\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaa1d17c1129b127a4a401db2fbd72960e2671474be3d08cae71ccdc42f7624c\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcab667ddad478ff0d39c2053ca77fac778af8483c18ab07d810277b4216fd582\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0xb25a4f11fa80c702bf5cd85adec90e6f6f507f32f4a8e6f5dbc31e8c10029486\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC-20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC-721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC-1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x880da465c203cec76b10d72dbd87c80f387df4102274f23eea1f9c9b0918792b\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.22;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {IERC1967} from \\\"../../interfaces/IERC1967.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This library provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit IERC1967.Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit IERC1967.BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8decfa54cec979c824b044b8128cd91d713f72c71fd7dfa54974624d8c949898\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the zero address.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1d7a05b3219532ea5ece50a80cf390cac9109dc74e07763adfa463ab5a3af0dc\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x61a23d601c2ab69dd726ac55058604cbda98e1d728ba31a51c379a3f9eeea715\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x35d120c427299af1525aaf07955314d9e36a62f14408eb93dec71a2e001f74d3\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/utils/ERC1155Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155Receiver} from \\\"../IERC1155Receiver.sol\\\";\\nimport {IERC1155Errors} from \\\"../../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Library that provide common ERC-1155 utility functions.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\\n *\\n * _Available since v5.1._\\n */\\nlibrary ERC1155Utils {\\n    /**\\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}\\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\\n     *\\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\\n     * the transfer.\\n     */\\n    function checkOnERC1155Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length > 0) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    // Tokens rejected\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-IERC1155Receiver implementer\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\n                } else {\\n                    assembly (\\\"memory-safe\\\") {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}\\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\\n     *\\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\\n     * the transfer.\\n     */\\n    function checkOnERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length > 0) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    // Tokens rejected\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-IERC1155Receiver implementer\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\n                } else {\\n                    assembly (\\\"memory-safe\\\") {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x22f099c02c252dd1f6ddc464916ce683294a63b23b3c6ee3d290b77398e2474b\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaa1d17c1129b127a4a401db2fbd72960e2671474be3d08cae71ccdc42f7624c\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)\\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Comparators} from \\\"./Comparators.sol\\\";\\nimport {SlotDerivation} from \\\"./SlotDerivation.sol\\\";\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\nimport {Math} from \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    using SlotDerivation for bytes32;\\n    using StorageSlot for bytes32;\\n\\n    /**\\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n \\u00b7 log(n))` in average and `O(n\\u00b2)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        uint256[] memory array,\\n        function(uint256, uint256) pure returns (bool) comp\\n    ) internal pure returns (uint256[] memory) {\\n        _quickSort(_begin(array), _end(array), comp);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\\n     */\\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\\n        sort(array, Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Sort an array of address (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n \\u00b7 log(n))` in average and `O(n\\u00b2)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        address[] memory array,\\n        function(address, address) pure returns (bool) comp\\n    ) internal pure returns (address[] memory) {\\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\\n     */\\n    function sort(address[] memory array) internal pure returns (address[] memory) {\\n        sort(_castToUint256Array(array), Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n \\u00b7 log(n))` in average and `O(n\\u00b2)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        bytes32[] memory array,\\n        function(bytes32, bytes32) pure returns (bool) comp\\n    ) internal pure returns (bytes32[] memory) {\\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\\n     */\\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\\n        sort(_castToUint256Array(array), Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\\n     * at end (exclusive). Sorting follows the `comp` comparator.\\n     *\\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\\n     *\\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\\n     * be used only if the limits are within a memory array.\\n     */\\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\\n        unchecked {\\n            if (end - begin < 0x40) return;\\n\\n            // Use first element as pivot\\n            uint256 pivot = _mload(begin);\\n            // Position where the pivot should be at the end of the loop\\n            uint256 pos = begin;\\n\\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\\n                if (comp(_mload(it), pivot)) {\\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\\n                    // position of the pivot and move the value there.\\n                    pos += 0x20;\\n                    _swap(pos, it);\\n                }\\n            }\\n\\n            _swap(begin, pos); // Swap pivot into place\\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\\n        }\\n    }\\n\\n    /**\\n     * @dev Pointer to the memory location of the first element of `array`.\\n     */\\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\\n        assembly (\\\"memory-safe\\\") {\\n            ptr := add(array, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\\n     * that comes just after the last element of the array.\\n     */\\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\\n        unchecked {\\n            return _begin(array) + array.length * 0x20;\\n        }\\n    }\\n\\n    /**\\n     * @dev Load memory word (as a uint256) at location `ptr`.\\n     */\\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\\n     */\\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\\n        assembly {\\n            let value1 := mload(ptr1)\\n            let value2 := mload(ptr2)\\n            mstore(ptr1, value2)\\n            mstore(ptr2, value1)\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast address memory array to uint256 memory array\\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast address comp function to uint256 comp function\\n    function _castToUint256Comp(\\n        function(address, address) pure returns (bool) input\\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\\n    function _castToUint256Comp(\\n        function(bytes32, bytes32) pure returns (bool) input\\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\\n     * contain no repeated elements.\\n     *\\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\\n     * support for repeated elements in the array. The {lowerBound} function should\\n     * be used instead.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\n     * index that contains a value greater or equal than `element`. If no such index\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\n     * length is returned. Time complexity O(log n).\\n     *\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\\n     */\\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value < element) {\\n                // this cannot overflow because mid < high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\n     * index that contains a value strictly greater than `element`. If no such index\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\n     * length is returned. Time complexity O(log n).\\n     *\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\\n     */\\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                // this cannot overflow because mid < high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Same as {lowerBound}, but with an array in memory.\\n     */\\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeMemoryAccess(array, mid) < element) {\\n                // this cannot overflow because mid < high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Same as {upperBound}, but with an array in memory.\\n     */\\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeMemoryAccess(array, mid) > element) {\\n                high = mid;\\n            } else {\\n                // this cannot overflow because mid < high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getUint256Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55a4fdb408e3db950b48f4a6131e538980be8c5f48ee59829d92d66477140cd6\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/Comparators.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides a set of functions to compare values.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Comparators {\\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a < b;\\n    }\\n\\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a > b;\\n    }\\n}\\n\",\"keccak256\":\"0x302eecd8cf323b4690e3494a7d960b3cbce077032ab8ef655b323cdd136cec58\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/Panic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper library for emitting standardized panic codes.\\n *\\n * ```solidity\\n * contract Example {\\n *      using Panic for uint256;\\n *\\n *      // Use any of the declared internal constants\\n *      function foo() { Panic.GENERIC.panic(); }\\n *\\n *      // Alternatively\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\n * }\\n * ```\\n *\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\n *\\n * _Available since v5.1._\\n */\\n// slither-disable-next-line unused-state\\nlibrary Panic {\\n    /// @dev generic / unspecified error\\n    uint256 internal constant GENERIC = 0x00;\\n    /// @dev used by the assert() builtin\\n    uint256 internal constant ASSERT = 0x01;\\n    /// @dev arithmetic underflow or overflow\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\n    /// @dev division or modulo by zero\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\n    /// @dev enum conversion error\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\n    /// @dev invalid encoding in storage\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\n    /// @dev empty array pop\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\n    /// @dev array out of bounds access\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\n    /// @dev resource error (too large allocation or too large array)\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\n    /// @dev calling invalid internal function\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\n\\n    /// @dev Reverts with a panic code. Recommended to use with\\n    /// the internal constants with predefined codes.\\n    function panic(uint256 code) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x4e487b71)\\n            mstore(0x20, code)\\n            revert(0x1c, 0x24)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/SlotDerivation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\\n * the solidity language / compiler.\\n *\\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\\n *\\n * Example usage:\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using StorageSlot for bytes32;\\n *     using SlotDerivation for bytes32;\\n *\\n *     // Declare a namespace\\n *     string private constant _NAMESPACE = \\\"<namespace>\\\"; // eg. OpenZeppelin.Slot\\n *\\n *     function setValueInNamespace(uint256 key, address newValue) internal {\\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\\n *     }\\n *\\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {StorageSlot}.\\n *\\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\\n * upgrade safety will ignore the slots accessed through this library.\\n *\\n * _Available since v5.1._\\n */\\nlibrary SlotDerivation {\\n    /**\\n     * @dev Derive an ERC-7201 slot from a string (namespace).\\n     */\\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\\n            slot := and(keccak256(0x00, 0x20), not(0xff))\\n        }\\n    }\\n\\n    /**\\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\\n     */\\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\\n        unchecked {\\n            return bytes32(uint256(slot) + pos);\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\\n     */\\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, slot)\\n            result := keccak256(0x00, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, and(key, shr(96, not(0))))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, iszero(iszero(key)))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x67672e4ca1dafdcc661d4eba8475cfac631fa0933309258e3af7644b92e1fb26\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Panic} from \\\"../Panic.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit addition of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that sum = high * 2\\u00b2\\u2075\\u2076 + low.\\n     */\\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        assembly (\\\"memory-safe\\\") {\\n            low := add(a, b)\\n            high := lt(low, a)\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit multiplication of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that product = high * 2\\u00b2\\u2075\\u2076 + low.\\n     */\\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2\\u00b2\\u2075\\u2076 and mod 2\\u00b2\\u2075\\u2076 - 1, then use\\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = high * 2\\u00b2\\u2075\\u2076 + low.\\n        assembly (\\\"memory-safe\\\") {\\n            let mm := mulmod(a, b, not(0))\\n            low := mul(a, b)\\n            high := sub(sub(mm, low), lt(mm, low))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a + b;\\n            success = c >= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a - b;\\n            success = c <= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a * b;\\n            assembly (\\\"memory-safe\\\") {\\n                // Only true when the multiplication doesn't overflow\\n                // (c / a == b) || (a == 0)\\n                success := or(eq(div(c, a), b), iszero(a))\\n            }\\n            // equivalent to: success ? c : 0\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `DIV` opcode returns zero when the denominator is 0.\\n                result := div(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `MOD` opcode returns zero when the denominator is 0.\\n                result := mod(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating addition, bounds to `2\\u00b2\\u2075\\u2076 - 1` instead of overflowing.\\n     */\\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryAdd(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\\n     */\\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (, uint256 result) = trySub(a, b);\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating multiplication, bounds to `2\\u00b2\\u2075\\u2076 - 1` instead of overflowing.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryMul(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a > b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a < b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     *\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (high == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return low / denominator;\\n            }\\n\\n            // Make sure the result is less than 2\\u00b2\\u2075\\u2076. Also prevents denominator == 0.\\n            if (denominator <= high) {\\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [high low].\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                high := sub(high, gt(remainder, low))\\n                low := sub(low, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly (\\\"memory-safe\\\") {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [high low] by twos.\\n                low := div(low, twos)\\n\\n                // Flip twos such that it is 2\\u00b2\\u2075\\u2076 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from high into low.\\n            low |= high * twos;\\n\\n            // Invert denominator mod 2\\u00b2\\u2075\\u2076. Now that denominator is an odd number, it has an inverse modulo 2\\u00b2\\u2075\\u2076 such\\n            // that denominator * inv \\u2261 1 mod 2\\u00b2\\u2075\\u2076. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv \\u2261 1 mod 2\\u2074.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u2078\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b9\\u2076\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b3\\u00b2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u2076\\u2074\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b9\\u00b2\\u2078\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b2\\u2075\\u2076\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2\\u00b2\\u2075\\u2076. Since the preconditions guarantee that the outcome is\\n            // less than 2\\u00b2\\u2075\\u2076, this is the final result. We don't need to compute the high bits of the result and high\\n            // is no longer required.\\n            result = low * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n            if (high >= 1 << n) {\\n                Panic.panic(Panic.UNDER_OVERFLOW);\\n            }\\n            return (high << (256 - n)) | (low >> n);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\n     *\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\n     *\\n     * If the input value is not inversible, 0 is returned.\\n     *\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\\n     */\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\n        unchecked {\\n            if (n == 0) return 0;\\n\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\n            // ax + ny = 1\\n            // ax = 1 + (-y)n\\n            // ax \\u2261 1 (mod n) # x is the inverse of a modulo n\\n\\n            // If the remainder is 0 the gcd is n right away.\\n            uint256 remainder = a % n;\\n            uint256 gcd = n;\\n\\n            // Therefore the initial coefficients are:\\n            // ax + ny = gcd(a, n) = n\\n            // 0a + 1n = n\\n            int256 x = 0;\\n            int256 y = 1;\\n\\n            while (remainder != 0) {\\n                uint256 quotient = gcd / remainder;\\n\\n                (gcd, remainder) = (\\n                    // The old remainder is the next gcd to try.\\n                    remainder,\\n                    // Compute the next remainder.\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\\n                    // where gcd is at most n (capped to type(uint256).max)\\n                    gcd - remainder * quotient\\n                );\\n\\n                (x, y) = (\\n                    // Increment the coefficient of a.\\n                    y,\\n                    // Decrement the coefficient of n.\\n                    // Can overflow, but the result is casted to uint256 so that the\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\n                    x - y * int256(quotient)\\n                );\\n            }\\n\\n            if (gcd != 1) return 0; // No inverse exists.\\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\\n     *\\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\\n     * prime, then `a**(p-1) \\u2261 1 mod p`. As a consequence, we have `a * a**(p-2) \\u2261 1 mod p`, which means that\\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\\n     *\\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\\n     */\\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\\n        unchecked {\\n            return Math.modExp(a, p - 2, p);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\n     *\\n     * Requirements:\\n     * - modulus can't be zero\\n     * - underlying staticcall to precompile must succeed\\n     *\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\n     * interpreted as 0.\\n     */\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\\n     * to operate modulo 0 or if the underlying precompile reverted.\\n     *\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\n     */\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\n        if (m == 0) return (false, 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            // | Offset    | Content    | Content (Hex)                                                      |\\n            // |-----------|------------|--------------------------------------------------------------------|\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\\n            mstore(ptr, 0x20)\\n            mstore(add(ptr, 0x20), 0x20)\\n            mstore(add(ptr, 0x40), 0x20)\\n            mstore(add(ptr, 0x60), b)\\n            mstore(add(ptr, 0x80), e)\\n            mstore(add(ptr, 0xa0), m)\\n\\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\\n            // so we can use the memory scratch space located at offset 0.\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\n     */\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\n     */\\n    function tryModExp(\\n        bytes memory b,\\n        bytes memory e,\\n        bytes memory m\\n    ) internal view returns (bool success, bytes memory result) {\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\n\\n        uint256 mLen = m.length;\\n\\n        // Encode call args in result and move the free memory pointer\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPtr := add(result, 0x20)\\n            // Write result on top of args to avoid allocating extra memory.\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\n            // Overwrite the length.\\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\\n            mstore(result, mLen)\\n            // Set the memory pointer after the returned data.\\n            mstore(0x40, add(dataPtr, mLen))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the provided byte array is zero.\\n     */\\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\\n        for (uint256 i = 0; i < byteArray.length; ++i) {\\n            if (byteArray[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\n     * using integer operations.\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        unchecked {\\n            // Take care of easy edge cases when a == 0 or a == 1\\n            if (a <= 1) {\\n                return a;\\n            }\\n\\n            // In this function, we use Newton's method to get a root of `f(x) := x\\u00b2 - a`. It involves building a\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\n            // the current value as `\\u03b5_n = | x_n - sqrt(a) |`.\\n            //\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\n            // of the target. (i.e. `2**(e-1) \\u2264 sqrt(a) < 2**e`). We know that `e \\u2264 128` because `(2\\u00b9\\u00b2\\u2078)\\u00b2 = 2\\u00b2\\u2075\\u2076` is\\n            // bigger than any uint256.\\n            //\\n            // By noticing that\\n            // `2**(e-1) \\u2264 sqrt(a) < 2**e \\u2192 (2**(e-1))\\u00b2 \\u2264 a < (2**e)\\u00b2 \\u2192 2**(2*e-2) \\u2264 a < 2**(2*e)`\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\n            // to the msb function.\\n            uint256 aa = a;\\n            uint256 xn = 1;\\n\\n            if (aa >= (1 << 128)) {\\n                aa >>= 128;\\n                xn <<= 64;\\n            }\\n            if (aa >= (1 << 64)) {\\n                aa >>= 64;\\n                xn <<= 32;\\n            }\\n            if (aa >= (1 << 32)) {\\n                aa >>= 32;\\n                xn <<= 16;\\n            }\\n            if (aa >= (1 << 16)) {\\n                aa >>= 16;\\n                xn <<= 8;\\n            }\\n            if (aa >= (1 << 8)) {\\n                aa >>= 8;\\n                xn <<= 4;\\n            }\\n            if (aa >= (1 << 4)) {\\n                aa >>= 4;\\n                xn <<= 2;\\n            }\\n            if (aa >= (1 << 2)) {\\n                xn <<= 1;\\n            }\\n\\n            // We now have x_n such that `x_n = 2**(e-1) \\u2264 sqrt(a) < 2**e = 2 * x_n`. This implies \\u03b5_n \\u2264 2**(e-1).\\n            //\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to \\u03b5_n \\u2264 2**(e-2).\\n            // This is going to be our x_0 (and \\u03b5_0)\\n            xn = (3 * xn) >> 1; // \\u03b5_0 := | x_0 - sqrt(a) | \\u2264 2**(e-2)\\n\\n            // From here, Newton's method give us:\\n            // x_{n+1} = (x_n + a / x_n) / 2\\n            //\\n            // One should note that:\\n            // x_{n+1}\\u00b2 - a = ((x_n + a / x_n) / 2)\\u00b2 - a\\n            //              = ((x_n\\u00b2 + a) / (2 * x_n))\\u00b2 - a\\n            //              = (x_n\\u2074 + 2 * a * x_n\\u00b2 + a\\u00b2) / (4 * x_n\\u00b2) - a\\n            //              = (x_n\\u2074 + 2 * a * x_n\\u00b2 + a\\u00b2 - 4 * a * x_n\\u00b2) / (4 * x_n\\u00b2)\\n            //              = (x_n\\u2074 - 2 * a * x_n\\u00b2 + a\\u00b2) / (4 * x_n\\u00b2)\\n            //              = (x_n\\u00b2 - a)\\u00b2 / (2 * x_n)\\u00b2\\n            //              = ((x_n\\u00b2 - a) / (2 * x_n))\\u00b2\\n            //              \\u2265 0\\n            // Which proves that for all n \\u2265 1, sqrt(a) \\u2264 x_n\\n            //\\n            // This gives us the proof of quadratic convergence of the sequence:\\n            // \\u03b5_{n+1} = | x_{n+1} - sqrt(a) |\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\n            //         = | (x_n\\u00b2 + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\n            //         = | (x_n - sqrt(a))\\u00b2 / (2 * x_n) |\\n            //         = | \\u03b5_n\\u00b2 / (2 * x_n) |\\n            //         = \\u03b5_n\\u00b2 / | (2 * x_n) |\\n            //\\n            // For the first iteration, we have a special case where x_0 is known:\\n            // \\u03b5_1 = \\u03b5_0\\u00b2 / | (2 * x_0) |\\n            //     \\u2264 (2**(e-2))\\u00b2 / (2 * (2**(e-1) + 2**(e-2)))\\n            //     \\u2264 2**(2*e-4) / (3 * 2**(e-1))\\n            //     \\u2264 2**(e-3) / 3\\n            //     \\u2264 2**(e-3-log2(3))\\n            //     \\u2264 2**(e-4.5)\\n            //\\n            // For the following iterations, we use the fact that, 2**(e-1) \\u2264 sqrt(a) \\u2264 x_n:\\n            // \\u03b5_{n+1} = \\u03b5_n\\u00b2 / | (2 * x_n) |\\n            //         \\u2264 (2**(e-k))\\u00b2 / (2 * 2**(e-1))\\n            //         \\u2264 2**(2*e-2*k) / 2**e\\n            //         \\u2264 2**(e-2*k)\\n            xn = (xn + a / xn) >> 1; // \\u03b5_1 := | x_1 - sqrt(a) | \\u2264 2**(e-4.5)  -- special case, see above\\n            xn = (xn + a / xn) >> 1; // \\u03b5_2 := | x_2 - sqrt(a) | \\u2264 2**(e-9)    -- general case with k = 4.5\\n            xn = (xn + a / xn) >> 1; // \\u03b5_3 := | x_3 - sqrt(a) | \\u2264 2**(e-18)   -- general case with k = 9\\n            xn = (xn + a / xn) >> 1; // \\u03b5_4 := | x_4 - sqrt(a) | \\u2264 2**(e-36)   -- general case with k = 18\\n            xn = (xn + a / xn) >> 1; // \\u03b5_5 := | x_5 - sqrt(a) | \\u2264 2**(e-72)   -- general case with k = 36\\n            xn = (xn + a / xn) >> 1; // \\u03b5_6 := | x_6 - sqrt(a) | \\u2264 2**(e-144)  -- general case with k = 72\\n\\n            // Because e \\u2264 128 (as discussed during the first estimation phase), we know have reached a precision\\n            // \\u03b5_6 \\u2264 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\\n            // sqrt(a) or sqrt(a) + 1.\\n            return xn - SafeCast.toUint(xn > a / xn);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // If upper 8 bits of 16-bit half set, add 8 to result\\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\\n        // If upper 4 bits of 8-bit half set, add 4 to result\\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\\n\\n        // Shifts value right by the current result and use it as an index into this lookup table:\\n        //\\n        // | x (4 bits) |  index  | table[index] = MSB position |\\n        // |------------|---------|-----------------------------|\\n        // |    0000    |    0    |        table[0] = 0         |\\n        // |    0001    |    1    |        table[1] = 0         |\\n        // |    0010    |    2    |        table[2] = 1         |\\n        // |    0011    |    3    |        table[3] = 1         |\\n        // |    0100    |    4    |        table[4] = 2         |\\n        // |    0101    |    5    |        table[5] = 2         |\\n        // |    0110    |    6    |        table[6] = 2         |\\n        // |    0111    |    7    |        table[7] = 2         |\\n        // |    1000    |    8    |        table[8] = 3         |\\n        // |    1001    |    9    |        table[9] = 3         |\\n        // |    1010    |   10    |        table[10] = 3        |\\n        // |    1011    |   11    |        table[11] = 3        |\\n        // |    1100    |   12    |        table[12] = 3        |\\n        // |    1101    |   13    |        table[13] = 3        |\\n        // |    1110    |   14    |        table[14] = 3        |\\n        // |    1111    |   15    |        table[15] = 3        |\\n        //\\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x1225214420c83ebcca88f2ae2b50f053aaa7df7bd684c3e878d334627f2edfc6\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0xb25a4f11fa80c702bf5cd85adec90e6f6f507f32f4a8e6f5dbc31e8c10029486\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.22;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {IERC1967} from \\\"../../interfaces/IERC1967.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This library provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit IERC1967.Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit IERC1967.BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02caa0e5f7bade9a0d8ad6058467d641cb67697cd4678c7b1c170686bafe9128\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\",\"keccak256\":\"0xc3f2ec76a3de8ed7a7007c46166f5550c72c7709e3fc7e8bb3111a7191cdedbd\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9d8da059267bac779a2dbbb9a26c2acf00ca83085e105d62d5d4ef96054a47f5\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n            // if no address was created, and returndata is not empty, bubble revert\\n            if and(iszero(addr), not(iszero(returndatasize()))) {\\n                let p := mload(0x40)\\n                returndatacopy(p, 0, returndatasize())\\n                revert(p, returndatasize())\\n            }\\n        }\\n        if (addr == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb7e8401583d26268ea9103013bcdcd90866a7718bd91105ebd21c9bf11f4f06\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/utils/SlotDerivation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/SlotDerivation.sol)\\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\\n * the solidity language / compiler.\\n *\\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\\n *\\n * Example usage:\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using StorageSlot for bytes32;\\n *     using SlotDerivation for bytes32;\\n *\\n *     // Declare a namespace\\n *     string private constant _NAMESPACE = \\\"<namespace>\\\" // eg. OpenZeppelin.Slot\\n *\\n *     function setValueInNamespace(uint256 key, address newValue) internal {\\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\\n *     }\\n *\\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {StorageSlot}.\\n *\\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\\n * upgrade safety will ignore the slots accessed through this library.\\n *\\n * _Available since v5.1._\\n */\\nlibrary SlotDerivation {\\n    /**\\n     * @dev Derive an ERC-7201 slot from a string (namespace).\\n     */\\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\\n            slot := and(keccak256(0x00, 0x20), not(0xff))\\n        }\\n    }\\n\\n    /**\\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\\n     */\\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\\n        unchecked {\\n            return bytes32(uint256(slot) + pos);\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\\n     */\\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, slot)\\n            result := keccak256(0x00, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, and(key, shr(96, not(0))))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, iszero(iszero(key)))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8447b57b63810fe2e367c09496a966f143ec0e825d71ddb9fce2506cff84b618\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/src/IUUPSProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface IUUPSProxy {\\n    function getVerifiableProxySalt() external view returns (bytes32);\\n\\n    function verifiableProxyFactory() external view returns (address);\\n}\\n\",\"keccak256\":\"0x7b83c27ad0fe616286f4b28415dafd21bb6c1517a511d8a798c5936058da8f49\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/src/UUPSProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// This contract was adapted from OpenZeppelin's ERC1967Proxy and UUPS proxy pattern.\\n// @ref: @openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\n// @ref: @openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\npragma solidity ^0.8.20;\\n\\nimport {Proxy} from \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport {ERC1967Utils, StorageSlot} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {SlotDerivation} from \\\"@openzeppelin/contracts/utils/SlotDerivation.sol\\\";\\nimport {IUUPSProxy} from \\\"./IUUPSProxy.sol\\\";\\n\\ncontract UUPSProxy is Proxy, IUUPSProxy {\\n    using StorageSlot for bytes32;\\n    using SlotDerivation for string;\\n\\n    string internal constant _SALT_SLOT = \\\"eth.ens.proxy.verifiable.salt\\\";\\n\\n    // immutable variable (in bytecode)\\n    address public immutable verifiableProxyFactory;\\n\\n    constructor(address _factory, bytes32 _salt) {\\n        verifiableProxyFactory = _factory;\\n        _setSalt(_salt);\\n    }\\n\\n    /**\\n     * @dev Initializes the verifiable proxy with an initial implementation specified by `implementation`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - If `data` is empty, `msg.value` must be zero.\\n     */\\n    function initialize(address implementation, bytes memory data) public payable {\\n        require(implementation != address(0), \\\"New implementation cannot be the zero address\\\");\\n        require(_implementation() == address(0), \\\"Already initialized\\\");\\n\\n        ERC1967Utils.upgradeToAndCall(implementation, data);\\n    }\\n\\n    function getVerifiableProxySalt() public view returns (bytes32) {\\n        return _SALT_SLOT.erc7201Slot().getBytes32Slot().value;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC1967Utils.getImplementation();\\n    }\\n\\n    function _setSalt(bytes32 _salt) internal {\\n        _SALT_SLOT.erc7201Slot().getBytes32Slot().value = _salt;\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x0e124d935f05c3f19363fdb60e0645a28f4d6db6ed19a168d26b43d2fd7eecd0\",\"license\":\"MIT\"},\"project/lib/verifiable-factory/src/VerifiableFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {console} from \\\"forge-std/console.sol\\\";\\nimport {Create2} from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport {UUPSProxy} from \\\"./UUPSProxy.sol\\\";\\nimport {IUUPSProxy} from \\\"./IUUPSProxy.sol\\\";\\n\\ncontract VerifiableFactory {\\n    event ProxyDeployed(address indexed sender, address indexed proxyAddress, uint256 salt, address implementation);\\n\\n    /**\\n     * @dev Deploys a new `UUPSProxy` contract at a deterministic address.\\n     *\\n     * This function deploys a proxy contract using the CREATE2 opcode, ensuring a predictable\\n     * address based on the sender's address and a provided salt. The deployed proxy is\\n     * controlled by the factory and is initialized to use a specific implementation.\\n     *\\n     * - A unique address for the proxy is generated using the caller's address and the salt.\\n     * - After deployment, the proxy's `initialize` function is called to configure it with the given salt,\\n     *   the factory address, and the provided implementation address.\\n     * - The proxy is fully managed by the factory, which controls upgrades and other administrative methods.\\n     * - The event `ProxyDeployed` is emitted, logging details of the deployment including the sender, proxy address, salt, and implementation.\\n     *\\n     * @param implementation The address of the contract implementation the proxy will delegate calls to.\\n     * @param salt A value provided by the caller to ensure uniqueness of the proxy address.\\n     * @return proxy The address of the deployed `UUPSProxy`.\\n     */\\n    function deployProxy(address implementation, uint256 salt, bytes memory data) external returns (address) {\\n        bytes32 outerSalt = keccak256(abi.encode(msg.sender, salt));\\n\\n        UUPSProxy proxy = new UUPSProxy{salt: outerSalt}(address(this), outerSalt);\\n\\n        require(isContract(address(proxy)), \\\"Proxy deployment failed\\\");\\n\\n        proxy.initialize(implementation, data);\\n\\n        emit ProxyDeployed(msg.sender, address(proxy), salt, implementation);\\n        return address(proxy);\\n    }\\n\\n    /**\\n     * @dev Initiates verification of a proxy contract.\\n     *\\n     * This function attempts to validate a proxy contract by retrieving its salt\\n     * and reconstructing the address to ensure it was correctly deployed by the\\n     * current factory.\\n     *\\n     * @param proxy The address of the proxy contract being verified.\\n     * @return A boolean indicating whether the verification succeeded.\\n     */\\n    function verifyContract(address proxy) public view returns (bool) {\\n        if (!isContract(proxy)) {\\n            return false;\\n        }\\n        try IUUPSProxy(proxy).getVerifiableProxySalt() returns (bytes32 salt) {\\n            return _verifyContract(proxy, salt);\\n        } catch {}\\n\\n        return false;\\n    }\\n\\n    function _verifyContract(address proxy, bytes32 salt) private view returns (bool) {\\n        // get creation bytecode with constructor arguments\\n        bytes memory bytecode = abi.encodePacked(type(UUPSProxy).creationCode, abi.encode(address(this), salt));\\n\\n        address expectedProxyAddress = Create2.computeAddress(salt, keccak256(bytecode), address(this));\\n\\n        return expectedProxyAddress == proxy;\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa6deb0e9379f5dd3d4e23c9523b7f922b6ca5db6ef1ee3ce61198d4a6bbbf53e\",\"license\":\"MIT\"},\"project/src/CommonErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/**\\n * @title Errors\\n * @dev Common error definitions used across multiple contracts\\n */\\n\\n/**\\n * @dev Thrown when an operation requires a valid owner but receives the zero address\\n */\\nerror InvalidOwner();\\n\\n/**\\n * @dev Thrown when a caller is not authorized to perform the requested operation\\n * @param caller The address that attempted the unauthorized operation\\n */\\nerror UnauthorizedCaller(address caller);\\n\\n/// @notice Arrays have different lengths.\\n/// @param length1 The first array length.\\n/// @param length2 The second array length.\\nerror ArrayLengthMismatch(uint256 length1, uint256 length2);\\n\",\"keccak256\":\"0x545a8fc8ee6c02385b371b8afd9a0ad94940099332a08b28adbd25daa2e1cf23\",\"license\":\"MIT\"},\"project/src/access-control/EnhancedAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {HCAContext} from \\\"../hca/HCAContext.sol\\\";\\n\\nimport {IEnhancedAccessControl} from \\\"./interfaces/IEnhancedAccessControl.sol\\\";\\nimport {EACBaseRolesLib} from \\\"./libraries/EACBaseRolesLib.sol\\\";\\n\\n/// @dev Access control system that allows for:\\n///\\n///      - Resource-based roles.\\n///      - Obtaining assignee count for each role in each resource.\\n///      - Root resource override (0x0) - role assignments in the `ROOT_RESOURCE` auto-apply to all resources.\\n///      - Up to 32 roles and 32 corresponding admin roles - stored as a bitmap in uint256 (see below).\\n///      - Up to 15 assignees per role - stored as a bitmap in uint256 (64 * 4 bits = 256 bits) (see below).\\n///\\n///      Role representation:\\n///      - A role bitmap is a uint256, where the lower 128 bits represent the regular roles (0-31), and the upper 128 bits represent the admin roles (32-63) for those roles.\\n///      - Each role is represented by a nybble (4 bits), in little-endian order.\\n///      - If a given role left-most nybble bit is located at index N then the corresponding admin role nybble starts at bit position N << 128.\\nabstract contract EnhancedAccessControl is HCAContext, ERC165, IEnhancedAccessControl {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice The `ROOT_RESOURCE`.\\n    uint256 public constant ROOT_RESOURCE = 0;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Storage\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev user roles within a resource stored as a bitmap.\\n    ///      Resource -> User -> RoleBitmap\\n    mapping(uint256 resource => mapping(address account => uint256 roleBitmap)) private _roles;\\n\\n    /// @dev The number of assignees for a given role in a given resource.\\n    ///\\n    ///      Each role's count is represented by 4 bits, in little-endian order.\\n    ///      This results in max. 64 roles, and 15 assignees per role.\\n    mapping(uint256 resource => uint256 roleCount) private _roleCount;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Modifiers\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Modifier that checks that sender has the admin roles for all the given roles.\\n    modifier canGrantRoles(uint256 resource, uint256 roleBitmap) {\\n        _checkCanGrantRoles(resource, roleBitmap, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that sender has the admin roles for all the given roles and can revoke them.\\n     */\\n    modifier canRevokeRoles(uint256 resource, uint256 roleBitmap) {\\n        _checkCanRevokeRoles(resource, roleBitmap, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that sender has all the given roles within the given resource.\\n     */\\n    modifier onlyRoles(uint256 resource, uint256 roleBitmap) {\\n        _checkRoles(resource, roleBitmap, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that sender has all the given roles within the `ROOT_RESOURCE`.\\n     */\\n    modifier onlyRootRoles(uint256 roleBitmap) {\\n        _checkRoles(ROOT_RESOURCE, roleBitmap, _msgSender());\\n        _;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IEnhancedAccessControl).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n    /**\\n     * @dev Grants all roles in the given role bitmap to `account`.\\n     *\\n     * The caller must have all the necessary admin roles for the roles being granted.\\n     * Cannot be used with ROOT_RESOURCE directly, use grantRootRoles instead.\\n     *\\n     * @param resource The resource to grant roles within.\\n     * @param roleBitmap The roles bitmap to grant.\\n     * @param account The account to grant roles to.\\n     * @return `true` if the roles were granted, `false` otherwise.\\n     */\\n    function grantRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) public virtual canGrantRoles(resource, roleBitmap) returns (bool) {\\n        if (resource == ROOT_RESOURCE) {\\n            revert EACRootResourceNotAllowed();\\n        }\\n        return _grantRoles(resource, roleBitmap, account, true);\\n    }\\n\\n    /**\\n     * @dev Grants all roles in the given role bitmap to `account` in the ROOT_RESOURCE.\\n     *\\n     * The caller must have all the necessary admin roles for the roles being granted.\\n     *\\n     * @param roleBitmap The roles bitmap to grant.\\n     * @param account The account to grant roles to.\\n     * @return `true` if the roles were granted, `false` otherwise.\\n     */\\n    function grantRootRoles(\\n        uint256 roleBitmap,\\n        address account\\n    ) public virtual canGrantRoles(ROOT_RESOURCE, roleBitmap) returns (bool) {\\n        return _grantRoles(ROOT_RESOURCE, roleBitmap, account, true);\\n    }\\n\\n    /**\\n     * @dev Revokes all roles in the given role bitmap from `account`.\\n     *\\n     * The caller must have all the necessary admin roles for the roles being revoked.\\n     * Cannot be used with ROOT_RESOURCE directly, use revokeRootRoles instead.\\n     *\\n     * @param resource The resource to revoke roles within.\\n     * @param roleBitmap The roles bitmap to revoke.\\n     * @param account The account to revoke roles from.\\n     * @return `true` if the roles were revoked, `false` otherwise.\\n     */\\n    function revokeRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) public virtual canRevokeRoles(resource, roleBitmap) returns (bool) {\\n        if (resource == ROOT_RESOURCE) {\\n            revert EACRootResourceNotAllowed();\\n        }\\n        return _revokeRoles(resource, roleBitmap, account, true);\\n    }\\n\\n    /**\\n     * @dev Revokes all roles in the given role bitmap from `account` in the ROOT_RESOURCE.\\n     *\\n     * The caller must have all the necessary admin roles for the roles being revoked.\\n     *\\n     * @param roleBitmap The roles bitmap to revoke.\\n     * @param account The account to revoke roles from.\\n     * @return `true` if the roles were revoked, `false` otherwise.\\n     */\\n    function revokeRootRoles(\\n        uint256 roleBitmap,\\n        address account\\n    ) public virtual canRevokeRoles(ROOT_RESOURCE, roleBitmap) returns (bool) {\\n        return _revokeRoles(ROOT_RESOURCE, roleBitmap, account, true);\\n    }\\n\\n    /// @notice Returns the roles bitmap for an account in a resource.\\n    function roles(uint256 resource, address account) public view virtual returns (uint256) {\\n        return _roles[resource][account];\\n    }\\n\\n    /// @notice Returns the role count bitmap for a resource.\\n    function roleCount(uint256 resource) public view virtual returns (uint256) {\\n        return _roleCount[resource];\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`.\\n     *\\n     * @param rolesBitmap The roles bitmap to check.\\n     * @param account The account to check.\\n     * @return `true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`, `false` otherwise.\\n     */\\n    function hasRootRoles(uint256 rolesBitmap, address account) public view virtual returns (bool) {\\n        return _roles[ROOT_RESOURCE][account] & rolesBitmap == rolesBitmap;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted all the given roles in `resource`.\\n     *\\n     * @param resource The resource to check.\\n     * @param rolesBitmap The roles bitmap to check.\\n     * @param account The account to check.\\n     * @return `true` if `account` has been granted all the given roles in either `resource` or the `ROOT_RESOURCE`, `false` otherwise.\\n     */\\n    function hasRoles(\\n        uint256 resource,\\n        uint256 rolesBitmap,\\n        address account\\n    ) public view virtual returns (bool) {\\n        return\\n            (_roles[ROOT_RESOURCE][account] | _roles[resource][account]) & rolesBitmap ==\\n            rolesBitmap;\\n    }\\n\\n    /**\\n     * @dev Get if any of the roles in the given role bitmap has assignees.\\n     *\\n     * @param resource The resource to check.\\n     * @param roleBitmap The roles bitmap to check.\\n     * @return `true` if any of the roles in the given role bitmap has assignees, `false` otherwise.\\n     */\\n    function hasAssignees(uint256 resource, uint256 roleBitmap) public view virtual returns (bool) {\\n        (uint256 counts, ) = getAssigneeCount(resource, roleBitmap);\\n        return counts != 0;\\n    }\\n\\n    /**\\n     * @dev Get the no. of assignees for the roles in the given role bitmap.\\n     *\\n     * @param resource The resource to check.\\n     * @param roleBitmap The roles bitmap to check.\\n     * @return counts The no. of assignees for each of the roles in the given role bitmap, expressed as a packed array of 4-bit ints.\\n     * @return mask The mask for the given role bitmap.\\n     */\\n    function getAssigneeCount(\\n        uint256 resource,\\n        uint256 roleBitmap\\n    ) public view virtual returns (uint256 counts, uint256 mask) {\\n        mask = _roleBitmapToMask(roleBitmap);\\n        counts = _roleCount[resource] & mask;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Internal Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Transfers all roles from `srcAccount` to `dstAccount` within the same resource.\\n     *\\n     * This function first revokes all roles from the source account, then grants them to the\\n     * destination account. This prevents exceeding max assignees limits during transfer.\\n     *\\n     * Does nothing if there are no roles to transfer.\\n     *\\n     * @param resource The resource to transfer roles within.\\n     * @param srcAccount The account to transfer roles from.\\n     * @param dstAccount The account to transfer roles to.\\n     * @param executeCallbacks Whether to execute the callbacks.\\n     */\\n    function _transferRoles(\\n        uint256 resource,\\n        address srcAccount,\\n        address dstAccount,\\n        bool executeCallbacks\\n    ) internal virtual {\\n        uint256 srcRoles = _roles[resource][srcAccount];\\n        if (srcRoles != 0) {\\n            // First revoke roles from source account to free up assignee slots\\n            _revokeRoles(resource, srcRoles, srcAccount, executeCallbacks);\\n            // Then grant roles to destination account\\n            _grantRoles(resource, srcRoles, dstAccount, executeCallbacks);\\n        }\\n    }\\n\\n    /**\\n     * @dev Grants multiple roles to `account`.\\n     *\\n     * @param resource The resource to grant roles within.\\n     * @param roleBitmap The roles bitmap to grant.\\n     * @param account The account to grant roles to.\\n     * @param executeCallbacks Whether to execute the callbacks.\\n     * @return `true` if the roles were granted, `false` otherwise.\\n     */\\n    function _grantRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account,\\n        bool executeCallbacks\\n    ) internal virtual returns (bool) {\\n        _checkRoleBitmap(roleBitmap);\\n        if (account == address(0)) {\\n            revert EACInvalidAccount();\\n        }\\n        uint256 currentRoles = _roles[resource][account];\\n        uint256 updatedRoles = currentRoles | roleBitmap;\\n\\n        if (currentRoles != updatedRoles) {\\n            _roles[resource][account] = updatedRoles;\\n            uint256 newlyAddedRoles = roleBitmap & ~currentRoles;\\n            _updateRoleCounts(resource, newlyAddedRoles, true);\\n            if (executeCallbacks) {\\n                _onRolesGranted(resource, account, currentRoles, updatedRoles, roleBitmap);\\n            }\\n            emit EACRolesChanged(resource, account, currentRoles, updatedRoles);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke roles from `account` and returns a boolean indicating if roles were revoked.\\n     *\\n     * @param resource The resource to revoke roles within.\\n     * @param roleBitmap The roles bitmap to revoke.\\n     * @param account The account to revoke roles from.\\n     * @param executeCallbacks Whether to execute the callbacks.\\n     * @return `true` if the roles were revoked, `false` otherwise.\\n     */\\n    function _revokeRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account,\\n        bool executeCallbacks\\n    ) internal virtual returns (bool) {\\n        _checkRoleBitmap(roleBitmap);\\n        uint256 currentRoles = _roles[resource][account];\\n        uint256 updatedRoles = currentRoles & ~roleBitmap;\\n\\n        if (currentRoles != updatedRoles) {\\n            _roles[resource][account] = updatedRoles;\\n            uint256 newlyRemovedRoles = roleBitmap & currentRoles;\\n            _updateRoleCounts(resource, newlyRemovedRoles, false);\\n            if (executeCallbacks) {\\n                _onRolesRevoked(resource, account, currentRoles, updatedRoles, roleBitmap);\\n            }\\n            emit EACRolesChanged(resource, account, currentRoles, updatedRoles);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Revoke all roles for account within resource.\\n     */\\n    function _revokeAllRoles(\\n        uint256 resource,\\n        address account,\\n        bool executeCallbacks\\n    ) internal virtual returns (bool) {\\n        return _revokeRoles(resource, EACBaseRolesLib.ALL_ROLES, account, executeCallbacks);\\n    }\\n\\n    /**\\n     * @dev Updates role counts when roles are granted/revoked\\n     * @param resource The resource to update counts for\\n     * @param roleBitmap The roles being modified\\n     * @param isGrant true for grant, false for revoke\\n     */\\n    function _updateRoleCounts(uint256 resource, uint256 roleBitmap, bool isGrant) internal {\\n        uint256 roleMask = _roleBitmapToMask(roleBitmap);\\n\\n        if (isGrant) {\\n            // Check for overflow\\n            if (_hasZeroNybbles(~(roleMask & _roleCount[resource]))) {\\n                revert EACMaxAssignees(resource, roleBitmap);\\n            }\\n            _roleCount[resource] += roleBitmap;\\n        } else {\\n            // Check for underflow\\n            if (_hasZeroNybbles(~(roleMask & ~_roleCount[resource]))) {\\n                revert EACMinAssignees(resource, roleBitmap);\\n            }\\n            _roleCount[resource] -= roleBitmap;\\n        }\\n    }\\n\\n    /**\\n     * @dev Callback for when roles are granted.\\n     *\\n     * @param resource The resource that the roles were granted within.\\n     * @param account The account that the roles were granted to.\\n     * @param oldRoles The old roles for the account.\\n     * @param newRoles The new roles for the account.\\n     * @param roleBitmap The roles that were granted.\\n     */\\n    function _onRolesGranted(\\n        uint256 resource,\\n        address account,\\n        uint256 oldRoles,\\n        uint256 newRoles,\\n        uint256 roleBitmap\\n    ) internal virtual {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Callback for when roles are revoked.\\n     *\\n     * @param resource The resource that the roles were revoked within.\\n     * @param account The account that the roles were revoked from.\\n     * @param oldRoles The old roles for the account.\\n     * @param newRoles The new roles for the account.\\n     * @param roleBitmap The roles that were revoked.\\n     */\\n    function _onRolesRevoked(\\n        uint256 resource,\\n        address account,\\n        uint256 oldRoles,\\n        uint256 newRoles,\\n        uint256 roleBitmap\\n    ) internal virtual {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Reverts if `account` does not have all the given roles.\\n     */\\n    function _checkRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) internal view virtual {\\n        if (!hasRoles(resource, roleBitmap, account)) {\\n            revert EACUnauthorizedAccountRoles(resource, roleBitmap, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `account` does not have the admin roles for all the given roles.\\n     */\\n    function _checkCanGrantRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) internal view virtual {\\n        uint256 settableRoles = _getSettableRoles(resource, account);\\n        if ((roleBitmap & ~settableRoles) != 0) {\\n            revert EACCannotGrantRoles(resource, roleBitmap, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `account` does not have the admin roles for all the given roles that are being revoked.\\n     */\\n    function _checkCanRevokeRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) internal view virtual {\\n        uint256 revokableRoles = _getRevokableRoles(resource, account);\\n        if ((roleBitmap & ~revokableRoles) != 0) {\\n            revert EACCannotRevokeRoles(resource, roleBitmap, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the settable roles for `account` within `resource`.\\n     *\\n     * The settable roles are the roles (both regular and admin) that the account can grant.\\n     * An account can grant a regular role if they have the corresponding admin role.\\n     * An account can grant an admin role if they have that same admin role.\\n     *\\n     * @param resource The resource to get settable roles for.\\n     * @param account The account to get settable roles for.\\n     * @return The settable roles for `account` within `resource`.\\n     */\\n    function _getSettableRoles(\\n        uint256 resource,\\n        address account\\n    ) internal view virtual returns (uint256) {\\n        uint256 adminRoleBitmap = (_roles[resource][account] | _roles[ROOT_RESOURCE][account]) &\\n            EACBaseRolesLib.ADMIN_ROLES;\\n        return (adminRoleBitmap >> 128) | adminRoleBitmap;\\n    }\\n\\n    /**\\n     * @dev Returns the revokable roles for `account` within `resource`.\\n     *\\n     * The revokable roles are the roles (including admin roles) that the account can revoke.\\n     * Unlike settable roles, this includes admin roles that can be revoked.\\n     *\\n     * @param resource The resource to get revokable roles for.\\n     * @param account The account to get revokable roles for.\\n     * @return The revokable roles for `account` within `resource`.\\n     */\\n    function _getRevokableRoles(\\n        uint256 resource,\\n        address account\\n    ) internal view virtual returns (uint256) {\\n        uint256 adminRoleBitmap = (_roles[resource][account] | _roles[ROOT_RESOURCE][account]) &\\n            EACBaseRolesLib.ADMIN_ROLES;\\n        uint256 regularRoles = adminRoleBitmap >> 128;\\n        return regularRoles | adminRoleBitmap;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Private Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Checks if a role bitmap contains only valid role bits.\\n     *\\n     * @param roleBitmap The role bitmap to check.\\n     */\\n    function _checkRoleBitmap(uint256 roleBitmap) private pure {\\n        if ((roleBitmap & ~EACBaseRolesLib.ALL_ROLES) != 0) {\\n            revert EACInvalidRoleBitmap(roleBitmap);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a role bitmap to a mask.\\n     *\\n     * The mask is a bitmap where each nybble is set if the corresponding role is in the role bitmap.\\n     *\\n     * @param roleBitmap The role bitmap to convert.\\n     * @return roleMask The mask for the role bitmap.\\n     */\\n    function _roleBitmapToMask(uint256 roleBitmap) private pure returns (uint256 roleMask) {\\n        _checkRoleBitmap(roleBitmap);\\n        roleMask = roleBitmap | (roleBitmap << 1);\\n        roleMask |= roleMask << 2;\\n    }\\n\\n    /**\\n     * @dev Checks if the given value has any zero nybbles.\\n     *\\n     * @param value The value to check.\\n     * @return `true` if the value has any zero nybbles, `false` otherwise.\\n     */\\n    function _hasZeroNybbles(uint256 value) private pure returns (bool) {\\n        // Algorithm source: https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord\\n        uint256 hasZeroNybbles;\\n        unchecked {\\n            hasZeroNybbles =\\n                (value - 0x1111111111111111111111111111111111111111111111111111111111111111) &\\n                ~value &\\n                0x8888888888888888888888888888888888888888888888888888888888888888;\\n        }\\n        return hasZeroNybbles != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9b936e81b5159c2457de6152f59be5bc81865d39f5a3d7c967dbbbcceeeeec85\",\"license\":\"MIT\"},\"project/src/access-control/interfaces/IEnhancedAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for Enhanced Access Control system that allows for:\\n * - Resource-based roles\\n * - Obtaining assignee count for each role in each resource\\n * - Root resource override\\n * - Up to 32 roles and 32 corresponding admin roles\\n * - Up to 15 assignees per role\\n */\\ninterface IEnhancedAccessControl is IERC165 {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Events\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    event EACRolesChanged(\\n        uint256 indexed resource,\\n        address indexed account,\\n        uint256 oldRoleBitmap,\\n        uint256 newRoleBitmap\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    error EACUnauthorizedAccountRoles(uint256 resource, uint256 roleBitmap, address account);\\n\\n    error EACCannotGrantRoles(uint256 resource, uint256 roleBitmap, address account);\\n\\n    error EACCannotRevokeRoles(uint256 resource, uint256 roleBitmap, address account);\\n\\n    error EACRootResourceNotAllowed();\\n\\n    error EACMaxAssignees(uint256 resource, uint256 role);\\n\\n    error EACMinAssignees(uint256 resource, uint256 role);\\n\\n    error EACInvalidRoleBitmap(uint256 roleBitmap);\\n\\n    error EACInvalidAccount();\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Grants all roles in the given role bitmap to `account`.\\n     */\\n    function grantRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Grants all roles in the given role bitmap to `account` in the ROOT_RESOURCE.\\n     */\\n    function grantRootRoles(uint256 roleBitmap, address account) external returns (bool);\\n\\n    /**\\n     * @dev Revokes all roles in the given role bitmap from `account`.\\n     */\\n    function revokeRoles(\\n        uint256 resource,\\n        uint256 roleBitmap,\\n        address account\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Revokes all roles in the given role bitmap from `account` in the ROOT_RESOURCE.\\n     */\\n    function revokeRootRoles(uint256 roleBitmap, address account) external returns (bool);\\n\\n    /**\\n     * @dev Returns the `ROOT_RESOURCE` constant.\\n     */\\n    function ROOT_RESOURCE() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the roles bitmap for an account in a resource.\\n     */\\n    function roles(uint256 resource, address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the role count bitmap for a resource.\\n     */\\n    function roleCount(uint256 resource) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted all the given roles in the `ROOT_RESOURCE`.\\n     */\\n    function hasRootRoles(uint256 rolesBitmap, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted all the given roles in `resource`.\\n     */\\n    function hasRoles(\\n        uint256 resource,\\n        uint256 rolesBitmap,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Get if any of the roles in the given role bitmap has assignees.\\n     */\\n    function hasAssignees(uint256 resource, uint256 roleBitmap) external view returns (bool);\\n\\n    /**\\n     * @dev Get the no. of assignees for the roles in the given role bitmap.\\n     */\\n    function getAssigneeCount(\\n        uint256 resource,\\n        uint256 roleBitmap\\n    ) external view returns (uint256 counts, uint256 mask);\\n}\\n\",\"keccak256\":\"0xca4a4d54153dfc1c0c04ccd1b560765c54d45b59793108064663d3807c0e3798\",\"license\":\"MIT\"},\"project/src/access-control/libraries/EACBaseRolesLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary EACBaseRolesLib {\\n    uint256 public constant ALL_ROLES =\\n        0x1111111111111111111111111111111111111111111111111111111111111111;\\n\\n    uint256 public constant ADMIN_ROLES =\\n        0x1111111111111111111111111111111100000000000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x904773ba27a898c3edde3346d378957d05d5120b9e2be5283171635e08f25137\",\"license\":\"MIT\"},\"project/src/erc1155/ERC1155Singleton.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// ERC1155 implementation that supports only a single token per ID. Stores owner information to allow\\n// fetching ownership information for a tokenId via `ownerOf`.\\n// Portions from OpenZeppelin Contracts (token/ERC1155/ERC1155.sol)\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155Errors} from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport {\\n    IERC1155MetadataURI\\n} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {ERC1155Utils} from \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol\\\";\\nimport {Arrays} from \\\"@openzeppelin/contracts/utils/Arrays.sol\\\";\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {HCAContext} from \\\"../hca/HCAContext.sol\\\";\\n\\nimport {IERC1155Singleton} from \\\"./interfaces/IERC1155Singleton.sol\\\";\\n\\nabstract contract ERC1155Singleton is\\n    HCAContext,\\n    ERC165,\\n    IERC1155Singleton,\\n    IERC1155Errors,\\n    IERC1155MetadataURI\\n{\\n    using Arrays for uint256[];\\n    using Arrays for address[];\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Storage\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    mapping(uint256 id => address account) private _owners;\\n\\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Events\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155Singleton).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) public virtual {\\n        address sender = _msgSender();\\n        if (from != sender && !isApprovedForAll(from, sender)) {\\n            revert ERC1155MissingApprovalForAll(sender, from);\\n        }\\n        _safeTransferFrom(from, to, id, value, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) public virtual {\\n        address sender = _msgSender();\\n        if (from != sender && !isApprovedForAll(from, sender)) {\\n            revert ERC1155MissingApprovalForAll(sender, from);\\n        }\\n        _safeBatchTransferFrom(from, to, ids, values, data);\\n    }\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        return _owners[id];\\n    }\\n\\n    function uri(uint256 /* id */) public view virtual returns (string memory);\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\\n        return ownerOf(id) == account ? 1 : 0;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual returns (uint256[] memory) {\\n        if (accounts.length != ids.length) {\\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\\n        }\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) public view virtual returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Internal Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\\n     * (or `to`) is the zero address.\\n     *\\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\\n     * - `ids` and `values` must have the same length.\\n     *\\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\\n     */\\n    function _update(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values\\n    ) internal virtual {\\n        if (ids.length != values.length) {\\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\\n        }\\n\\n        address operator = _msgSender();\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids.unsafeMemoryAccess(i);\\n            uint256 value = values.unsafeMemoryAccess(i);\\n\\n            if (value > 0) {\\n                address owner = _owners[id];\\n                if (owner != from) {\\n                    revert ERC1155InsufficientBalance(from, 0, value, id);\\n                } else if (value > 1) {\\n                    revert ERC1155InsufficientBalance(from, 1, value, id);\\n                }\\n                _owners[id] = to;\\n            }\\n        }\\n\\n        if (ids.length == 1) {\\n            uint256 id = ids.unsafeMemoryAccess(0);\\n            uint256 value = values.unsafeMemoryAccess(0);\\n            emit TransferSingle(operator, from, to, id, value);\\n        } else {\\n            emit TransferBatch(operator, from, to, ids, values);\\n        }\\n    }\\n\\n    /**\\n     * @dev Version of {_update} that performs the token acceptance check by calling\\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\\n     * contains code (eg. is a smart contract at the moment of execution).\\n     *\\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\\n     * overriding {_update} instead.\\n     */\\n    function _updateWithAcceptanceCheck(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) internal virtual {\\n        _update(from, to, ids, values);\\n        if (to != address(0)) {\\n            address operator = _msgSender();\\n            if (ids.length == 1) {\\n                uint256 id = ids.unsafeMemoryAccess(0);\\n                uint256 value = values.unsafeMemoryAccess(0);\\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\\n            } else {\\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     * - `ids` and `values` must have the same length.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `value` amount of tokens of type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `value` amount of tokens of type `id`.\\n     * - `ids` and `values` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the zero address.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC1155InvalidOperator(address(0));\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Private Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Creates an array in memory with only one value for each of the elements provided.\\n     */\\n    function _asSingletonArrays(\\n        uint256 element1,\\n        uint256 element2\\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Load the free memory pointer\\n            array1 := mload(0x40)\\n            // Set array length to 1\\n            mstore(array1, 1)\\n            // Store the single element at the next word after the length (where content starts)\\n            mstore(add(array1, 0x20), element1)\\n\\n            // Repeat for next array locating it right after the first array\\n            array2 := add(array1, 0x40)\\n            mstore(array2, 1)\\n            mstore(add(array2, 0x20), element2)\\n\\n            // Update the free memory pointer by pointing after the second array\\n            mstore(0x40, add(array2, 0x40))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x153e671c8d91a1d96bb5abddeef23e37d668cb18edf240edc2bb83d10fd4eed7\",\"license\":\"MIT\"},\"project/src/erc1155/interfaces/IERC1155Singleton.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IERC1155Singleton is IERC1155 {\\n    function ownerOf(uint256 id) external view returns (address owner);\\n}\\n\",\"keccak256\":\"0xbfa4f4f1da56c42a6e878895cbcfc50d0d612ca9d75dda04c6df1ca0fdb72494\",\"license\":\"MIT\"},\"project/src/hca/HCAContext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.25;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\nimport {HCAEquivalence} from \\\"./HCAEquivalence.sol\\\";\\n\\n/// @dev Replaces msg.sender\\nabstract contract HCAContext is Context, HCAEquivalence {\\n    /// @notice Returns either the account owner of an HCA or the original sender\\n    function _msgSender() internal view virtual override returns (address) {\\n        return _msgSenderWithHcaEquivalence();\\n    }\\n}\\n\",\"keccak256\":\"0x334a68522ae86cd7073cdaf6499c7e55456d927c60b4e6946bc90b0619080c85\",\"license\":\"MIT\"},\"project/src/hca/HCAEquivalence.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.25;\\n\\nimport {IHCAFactoryBasic} from \\\"./interfaces/IHCAFactoryBasic.sol\\\";\\n\\n/// @dev Replaces msg.sender\\nabstract contract HCAEquivalence {\\n    /// @notice The HCA factory contract\\n    IHCAFactoryBasic public immutable HCA_FACTORY;\\n\\n    constructor(IHCAFactoryBasic hcaFactory) {\\n        HCA_FACTORY = hcaFactory;\\n    }\\n\\n    /// @notice Returns either the account owner of an HCA or the original sender\\n    function _msgSenderWithHcaEquivalence() internal view returns (address) {\\n        if (address(HCA_FACTORY) == address(0)) return msg.sender;\\n        address accountOwner = HCA_FACTORY.getAccountOwner(msg.sender);\\n        if (accountOwner == address(0)) return msg.sender;\\n        return accountOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x51cf28e5de7b9eb9fd26ca77f56b353ec59c0187017e0a50cd49d8cf77cc5d8c\",\"license\":\"MIT\"},\"project/src/hca/interfaces/IHCAFactoryBasic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.25;\\n\\n/// @dev Basic interface for the HCA factory.\\ninterface IHCAFactoryBasic {\\n    /// @notice Returns the account owner of the given HCA\\n    /// @param hca The HCA to get the account owner of\\n    /// @return The account owner of the given HCA\\n    function getAccountOwner(address hca) external view returns (address);\\n}\\n\",\"keccak256\":\"0x16e469181d743f966d0a74812bc43e78ecd4109218721b85d543a4a45139d07c\",\"license\":\"MIT\"},\"project/src/migration/MigrationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/**\\n * @title MigrationErrors\\n * @dev Error definitions specific to migration operations\\n */\\n\\n/**\\n * @dev Thrown when attempting to migrate a subdomain whose parent has not been migrated\\n * @param name The DNS-encoded name being migrated\\n * @param offset The byte offset where the parent domain starts in the name\\n */\\nerror ParentNotMigrated(bytes name, uint256 offset);\\n\\n/**\\n * @dev Thrown when attempting to register a label that has an emancipated NFT in the old system but hasn't been migrated\\n * @param label The label that needs to be migrated first\\n */\\nerror LabelNotMigrated(string label);\\n\",\"keccak256\":\"0x3b103f7798c2b1c5b13f0c757bfb54d261b78e888f93175e99ae517be2b78661\",\"license\":\"MIT\"},\"project/src/migration/libraries/LockedNamesLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {\\n    INameWrapper,\\n    CANNOT_UNWRAP,\\n    CANNOT_BURN_FUSES,\\n    CANNOT_TRANSFER,\\n    CANNOT_SET_RESOLVER,\\n    CANNOT_SET_TTL,\\n    CANNOT_CREATE_SUBDOMAIN,\\n    IS_DOT_ETH,\\n    CAN_EXTEND_EXPIRY,\\n    PARENT_CANNOT_CONTROL\\n} from \\\"@ens/contracts/wrapper/INameWrapper.sol\\\";\\nimport {VerifiableFactory} from \\\"@ensdomains/verifiable-factory/VerifiableFactory.sol\\\";\\n\\nimport {\\n    IMigratedWrappedNameRegistry\\n} from \\\"../../registry/interfaces/IMigratedWrappedNameRegistry.sol\\\";\\nimport {RegistryRolesLib} from \\\"../../registry/libraries/RegistryRolesLib.sol\\\";\\n\\n/**\\n * @title LockedNamesLib\\n * @notice Library for common locked name migration operations\\n * @dev Contains shared logic for migrating locked names from ENS NameWrapper to v2 registries\\n */\\nlibrary LockedNamesLib {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice The fuses to burn during migration to prevent further changes\\n     * @dev Includes all transferable and modifiable fuses including the lock fuse\\n     */\\n    uint32 public constant FUSES_TO_BURN =\\n        CANNOT_UNWRAP |\\n            CANNOT_BURN_FUSES |\\n            CANNOT_TRANSFER |\\n            CANNOT_SET_RESOLVER |\\n            CANNOT_SET_TTL |\\n            CANNOT_CREATE_SUBDOMAIN;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    error NameNotLocked(uint256 tokenId);\\n\\n    error NameNotEmancipated(uint256 tokenId);\\n\\n    error NotDotEthName(uint256 tokenId);\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Library Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Deploys a new MigratedWrappedNameRegistry via VerifiableFactory\\n     * @dev The owner will have the specified roles on the deployed registry\\n     * @param factory The VerifiableFactory to use for deployment\\n     * @param implementation The implementation address for the proxy\\n     * @param owner The address that will own the deployed registry\\n     * @param ownerRoles The roles to grant to the owner\\n     * @param salt The salt for CREATE2 deployment\\n     * @param parentDnsEncodedName The DNS-encoded name of the parent domain\\n     * @return subregistry The address of the deployed registry\\n     */\\n    function deployMigratedRegistry(\\n        VerifiableFactory factory,\\n        address implementation,\\n        address owner,\\n        uint256 ownerRoles,\\n        uint256 salt,\\n        bytes memory parentDnsEncodedName\\n    ) internal returns (address subregistry) {\\n        bytes memory initData = abi.encodeCall(\\n            IMigratedWrappedNameRegistry.initialize,\\n            (parentDnsEncodedName, owner, ownerRoles, address(0))\\n        );\\n        subregistry = factory.deployProxy(implementation, salt, initData);\\n    }\\n\\n    /**\\n     * @notice Freezes a name by clearing its resolver if possible and burning all migration fuses\\n     * @dev Sets resolver to address(0) if CANNOT_SET_RESOLVER is not burned, then permanently freezes the name\\n     * @param nameWrapper The NameWrapper contract\\n     * @param tokenId The token ID to freeze\\n     * @param fuses The current fuses on the name\\n     */\\n    function freezeName(INameWrapper nameWrapper, uint256 tokenId, uint32 fuses) internal {\\n        // Clear resolver if CANNOT_SET_RESOLVER fuse is not set\\n        if ((fuses & CANNOT_SET_RESOLVER) == 0) {\\n            nameWrapper.setResolver(bytes32(tokenId), address(0));\\n        }\\n\\n        // Burn all migration fuses\\n        nameWrapper.setFuses(bytes32(tokenId), uint16(FUSES_TO_BURN));\\n    }\\n\\n    /**\\n     * @notice Validates that a name is properly locked for migration\\n     * @dev Checks that CANNOT_UNWRAP is set\\n     * @param fuses The current fuses on the name\\n     * @param tokenId The token ID for error reporting\\n     */\\n    function validateLockedName(uint32 fuses, uint256 tokenId) internal pure {\\n        if ((fuses & CANNOT_UNWRAP) == 0) {\\n            revert NameNotLocked(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates that a name is properly emancipated for migration\\n     * @dev Checks that PARENT_CANNOT_CONTROL is set (emancipated). Name may or may not be locked.\\n     * @param fuses The current fuses on the name\\n     * @param tokenId The token ID for error reporting\\n     */\\n    function validateEmancipatedName(uint32 fuses, uint256 tokenId) internal pure {\\n        if ((fuses & PARENT_CANNOT_CONTROL) == 0) {\\n            revert NameNotEmancipated(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates that a name is a .eth second-level domain\\n     * @dev Checks the IS_DOT_ETH fuse, which is only valid for .eth 2LDs\\n     * @param fuses The current fuses on the name\\n     * @param tokenId The token ID for error reporting\\n     */\\n    function validateIsDotEth2LD(uint32 fuses, uint256 tokenId) internal pure {\\n        if ((fuses & IS_DOT_ETH) == 0) {\\n            revert NotDotEthName(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Generates role bitmaps based on fuses\\n     * @dev Returns two bitmaps: tokenRoles for the name registration and subRegistryRoles for the registry owner\\n     * @param fuses The current fuses on the name\\n     * @return tokenRoles The role bitmap for the owner on their name in their parent registry.\\n     * @return subRegistryRoles The role bitmap for the owner on their name's subregistry.\\n     */\\n    function generateRoleBitmapsFromFuses(\\n        uint32 fuses\\n    ) internal pure returns (uint256 tokenRoles, uint256 subRegistryRoles) {\\n        // Check if fuses are permanently frozen\\n        bool fusesFrozen = (fuses & CANNOT_BURN_FUSES) != 0;\\n\\n        // Include renewal permissions if expiry can be extended\\n        if ((fuses & CAN_EXTEND_EXPIRY) != 0) {\\n            tokenRoles |= RegistryRolesLib.ROLE_RENEW;\\n            if (!fusesFrozen) {\\n                tokenRoles |= RegistryRolesLib.ROLE_RENEW_ADMIN;\\n            }\\n        }\\n\\n        // Conditionally add resolver roles\\n        if ((fuses & CANNOT_SET_RESOLVER) == 0) {\\n            tokenRoles |= RegistryRolesLib.ROLE_SET_RESOLVER;\\n            if (!fusesFrozen) {\\n                tokenRoles |= RegistryRolesLib.ROLE_SET_RESOLVER_ADMIN;\\n            }\\n        }\\n\\n        // Add transfer admin role if transfers are allowed\\n        if ((fuses & CANNOT_TRANSFER) == 0) {\\n            tokenRoles |= RegistryRolesLib.ROLE_CAN_TRANSFER_ADMIN;\\n        }\\n\\n        // Owner gets registrar permissions on subregistry only if subdomain creation is allowed\\n        if ((fuses & CANNOT_CREATE_SUBDOMAIN) == 0) {\\n            subRegistryRoles |= RegistryRolesLib.ROLE_REGISTRAR;\\n            if (!fusesFrozen) {\\n                subRegistryRoles |= RegistryRolesLib.ROLE_REGISTRAR_ADMIN;\\n            }\\n        }\\n\\n        // Add renewal roles to subregistry\\n        subRegistryRoles |= RegistryRolesLib.ROLE_RENEW;\\n        subRegistryRoles |= RegistryRolesLib.ROLE_RENEW_ADMIN;\\n    }\\n}\\n\",\"keccak256\":\"0xc5fcc8786064b5eae87bd0777e6f525023ce3d59622044ab0bc4541ce9ccbdb8\",\"license\":\"MIT\"},\"project/src/migration/types/MigrationTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/**\\n * @dev The data for v1 to v2 transfers of a name.\\n */\\nstruct TransferData {\\n    bytes dnsEncodedName;\\n    address owner;\\n    address subregistry;\\n    address resolver;\\n    uint256 roleBitmap;\\n    uint64 expires;\\n}\\n\\n/**\\n * @dev The data for v1 to v2 migrations of names.\\n */\\nstruct MigrationData {\\n    TransferData transferData;\\n    /**\\n     * @dev (Optional) Salt for CREATE2 deployments.\\n     */\\n    uint256 salt;\\n}\\n\",\"keccak256\":\"0xf1598366ebd0caad1936c18803951ac343cdf9086cf926da3ee4dd8fdaecaad4\",\"license\":\"MIT\"},\"project/src/registry/BaseRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Portions from OpenZeppelin Contracts (token/ERC1155/ERC1155.sol)\\npragma solidity >=0.8.13;\\n\\nimport {\\n    IERC1155MetadataURI\\n} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {ERC1155Singleton} from \\\"../erc1155/ERC1155Singleton.sol\\\";\\nimport {LibLabel} from \\\"../utils/LibLabel.sol\\\";\\n\\nimport {IRegistry} from \\\"./interfaces/IRegistry.sol\\\";\\nimport {IRegistryDatastore} from \\\"./interfaces/IRegistryDatastore.sol\\\";\\n\\nabstract contract BaseRegistry is IRegistry, ERC1155Singleton {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    IRegistryDatastore public immutable DATASTORE;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    error AccessDenied(uint256 tokenId, address owner, address caller);\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Modifiers\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    modifier onlyTokenOwner(uint256 tokenId) {\\n        address owner = ownerOf(tokenId);\\n        if (owner != _msgSender()) {\\n            revert AccessDenied(tokenId, owner, _msgSender());\\n        }\\n        _;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    constructor(IRegistryDatastore datastore_) {\\n        DATASTORE = datastore_;\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC1155Singleton, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            interfaceId == type(IRegistry).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Fetches the registry for a subdomain of the current registry.\\n    ///\\n    /// @param label The label to resolve.\\n    ///\\n    /// @return The address of the registry for this subdomain, or `address(0)` if none exists.\\n    function getSubregistry(string calldata label) external view virtual returns (IRegistry) {\\n        return DATASTORE.getEntry(this, LibLabel.labelToCanonicalId(label)).subregistry;\\n    }\\n\\n    /// @notice Fetches the resolver responsible for the specified label.\\n    ///\\n    /// @param label The label to fetch a resolver for.\\n    ///\\n    /// @return resolver The address of a resolver responsible for this name, or `address(0)` if none exists.\\n    function getResolver(string calldata label) external view virtual returns (address resolver) {\\n        return DATASTORE.getEntry(this, LibLabel.labelToCanonicalId(label)).resolver;\\n    }\\n}\\n\",\"keccak256\":\"0x74c86e2cd6c39a7ea7e4bb26eacd80cb5f02e901a65feb84f8427583d1afc5a7\",\"license\":\"MIT\"},\"project/src/registry/MetadataMixin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IRegistryMetadata} from \\\"./interfaces/IRegistryMetadata.sol\\\";\\n\\n/// @title MetadataMixin\\n///\\n/// @notice Mixin contract for Registry implementations to delegate metadata to an external provider\\n///\\n/// @dev Inherit this contract to add metadata functionality to Registry contracts\\nabstract contract MetadataMixin {\\n    /// @notice The metadata provider contract\\n    IRegistryMetadata public immutable METADATA_PROVIDER;\\n\\n    /// @notice Initializes the mixin with a metadata provider\\n    ///\\n    /// @param metadataProvider_ Address of the metadata provider contract\\n    constructor(IRegistryMetadata metadataProvider_) {\\n        METADATA_PROVIDER = metadataProvider_;\\n    }\\n\\n    /// @notice Returns the token URI for a given token ID\\n    ///\\n    /// @param tokenId The ID of the token to query\\n    ///\\n    /// @return URI string for the token metadata\\n    function _tokenURI(uint256 tokenId) internal view virtual returns (string memory) {\\n        if (address(METADATA_PROVIDER) == address(0)) {\\n            return \\\"\\\";\\n        }\\n        return METADATA_PROVIDER.tokenUri(tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0xca0e53f304cd527d5546ea7b8c3dac01f20fe18e49b9d2dce8a89ba0ac880202\",\"license\":\"MIT\"},\"project/src/registry/MigratedWrappedNameRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {NameCoder} from \\\"@ens/contracts/utils/NameCoder.sol\\\";\\nimport {INameWrapper, PARENT_CANNOT_CONTROL} from \\\"@ens/contracts/wrapper/INameWrapper.sol\\\";\\nimport {VerifiableFactory} from \\\"@ensdomains/verifiable-factory/VerifiableFactory.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {UnauthorizedCaller} from \\\"../CommonErrors.sol\\\";\\nimport {IHCAFactoryBasic} from \\\"../hca/interfaces/IHCAFactoryBasic.sol\\\";\\nimport {LockedNamesLib} from \\\"../migration/libraries/LockedNamesLib.sol\\\";\\nimport {ParentNotMigrated, LabelNotMigrated} from \\\"../migration/MigrationErrors.sol\\\";\\nimport {MigrationData} from \\\"../migration/types/MigrationTypes.sol\\\";\\n\\nimport {IMigratedWrappedNameRegistry} from \\\"./interfaces/IMigratedWrappedNameRegistry.sol\\\";\\nimport {IPermissionedRegistry} from \\\"./interfaces/IPermissionedRegistry.sol\\\";\\nimport {IRegistry} from \\\"./interfaces/IRegistry.sol\\\";\\nimport {IRegistryDatastore} from \\\"./interfaces/IRegistryDatastore.sol\\\";\\nimport {IRegistryMetadata} from \\\"./interfaces/IRegistryMetadata.sol\\\";\\nimport {IStandardRegistry} from \\\"./interfaces/IStandardRegistry.sol\\\";\\nimport {RegistryRolesLib} from \\\"./libraries/RegistryRolesLib.sol\\\";\\nimport {PermissionedRegistry} from \\\"./PermissionedRegistry.sol\\\";\\n\\n/**\\n * @title MigratedWrappedNameRegistry\\n * @dev A registry for migrated wrapped names that inherits from PermissionedRegistry and is upgradeable using the UUPS pattern.\\n * This contract provides resolver fallback to the universal resolver for names that haven't been migrated yet.\\n * It also handles subdomain migration by receiving NFT transfers from the NameWrapper.\\n */\\ncontract MigratedWrappedNameRegistry is\\n    Initializable,\\n    PermissionedRegistry,\\n    UUPSUpgradeable,\\n    IERC1155Receiver,\\n    IMigratedWrappedNameRegistry\\n{\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    // TODO: these clobbers ROLE_CAN_TRANSFER_ADMIN and should be in RegistryRolesLib\\n    uint256 internal constant _ROLE_UPGRADE = 1 << 20;\\n    uint256 internal constant _ROLE_UPGRADE_ADMIN = _ROLE_UPGRADE << 128;\\n\\n    INameWrapper public immutable NAME_WRAPPER;\\n\\n    VerifiableFactory public immutable FACTORY;\\n\\n    IPermissionedRegistry public immutable ETH_REGISTRY;\\n\\n    address public immutable FALLBACK_RESOLVER;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Storage\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    bytes public parentDnsEncodedName;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    error NoParentDomain();\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        INameWrapper nameWrapper,\\n        IPermissionedRegistry ethRegistry,\\n        VerifiableFactory factory,\\n        IRegistryDatastore datastore,\\n        IHCAFactoryBasic hcaFactory,\\n        IRegistryMetadata metadataProvider,\\n        address fallbackResolver\\n    ) PermissionedRegistry(datastore, hcaFactory, metadataProvider, _msgSender(), 0) {\\n        NAME_WRAPPER = nameWrapper;\\n        ETH_REGISTRY = ethRegistry;\\n        FACTORY = factory;\\n        FALLBACK_RESOLVER = fallbackResolver;\\n        // Prevents initialization on the implementation contract\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Initializes the MigratedWrappedNameRegistry contract.\\n     * @param parentDnsEncodedName_ The DNS-encoded name of the parent domain.\\n     * @param ownerAddress_ The address that will own this registry.\\n     * @param ownerRoles_ The roles to grant to the owner.\\n     * @param registrarAddress_ Optional address to grant ROLE_REGISTRAR permissions (typically for testing).\\n     */\\n    function initialize(\\n        bytes calldata parentDnsEncodedName_,\\n        address ownerAddress_,\\n        uint256 ownerRoles_,\\n        address registrarAddress_\\n    ) public initializer {\\n        // TODO: custom error\\n        require(ownerAddress_ != address(0), \\\"Owner cannot be zero address\\\");\\n\\n        // Set the parent domain for name resolution fallback\\n        parentDnsEncodedName = parentDnsEncodedName_;\\n\\n        // Configure owner with upgrade permissions and specified roles\\n        _grantRoles(\\n            ROOT_RESOURCE,\\n            _ROLE_UPGRADE | _ROLE_UPGRADE_ADMIN | ownerRoles_,\\n            ownerAddress_,\\n            false\\n        );\\n\\n        // Grant registrar role if specified (typically for testing)\\n        if (registrarAddress_ != address(0)) {\\n            _grantRoles(ROOT_RESOURCE, RegistryRolesLib.ROLE_REGISTRAR, registrarAddress_, false);\\n        }\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(IERC165, PermissionedRegistry) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Receiver).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    function onERC1155Received(\\n        address /*operator*/,\\n        address /*from*/,\\n        uint256 tokenId,\\n        uint256 /*amount*/,\\n        bytes calldata data\\n    ) external virtual returns (bytes4) {\\n        if (msg.sender != address(NAME_WRAPPER)) {\\n            revert UnauthorizedCaller(msg.sender);\\n        }\\n\\n        (MigrationData memory migrationData) = abi.decode(data, (MigrationData));\\n        MigrationData[] memory migrationDataArray = new MigrationData[](1);\\n        migrationDataArray[0] = migrationData;\\n\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = tokenId;\\n\\n        _migrateSubdomains(tokenIds, migrationDataArray);\\n\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address /*operator*/,\\n        address /*from*/,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata /*amounts*/,\\n        bytes calldata data\\n    ) external virtual returns (bytes4) {\\n        if (msg.sender != address(NAME_WRAPPER)) {\\n            revert UnauthorizedCaller(msg.sender);\\n        }\\n\\n        (MigrationData[] memory migrationDataArray) = abi.decode(data, (MigrationData[]));\\n\\n        _migrateSubdomains(tokenIds, migrationDataArray);\\n\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /// @inheritdoc PermissionedRegistry\\n    /// @dev Restore the latest resolver to `FALLBACK_RESOLVER` upon visiting migratable children.\\n    function getResolver(\\n        string calldata label\\n    ) public view override(PermissionedRegistry) returns (address) {\\n        bytes32 node = NameCoder.namehash(\\n            NameCoder.namehash(parentDnsEncodedName, 0),\\n            keccak256(bytes(label))\\n        );\\n        (address owner, uint32 fuses, ) = NAME_WRAPPER.getData(uint256(node));\\n        if (owner != address(this) && (fuses & PARENT_CANNOT_CONTROL) != 0) {\\n            return FALLBACK_RESOLVER;\\n        }\\n        return super.getResolver(label);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Internal Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Required override for UUPSUpgradeable - restricts upgrade permissions\\n     */\\n    function _authorizeUpgrade(address) internal override onlyRootRoles(_ROLE_UPGRADE) {}\\n\\n    function _migrateSubdomains(\\n        uint256[] memory tokenIds,\\n        MigrationData[] memory migrationDataArray\\n    ) internal {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            (, uint32 fuses, ) = NAME_WRAPPER.getData(tokenIds[i]);\\n\\n            // Ensure name meets migration requirements\\n            LockedNamesLib.validateEmancipatedName(fuses, tokenIds[i]);\\n\\n            // Ensure proper domain hierarchy for migration\\n            string memory label = _validateHierarchy(\\n                migrationDataArray[i].transferData.dnsEncodedName,\\n                0\\n            );\\n\\n            // Determine permissions from name configuration (allow subdomain renewal based on fuses)\\n            (uint256 tokenRoles, uint256 subRegistryRoles) = LockedNamesLib\\n                .generateRoleBitmapsFromFuses(fuses);\\n\\n            // Create dedicated registry for the migrated name\\n            address subregistry = LockedNamesLib.deployMigratedRegistry(\\n                FACTORY,\\n                ERC1967Utils.getImplementation(),\\n                migrationDataArray[i].transferData.owner,\\n                subRegistryRoles,\\n                migrationDataArray[i].salt,\\n                migrationDataArray[i].transferData.dnsEncodedName\\n            );\\n\\n            // Complete name registration in new registry\\n            _register(\\n                label,\\n                migrationDataArray[i].transferData.owner,\\n                IRegistry(subregistry),\\n                migrationDataArray[i].transferData.resolver,\\n                tokenRoles,\\n                migrationDataArray[i].transferData.expires\\n            );\\n\\n            // Finalize migration by freezing the name\\n            LockedNamesLib.freezeName(NAME_WRAPPER, tokenIds[i], fuses);\\n        }\\n    }\\n\\n    function _register(\\n        string memory label,\\n        address owner,\\n        IRegistry registry,\\n        address resolver,\\n        uint256 roleBitmap,\\n        uint64 expires\\n    ) internal virtual override returns (uint256 tokenId) {\\n        // Check if the label has an emancipated NFT in the old system\\n        // For .eth 2LDs, NameWrapper uses keccak256(label) as the token ID\\n        uint256 legacyTokenId = uint256(keccak256(bytes(label)));\\n        (, uint32 fuses, ) = NAME_WRAPPER.getData(legacyTokenId);\\n\\n        // If the name is emancipated (PARENT_CANNOT_CONTROL burned),\\n        // it must be migrated (owned by this registry)\\n        if ((fuses & PARENT_CANNOT_CONTROL) != 0) {\\n            if (NAME_WRAPPER.ownerOf(legacyTokenId) != address(this)) {\\n                revert LabelNotMigrated(label);\\n            }\\n        }\\n\\n        // Proceed with registration\\n        return super._register(label, owner, registry, resolver, roleBitmap, expires);\\n    }\\n\\n    function _validateHierarchy(\\n        bytes memory dnsEncodedName,\\n        uint256 offset\\n    ) internal view returns (string memory label) {\\n        // Extract the current label (leftmost, at offset 0)\\n        uint256 parentOffset;\\n        (label, parentOffset) = NameCoder.extractLabel(dnsEncodedName, offset);\\n\\n        // Check if there's no parent (trying to migrate TLD)\\n        if (dnsEncodedName[parentOffset] == 0) {\\n            revert NoParentDomain();\\n        }\\n\\n        // Extract the parent label\\n        (string memory parentLabel, uint256 grandparentOffset) = NameCoder.extractLabel(\\n            dnsEncodedName,\\n            parentOffset\\n        );\\n\\n        // Check if this is a 2LD (parent is \\\"eth\\\" and no grandparent)\\n        if (\\n            keccak256(bytes(parentLabel)) == keccak256(bytes(\\\"eth\\\")) &&\\n            dnsEncodedName[grandparentOffset] == 0\\n        ) {\\n            // For 2LD: Check that label is NOT registered in ethRegistry\\n            IRegistry subregistry = ETH_REGISTRY.getSubregistry(label);\\n            if (address(subregistry) != address(0)) {\\n                revert IStandardRegistry.NameAlreadyRegistered(label);\\n            }\\n        } else {\\n            // For 3LD+: Check that parent is wrapped and owned by this contract\\n            bytes32 parentNode = NameCoder.namehash(dnsEncodedName, parentOffset);\\n            if (\\n                !NAME_WRAPPER.isWrapped(parentNode) ||\\n                NAME_WRAPPER.ownerOf(uint256(parentNode)) != address(this)\\n            ) {\\n                revert ParentNotMigrated(dnsEncodedName, parentOffset);\\n            }\\n\\n            // Also check that the current label is NOT already registered in this registry\\n            IRegistry subregistry = this.getSubregistry(label);\\n            if (address(subregistry) != address(0)) {\\n                revert IStandardRegistry.NameAlreadyRegistered(label);\\n            }\\n        }\\n\\n        return label;\\n    }\\n}\\n\",\"keccak256\":\"0x84609b2c4144e4854ca2e7272c4eb19359a9c55c28c004449cc2b83d19cf23e8\",\"license\":\"MIT\"},\"project/src/registry/PermissionedRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {EnhancedAccessControl} from \\\"../access-control/EnhancedAccessControl.sol\\\";\\nimport {IEnhancedAccessControl} from \\\"../access-control/interfaces/IEnhancedAccessControl.sol\\\";\\nimport {EACBaseRolesLib} from \\\"../access-control/libraries/EACBaseRolesLib.sol\\\";\\nimport {ERC1155Singleton} from \\\"../erc1155/ERC1155Singleton.sol\\\";\\nimport {IERC1155Singleton} from \\\"../erc1155/interfaces/IERC1155Singleton.sol\\\";\\nimport {HCAEquivalence} from \\\"../hca/HCAEquivalence.sol\\\";\\nimport {IHCAFactoryBasic} from \\\"../hca/interfaces/IHCAFactoryBasic.sol\\\";\\nimport {LibLabel} from \\\"../utils/LibLabel.sol\\\";\\n\\nimport {BaseRegistry} from \\\"./BaseRegistry.sol\\\";\\nimport {IPermissionedRegistry} from \\\"./interfaces/IPermissionedRegistry.sol\\\";\\nimport {IRegistry} from \\\"./interfaces/IRegistry.sol\\\";\\nimport {IRegistryDatastore} from \\\"./interfaces/IRegistryDatastore.sol\\\";\\nimport {IRegistryMetadata} from \\\"./interfaces/IRegistryMetadata.sol\\\";\\nimport {IStandardRegistry} from \\\"./interfaces/IStandardRegistry.sol\\\";\\nimport {RegistryRolesLib} from \\\"./libraries/RegistryRolesLib.sol\\\";\\nimport {MetadataMixin} from \\\"./MetadataMixin.sol\\\";\\n\\ncontract PermissionedRegistry is\\n    BaseRegistry,\\n    EnhancedAccessControl,\\n    IPermissionedRegistry,\\n    MetadataMixin\\n{\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        IRegistryDatastore datastore,\\n        IHCAFactoryBasic hcaFactory,\\n        IRegistryMetadata metadata,\\n        address ownerAddress,\\n        uint256 ownerRoles\\n    ) BaseRegistry(datastore) HCAEquivalence(hcaFactory) MetadataMixin(metadata) {\\n        _grantRoles(ROOT_RESOURCE, ownerRoles, ownerAddress, false);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(BaseRegistry, EnhancedAccessControl, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IPermissionedRegistry).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    function setSubregistry(uint256 anyId, IRegistry registry) external override {\\n        (uint256 tokenId, IRegistryDatastore.Entry memory entry) = _checkExpiryAndTokenRoles(\\n            anyId,\\n            RegistryRolesLib.ROLE_SET_SUBREGISTRY\\n        );\\n        entry.subregistry = registry;\\n        DATASTORE.setEntry(tokenId, entry);\\n        emit SubregistryUpdated(tokenId, registry);\\n    }\\n\\n    function setResolver(uint256 anyId, address resolver) external override {\\n        (uint256 tokenId, IRegistryDatastore.Entry memory entry) = _checkExpiryAndTokenRoles(\\n            anyId,\\n            RegistryRolesLib.ROLE_SET_RESOLVER\\n        );\\n        entry.resolver = resolver;\\n        DATASTORE.setEntry(tokenId, entry);\\n        emit ResolverUpdated(tokenId, resolver);\\n    }\\n\\n    /// @inheritdoc IStandardRegistry\\n    function register(\\n        string calldata label,\\n        address owner,\\n        IRegistry registry,\\n        address resolver,\\n        uint256 roleBitmap,\\n        uint64 expires\\n    )\\n        public\\n        virtual\\n        override\\n        onlyRootRoles(RegistryRolesLib.ROLE_REGISTRAR)\\n        returns (uint256 tokenId)\\n    {\\n        return _register(label, owner, registry, resolver, roleBitmap, expires);\\n    }\\n\\n    /// @inheritdoc IStandardRegistry\\n    function renew(uint256 anyId, uint64 newExpiry) public override {\\n        (uint256 tokenId, IRegistryDatastore.Entry memory entry) = _checkExpiryAndTokenRoles(\\n            anyId,\\n            RegistryRolesLib.ROLE_RENEW\\n        );\\n        if (newExpiry < entry.expiry) {\\n            revert CannotReduceExpiration(entry.expiry, newExpiry);\\n        }\\n        entry.expiry = newExpiry;\\n        DATASTORE.setEntry(tokenId, entry);\\n        emit ExpiryUpdated(tokenId, newExpiry, _msgSender());\\n    }\\n\\n    /// @inheritdoc IEnhancedAccessControl\\n    function grantRoles(\\n        uint256 anyId,\\n        uint256 roleBitmap,\\n        address account\\n    ) public override(EnhancedAccessControl, IEnhancedAccessControl) returns (bool) {\\n        return super.grantRoles(getResource(anyId), roleBitmap, account);\\n    }\\n\\n    /// @inheritdoc IEnhancedAccessControl\\n    function revokeRoles(\\n        uint256 anyId,\\n        uint256 roleBitmap,\\n        address account\\n    ) public override(EnhancedAccessControl, IEnhancedAccessControl) returns (bool) {\\n        return super.revokeRoles(getResource(anyId), roleBitmap, account);\\n    }\\n\\n    /// @inheritdoc IRegistry\\n    function getSubregistry(\\n        string calldata label\\n    ) public view virtual override(BaseRegistry, IRegistry) returns (IRegistry) {\\n        IRegistryDatastore.Entry memory entry = getEntry(LibLabel.labelToCanonicalId(label));\\n        return _isExpired(entry.expiry) ? IRegistry(address(0)) : entry.subregistry;\\n    }\\n\\n    /// @inheritdoc IRegistry\\n    function getResolver(\\n        string calldata label\\n    ) public view virtual override(BaseRegistry, IRegistry) returns (address) {\\n        IRegistryDatastore.Entry memory entry = getEntry(LibLabel.labelToCanonicalId(label));\\n        return _isExpired(entry.expiry) ? address(0) : entry.resolver;\\n    }\\n\\n    /// @inheritdoc ERC1155Singleton\\n    function uri(uint256 tokenId) public view override returns (string memory) {\\n        return _tokenURI(tokenId);\\n    }\\n\\n    /// @inheritdoc IPermissionedRegistry\\n    function getEntry(uint256 anyId) public view returns (IRegistryDatastore.Entry memory) {\\n        return DATASTORE.getEntry(this, anyId);\\n    }\\n\\n    /// @inheritdoc IStandardRegistry\\n    function getExpiry(uint256 anyId) public view returns (uint64) {\\n        return getEntry(anyId).expiry;\\n    }\\n\\n    /// @inheritdoc IPermissionedRegistry\\n    function getResource(uint256 anyId) public view returns (uint256) {\\n        return _constructResource(anyId, getEntry(anyId));\\n    }\\n\\n    /// @inheritdoc IPermissionedRegistry\\n    function getTokenId(uint256 anyId) public view returns (uint256) {\\n        return _constructTokenId(anyId, getEntry(anyId));\\n    }\\n\\n    /// @inheritdoc IPermissionedRegistry\\n    function getNameData(\\n        string memory label\\n    ) public view returns (uint256 tokenId, IRegistryDatastore.Entry memory entry) {\\n        uint256 anyId = LibLabel.labelToCanonicalId(label);\\n        entry = getEntry(anyId);\\n        tokenId = _constructTokenId(anyId, entry);\\n    }\\n\\n    /// @inheritdoc IPermissionedRegistry\\n    function latestOwnerOf(uint256 tokenId) public view virtual returns (address) {\\n        return super.ownerOf(tokenId);\\n    }\\n\\n    /// @inheritdoc IERC1155Singleton\\n    function ownerOf(\\n        uint256 tokenId\\n    ) public view virtual override(ERC1155Singleton, IERC1155Singleton) returns (address) {\\n        IRegistryDatastore.Entry memory entry = getEntry(tokenId);\\n        return\\n            tokenId != _constructTokenId(tokenId, entry) || _isExpired(entry.expiry)\\n                ? address(0)\\n                : super.ownerOf(tokenId);\\n    }\\n\\n    // Enhanced access control methods adapted for token-based resources\\n\\n    function roles(\\n        uint256 anyId,\\n        address account\\n    ) public view override(EnhancedAccessControl, IEnhancedAccessControl) returns (uint256) {\\n        return super.roles(getResource(anyId), account);\\n    }\\n\\n    function roleCount(\\n        uint256 anyId\\n    ) public view override(EnhancedAccessControl, IEnhancedAccessControl) returns (uint256) {\\n        return super.roleCount(getResource(anyId));\\n    }\\n\\n    function hasRoles(\\n        uint256 anyId,\\n        uint256 rolesBitmap,\\n        address account\\n    ) public view override(EnhancedAccessControl, IEnhancedAccessControl) returns (bool) {\\n        return super.hasRoles(getResource(anyId), rolesBitmap, account);\\n    }\\n\\n    function hasAssignees(\\n        uint256 anyId,\\n        uint256 roleBitmap\\n    ) public view override(EnhancedAccessControl, IEnhancedAccessControl) returns (bool) {\\n        return super.hasAssignees(getResource(anyId), roleBitmap);\\n    }\\n\\n    function getAssigneeCount(\\n        uint256 anyId,\\n        uint256 roleBitmap\\n    )\\n        public\\n        view\\n        override(EnhancedAccessControl, IEnhancedAccessControl)\\n        returns (uint256 counts, uint256 mask)\\n    {\\n        return super.getAssigneeCount(getResource(anyId), roleBitmap);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Internal Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Internal register method that takes string memory and performs the actual registration logic.\\n     * @param label The label to register.\\n     * @param owner The owner of the registered name.\\n     * @param registry The registry to use for the name.\\n     * @param resolver The resolver to set for the name.\\n     * @param roleBitmap The roles to grant to the owner.\\n     * @param expires The expiration time of the name.\\n     * @return tokenId The token ID of the registered name.\\n     */\\n    function _register(\\n        string memory label,\\n        address owner,\\n        IRegistry registry,\\n        address resolver,\\n        uint256 roleBitmap,\\n        uint64 expires\\n    ) internal virtual returns (uint256 tokenId) {\\n        tokenId = LibLabel.labelToCanonicalId(label);\\n        IRegistryDatastore.Entry memory entry = getEntry(tokenId);\\n        if (!_isExpired(entry.expiry)) {\\n            revert NameAlreadyRegistered(label);\\n        }\\n        if (_isExpired(expires)) {\\n            revert CannotSetPastExpiration(expires);\\n        }\\n        tokenId = _constructTokenId(tokenId, entry);\\n        address prevOwner = super.ownerOf(tokenId);\\n        if (prevOwner != address(0)) {\\n            _burn(prevOwner, tokenId, 1);\\n            ++entry.eacVersionId;\\n            ++entry.tokenVersionId;\\n            tokenId = _constructTokenId(tokenId, entry);\\n        }\\n        entry.expiry = expires;\\n        entry.subregistry = registry;\\n        entry.resolver = resolver;\\n        DATASTORE.setEntry(tokenId, entry);\\n\\n        // emit NameRegistered before mint so we can determine this is a registry (in an indexer)\\n        emit NameRegistered(tokenId, label, expires, _msgSender());\\n\\n        _mint(owner, tokenId, 1, \\\"\\\");\\n        _grantRoles(_constructResource(tokenId, entry), roleBitmap, owner, false);\\n\\n        emit SubregistryUpdated(tokenId, registry);\\n        emit ResolverUpdated(tokenId, resolver);\\n    }\\n\\n    /**\\n     * @dev Override the base registry _update function to transfer the roles to the new owner when the token is transferred.\\n     */\\n    function _update(\\n        address from,\\n        address to,\\n        uint256[] memory tokenIds,\\n        uint256[] memory values\\n    ) internal virtual override {\\n        bool externalTransfer = to != address(0) && from != address(0);\\n        if (externalTransfer) {\\n            // Check ROLE_CAN_TRANSFER for actual transfers only\\n            // Skip check for mints (from == address(0)) and burns (to == address(0))\\n            for (uint256 i; i < tokenIds.length; ++i) {\\n                if (!hasRoles(tokenIds[i], RegistryRolesLib.ROLE_CAN_TRANSFER_ADMIN, from)) {\\n                    revert TransferDisallowed(tokenIds[i], from);\\n                }\\n            }\\n        }\\n        super._update(from, to, tokenIds, values);\\n        if (externalTransfer) {\\n            for (uint256 i; i < tokenIds.length; ++i) {\\n                _transferRoles(getResource(tokenIds[i]), from, to, false);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Override the base registry _onRolesGranted function to regenerate the token when the roles are granted.\\n     */\\n    function _onRolesGranted(\\n        uint256 resource,\\n        address /*account*/,\\n        uint256 /*oldRoles*/,\\n        uint256 /*newRoles*/,\\n        uint256 /*roleBitmap*/\\n    ) internal virtual override {\\n        _regenerateToken(resource);\\n    }\\n\\n    /**\\n     * @dev Override the base registry _onRolesRevoked function to regenerate the token when the roles are revoked.\\n     */\\n    function _onRolesRevoked(\\n        uint256 resource,\\n        address /*account*/,\\n        uint256 /*oldRoles*/,\\n        uint256 /*newRoles*/,\\n        uint256 /*roleBitmap*/\\n    ) internal virtual override {\\n        _regenerateToken(resource);\\n    }\\n\\n    /// @dev Bump `tokenVersionId` via burn+mint if token is not expired.\\n    function _regenerateToken(uint256 anyId) internal {\\n        IRegistryDatastore.Entry memory entry = getEntry(anyId);\\n        if (!_isExpired(entry.expiry)) {\\n            uint256 tokenId = _constructTokenId(anyId, entry);\\n            address owner = super.ownerOf(tokenId); // skip expiry check\\n            if (owner != address(0)) {\\n                _burn(owner, tokenId, 1);\\n                ++entry.tokenVersionId;\\n                DATASTORE.setEntry(tokenId, entry);\\n                uint256 newTokenId = _constructTokenId(tokenId, entry);\\n                _mint(owner, newTokenId, 1, \\\"\\\");\\n                emit TokenRegenerated(tokenId, newTokenId, _constructResource(tokenId, entry));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Override to prevent admin roles from being granted in the registry.\\n     *\\n     * In the registry context, admin roles are only assigned during name registration\\n     * to maintain controlled permission management. This ensures that role delegation\\n     * follows the intended security model where admin privileges are granted at\\n     * registration time and cannot be arbitrarily granted afterward.\\n     *\\n     * @param resource The resource to get settable roles for.\\n     * @param account The account to get settable roles for.\\n     * @return The settable roles (regular roles only, not admin roles).\\n     */\\n    function _getSettableRoles(\\n        uint256 resource,\\n        address account\\n    ) internal view virtual override returns (uint256) {\\n        uint256 allRoles = super.roles(resource, account) | super.roles(ROOT_RESOURCE, account);\\n        uint256 adminRoleBitmap = allRoles & EACBaseRolesLib.ADMIN_ROLES;\\n        return adminRoleBitmap >> 128;\\n    }\\n\\n    /// @dev Assert token is not expired and caller has necessary roles.\\n    function _checkExpiryAndTokenRoles(\\n        uint256 anyId,\\n        uint256 roleBitmap\\n    ) internal view returns (uint256 tokenId, IRegistryDatastore.Entry memory entry) {\\n        entry = getEntry(anyId);\\n        tokenId = _constructTokenId(anyId, entry);\\n        if (_isExpired(entry.expiry)) {\\n            revert NameExpired(tokenId);\\n        }\\n        _checkRoles(_constructResource(anyId, entry), roleBitmap, _msgSender());\\n    }\\n\\n    /// @dev Internal logic for expired status.\\n    ///      Only use of `block.timestamp`.\\n    function _isExpired(uint64 expires) internal view returns (bool) {\\n        return block.timestamp >= expires;\\n    }\\n\\n    /// @dev Create `resource` from parts.\\n    ///      Returns next resource if token is expired.\\n    function _constructResource(\\n        uint256 anyId,\\n        IRegistryDatastore.Entry memory entry\\n    ) internal view returns (uint256) {\\n        return\\n            LibLabel.getCanonicalId(anyId) |\\n            (_isExpired(entry.expiry) ? entry.eacVersionId + 1 : entry.eacVersionId);\\n    }\\n\\n    /// @dev Create `tokenId` from parts.\\n    function _constructTokenId(\\n        uint256 anyId,\\n        IRegistryDatastore.Entry memory entry\\n    ) internal pure returns (uint256) {\\n        return LibLabel.getCanonicalId(anyId) | entry.tokenVersionId;\\n    }\\n}\\n\",\"keccak256\":\"0xee075520334865d11d69bb6166722767a5644973b8d2d1d2c74aa71579375c60\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IMigratedWrappedNameRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/**\\n * @dev Interface for MigratedWrappedNameRegistry initialization and core functions\\n */\\ninterface IMigratedWrappedNameRegistry {\\n    function initialize(\\n        bytes calldata parentDnsEncodedName_,\\n        address ownerAddress_,\\n        uint256 ownerRoles_,\\n        address registrarAddress_\\n    ) external;\\n}\\n\",\"keccak256\":\"0x7744d38744c621d7413b1d82dede1da3f0d5a9d615c90916910ea3e83347528c\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IPermissionedRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IEnhancedAccessControl} from \\\"../../access-control/interfaces/IEnhancedAccessControl.sol\\\";\\n\\nimport {IRegistryDatastore} from \\\"./IRegistryDatastore.sol\\\";\\nimport {IStandardRegistry} from \\\"./IStandardRegistry.sol\\\";\\n\\ninterface IPermissionedRegistry is IStandardRegistry, IEnhancedAccessControl {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Get the latest owner of a token.\\n    ///         If the token was burned, returns null.\\n    /// @param tokenId The token ID to query.\\n    /// @return The latest owner address.\\n    function latestOwnerOf(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Fetches the name data for a label.\\n     * @param label The label to fetch the name data for.\\n     * @return tokenId The token ID of the name.\\n     * @return entry The entry data for the name.\\n     */\\n    function getNameData(\\n        string calldata label\\n    ) external view returns (uint256 tokenId, IRegistryDatastore.Entry memory entry);\\n\\n    /// @notice Get datastore `Entry` from `anyId`.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @return The datastore entry.\\n    function getEntry(uint256 anyId) external view returns (IRegistryDatastore.Entry memory);\\n\\n    /// @notice Get `resource` from `anyId`.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @return The resource.\\n    function getResource(uint256 anyId) external view returns (uint256);\\n\\n    /// @notice Get `tokenId` from `anyId`.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @return The token ID.\\n    function getTokenId(uint256 anyId) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x500ece8944bdd297d440377f47440460326490bf69f91c88c2e75955bbc59ef5\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155Singleton} from \\\"../../erc1155/interfaces/IERC1155Singleton.sol\\\";\\n\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\ninterface IRegistry is IERC1155Singleton {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Events\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev SHOULD be emitted when a new label is registered\\n    event NameRegistered(\\n        uint256 indexed tokenId,\\n        string label,\\n        uint64 expiry,\\n        address registeredBy\\n    );\\n\\n    /// @notice Expiry was changed.\\n    /// @dev Error selector: `0x`\\n    event ExpiryUpdated(uint256 indexed tokenId, uint64 newExpiry, address changedBy);\\n\\n    /// @notice Subregistry was changed.\\n    event SubregistryUpdated(uint256 indexed tokenId, IRegistry subregistry);\\n\\n    /// @notice Resolver was changed.\\n    event ResolverUpdated(uint256 indexed tokenId, address resolver);\\n\\n    /// @notice Token was regenerated with a new token ID.\\n    ///         This occurs when roles are granted or revoked to maintain ERC1155 compliance.\\n    event TokenRegenerated(\\n        uint256 indexed oldTokenId,\\n        uint256 indexed newTokenId,\\n        uint256 resource\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Fetches the registry for a subdomain.\\n     * @param label The label to resolve.\\n     * @return The address of the registry for this subdomain, or `address(0)` if none exists.\\n     */\\n    function getSubregistry(string calldata label) external view returns (IRegistry);\\n\\n    /**\\n     * @dev Fetches the resolver responsible for the specified label.\\n     * @param label The label to fetch a resolver for.\\n     * @return resolver The address of a resolver responsible for this name, or `address(0)` if none exists.\\n     */\\n    function getResolver(string calldata label) external view returns (address);\\n}\\n\",\"keccak256\":\"0xc3c7b964bbaadd35412ce44163ab335f802ac9b5f19d72b0fbb64bf772f63634\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IRegistryDatastore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\n/**\\n * @dev Interface for the ENSv2 registry datastore, which stores subregistry and resolver addresses and other data\\n *      for all names, keyed by registry address and label hash.\\n */\\ninterface IRegistryDatastore {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Types\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    struct Entry {\\n        uint64 expiry;\\n        uint32 tokenVersionId;\\n        IRegistry subregistry;\\n        uint32 eacVersionId;\\n        address resolver;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    function setEntry(uint256 anyId, Entry calldata entry) external;\\n\\n    function getEntry(IRegistry registry, uint256 anyId) external view returns (Entry calldata);\\n}\\n\",\"keccak256\":\"0xb253b791894ae3bffc3c3a6c6c485ee7adab7a597a6bdfdcd7275e7064125024\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IRegistryMetadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/**\\n * @dev Interface for providing metadata URIs for ENSv2 registry contracts.\\n */\\ninterface IRegistryMetadata {\\n    /**\\n     * @dev Fetches the token URI for a token ID.\\n     * @param tokenId The ID of the token to fetch a URI for.\\n     * @return The token URI for the token.\\n     */\\n    function tokenUri(uint256 tokenId) external view returns (string calldata);\\n}\\n\",\"keccak256\":\"0x8aa210895336c2394a274f576db7702a0e9fc3bbfca02db47cdb588b9198e54c\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IStandardRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\n/**\\n * @title IStandardRegistry\\n * @dev Interface for the a standard registry.\\n */\\ninterface IStandardRegistry is IRegistry {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Error emitted when a name is already registered.\\n     */\\n    error NameAlreadyRegistered(string label);\\n\\n    /**\\n     * @dev Error emitted when a name has expired.\\n     */\\n    error NameExpired(uint256 tokenId);\\n\\n    /**\\n     * @dev Error emitted when a name cannot be reduced in expiration.\\n     */\\n    error CannotReduceExpiration(uint64 oldExpiration, uint64 newExpiration);\\n\\n    /**\\n     * @dev Error emitted when a name cannot be set to a past expiration.\\n     */\\n    error CannotSetPastExpiration(uint64 expiry);\\n\\n    /**\\n     * @dev Error emitted when a transfer is not allowed due to missing transfer admin role.\\n     */\\n    error TransferDisallowed(uint256 tokenId, address from);\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Registers a new name.\\n     * @param label The label to register.\\n     * @param owner The address of the owner of the name.\\n     * @param registry The registry to set as the name.\\n     * @param resolver The resolver to set for the name.\\n     * @param roleBitmap The role bitmap to set for the name.\\n     * @param expires The expiration date of the name.\\n     */\\n    function register(\\n        string calldata label,\\n        address owner,\\n        IRegistry registry,\\n        address resolver,\\n        uint256 roleBitmap,\\n        uint64 expires\\n    ) external returns (uint256 tokenId);\\n\\n    /// @notice Renew a subdomain.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @param newExpiry The new expiration.\\n    function renew(uint256 anyId, uint64 newExpiry) external;\\n\\n    /// @notice Change registry of name.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @param registry The new registry.\\n    function setSubregistry(uint256 anyId, IRegistry registry) external;\\n\\n    /// @notice Change resolver of name.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @param resolver The new resolver.\\n    function setResolver(uint256 anyId, address resolver) external;\\n\\n    /// @notice Get expiry of name.\\n    /// @param anyId The labelhash, token ID, or resource.\\n    /// @return The expiry for name.\\n    function getExpiry(uint256 anyId) external view returns (uint64);\\n}\\n\",\"keccak256\":\"0x54471ee6437cdce72821f1cd54759aac90575e1fc4ddbd936a828717b05c3c06\",\"license\":\"MIT\"},\"project/src/registry/libraries/RegistryRolesLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nlibrary RegistryRolesLib {\\n    uint256 internal constant ROLE_REGISTRAR = 1 << 0;\\n    uint256 internal constant ROLE_REGISTRAR_ADMIN = ROLE_REGISTRAR << 128;\\n\\n    uint256 internal constant ROLE_RENEW = 1 << 4;\\n    uint256 internal constant ROLE_RENEW_ADMIN = ROLE_RENEW << 128;\\n\\n    uint256 internal constant ROLE_SET_SUBREGISTRY = 1 << 8;\\n    uint256 internal constant ROLE_SET_SUBREGISTRY_ADMIN = ROLE_SET_SUBREGISTRY << 128;\\n\\n    uint256 internal constant ROLE_SET_RESOLVER = 1 << 12;\\n    uint256 internal constant ROLE_SET_RESOLVER_ADMIN = ROLE_SET_RESOLVER << 128;\\n\\n    uint256 internal constant ROLE_CAN_TRANSFER_ADMIN = (1 << 16) << 128;\\n}\\n\",\"keccak256\":\"0xd834b810c6faa5b5ecb9fd8421976e61f587815ff062c88c48048ed28d8f2a19\",\"license\":\"MIT\"},\"project/src/utils/LibLabel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nlibrary LibLabel {\\n    /// @dev Convert a label to canonical id.\\n    ///\\n    /// @param label The label to convert.\\n    ///\\n    /// @return The canonical id corresponding to this label.\\n    function labelToCanonicalId(string memory label) internal pure returns (uint256) {\\n        return getCanonicalId(uint256(keccak256(bytes(label))));\\n    }\\n\\n    /// @dev Get the canonical id of a token id or canonical id.\\n    ///\\n    /// @param id The token id or canonical id to convert to its canonical id version.\\n    ///\\n    /// @return The canonical id.\\n    function getCanonicalId(uint256 id) internal pure returns (uint256) {\\n        return id ^ uint32(id);\\n    }\\n}\\n\",\"keccak256\":\"0x2e5ba544a5883665568b8068f263bfed14c2c4aa7a4a8bf3779192437a5c889c\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 25257,
        "contract": "project/src/registry/MigratedWrappedNameRegistry.sol:MigratedWrappedNameRegistry",
        "label": "_owners",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 25263,
        "contract": "project/src/registry/MigratedWrappedNameRegistry.sol:MigratedWrappedNameRegistry",
        "label": "_operatorApprovals",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 23872,
        "contract": "project/src/registry/MigratedWrappedNameRegistry.sol:MigratedWrappedNameRegistry",
        "label": "_roles",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 23877,
        "contract": "project/src/registry/MigratedWrappedNameRegistry.sol:MigratedWrappedNameRegistry",
        "label": "_roleCount",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 27282,
        "contract": "project/src/registry/MigratedWrappedNameRegistry.sol:MigratedWrappedNameRegistry",
        "label": "parentDnsEncodedName",
        "offset": 0,
        "slot": "4",
        "type": "t_bytes_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  },
  "userdoc": {
    "events": {
      "ExpiryUpdated(uint256,uint64,address)": {
        "notice": "Expiry was changed."
      },
      "ResolverUpdated(uint256,address)": {
        "notice": "Resolver was changed."
      },
      "SubregistryUpdated(uint256,address)": {
        "notice": "Subregistry was changed."
      },
      "TokenRegenerated(uint256,uint256,uint256)": {
        "notice": "Token was regenerated with a new token ID.         This occurs when roles are granted or revoked to maintain ERC1155 compliance."
      }
    },
    "kind": "user",
    "methods": {
      "HCA_FACTORY()": {
        "notice": "The HCA factory contract"
      },
      "METADATA_PROVIDER()": {
        "notice": "The metadata provider contract"
      },
      "ROOT_RESOURCE()": {
        "notice": "The `ROOT_RESOURCE`."
      },
      "getEntry(uint256)": {
        "notice": "Get datastore `Entry` from `anyId`."
      },
      "getExpiry(uint256)": {
        "notice": "Get expiry of name."
      },
      "getResource(uint256)": {
        "notice": "Get `resource` from `anyId`."
      },
      "getTokenId(uint256)": {
        "notice": "Get `tokenId` from `anyId`."
      },
      "latestOwnerOf(uint256)": {
        "notice": "Get the latest owner of a token.         If the token was burned, returns null."
      },
      "renew(uint256,uint64)": {
        "notice": "Renew a subdomain."
      },
      "setResolver(uint256,address)": {
        "notice": "Change resolver of name."
      },
      "setSubregistry(uint256,address)": {
        "notice": "Change registry of name."
      }
    },
    "version": 1
  },
  "argsData": "0x000000000000000000000000b7278a61aa25c888815afc32ad3cc52ff24fe57500000000000000000000000084ea74d481ee0a5332c457a4d796187f6ba67feb00000000000000000000000082e01223d51eb87e16a03e24687edf0f294da6f1000000000000000000000000a513e6e4b8f2a923d98304ec87f64353c4d5c8530000000000000000000000002279b7a0a67db372996a5fab50d91eaa73d2ebe60000000000000000000000008a791620dd6260079bf849dc5567adc3f2fdc3180000000000000000000000005fc8d32690cc91d4c39d9d3abcbd16989f875707",
  "transaction": {
    "hash": "0x24b7237138e56e2a2ba8b772c3ba05fc0a679bbdd754388833c968fadedafe4e",
    "nonce": "0x37",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x0448d368d12ce3251cfff0cc14c9d33db36b4046d410c48c5b99d703ae43e252",
    "blockNumber": "0x42",
    "transactionIndex": "0x0"
  }
}
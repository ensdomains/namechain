{
  "address": "0xb0d4afd8879ed9f52b28595d31b441d079b2ca07",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IRegistry",
          "name": "root",
          "type": "address"
        },
        {
          "internalType": "contract IGatewayProvider",
          "name": "batchGatewayProvider",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ens",
          "type": "string"
        }
      ],
      "name": "DNSEncodingFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EmptyAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "status",
          "type": "uint16"
        },
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "HttpError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBatchGatewayResponse",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "string[]",
          "name": "urls",
          "type": "string[]"
        },
        {
          "internalType": "bytes",
          "name": "callData",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "callbackFunction",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "OffchainLookup",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "errorData",
          "type": "bytes"
        }
      ],
      "name": "ResolverError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        }
      ],
      "name": "ResolverNotContract",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "ResolverNotFound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "primary",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "primaryAddress",
          "type": "bytes"
        }
      ],
      "name": "ReverseAddressMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        }
      ],
      "name": "UnsupportedResolverProfile",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ROOT_REGISTRY",
      "outputs": [
        {
          "internalType": "contract IRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "batchGatewayProvider",
      "outputs": [
        {
          "internalType": "contract IGatewayProvider",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "name": "ccipBatch",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipBatchCallback",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipReadCallback",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "findRegistries",
      "outputs": [
        {
          "internalType": "contract IRegistry[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "findResolver",
      "outputs": [
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "requireResolver",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "name",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "offset",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "node",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "resolver",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "extended",
              "type": "bool"
            }
          ],
          "internalType": "struct AbstractUniversalResolver.ResolverInfo",
          "name": "info",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveBatchCallback",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveDirectCallback",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "resolveDirectCallbackError",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "string[]",
          "name": "gateways",
          "type": "string[]"
        }
      ],
      "name": "resolveWithGateways",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "string[]",
          "name": "gateways",
          "type": "string[]"
        }
      ],
      "name": "resolveWithResolver",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "lookupAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "coinType",
          "type": "uint256"
        }
      ],
      "name": "reverse",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "reverseAddressCallback",
      "outputs": [
        {
          "internalType": "string",
          "name": "primary",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "reverseResolver",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "reverseNameCallback",
      "outputs": [
        {
          "internalType": "string",
          "name": "primary",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "lookupAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "coinType",
          "type": "uint256"
        },
        {
          "internalType": "string[]",
          "name": "gateways",
          "type": "string[]"
        }
      ],
      "name": "reverseWithGateways",
      "outputs": [
        {
          "internalType": "string",
          "name": "primary",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "reverseResolver",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "UniversalResolverV2",
  "sourceName": "src/universalResolver/UniversalResolverV2.sol",
  "bytecode": "0x60e060405234801561000f575f80fd5b50604051613ef9380380613ef983398101604081905261002e91610062565b61c3506080526001600160a01b0390811660a0521660c05261009a565b6001600160a01b038116811461005f575f80fd5b50565b5f8060408385031215610073575f80fd5b825161007e8161004b565b602084015190925061008f8161004b565b809150509250929050565b60805160a05160c051613e196100e05f395f818161035b01528181610e52015261134401525f8181610194015281816109a70152610a4201525f611ace0152613e195ff3fe608060405234801561000f575f80fd5b5060043610610163575f3560e01c80639f28e99d116100c7578063b7d6ca641161007d578063c92cc49a11610063578063c92cc49a14610356578063ef46c0b81461037d578063f272e2af14610390575f80fd5b8063b7d6ca6414610323578063c285238a14610336575f80fd5b8063a1cbcbaf116100ad578063a1cbcbaf146102c5578063b4a85801146102fd578063b536af7614610310575f80fd5b80639f28e99d14610292578063a1472844146102b2575f80fd5b806355391bb81161011c5780635d78a217116101025780635d78a2171461024b5780639061b9231461025e57806394fbfa871461027f575f80fd5b806355391bb814610216578063575de75014610229575f80fd5b80633c6cbda81161014c5780633c6cbda8146101ce578063491fc4f9146101e35780634a3e3994146101f6575f80fd5b806301ffc9a71461016757806302cf25781461018f575b5f80fd5b61017a6101753660046129f6565b6103b0565b60405190151581526020015b60405180910390f35b6101b67f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610186565b6101e16101dc366004612a4f565b6103ff565b005b6101e16101f1366004612a4f565b610443565b610209610204366004612c95565b610683565b6040516101869190612d61565b6101e1610224366004612d73565b6107b7565b61023c610237366004612a4f565b61083a565b60405161018693929190612dd7565b61023c610259366004612e09565b61099b565b61027161026c366004612a4f565b610a36565b604051610186929190612e51565b61023c61028d366004612a4f565b610acf565b6102a56102a0366004612e7b565b610bd7565b604051610186919061303b565b6102716102c0366004613104565b610d98565b6102d86102d3366004613191565b610e4a565b604080516001600160a01b039094168452602084019290925290820152606001610186565b61027161030b366004612a4f565b610e86565b6102a561031e366004612a4f565b610edc565b61023c6103313660046131c3565b611136565b610349610344366004613191565b61125c565b6040516101869190613231565b6101b67f000000000000000000000000000000000000000000000000000000000000000081565b6101e161038b36600461328b565b6112b8565b6103a361039e3660046132eb565b61133d565b604051610186919061332a565b5f7f6cd2d09b000000000000000000000000000000000000000000000000000000006001600160e01b0319831614806103f957506301ffc9a760e01b6001600160e01b03198316145b92915050565b61043d84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506113a592505050565b50505050565b5f61045084860186612e7b565b5190505f80808061046386880188613383565b935093509350935060608315610573575f865167ffffffffffffffff81111561048e5761048e612aca565b6040519080825280602002602001820160405280156104c157816020015b60608152602001906001900390816104ac5790505b5090505f5b875181101561054a575f8882815181106104e2576104e26133e8565b602002602001015190505f8160400151905088801561050657506060820151600e16155b15610522578080602001905181019061051f9190613450565b90505b80848481518110610535576105356133e8565b602090810291909101015250506001016104c6565b508060405160200161055c9190613482565b604051602081830303815290604052915050610628565b5f865f81518110610586576105866133e8565b602002602001015190508060400151915060048160600151165f146105ad57815160208301fd5b6060810151600216156105c8576105c3826113a5565b610609565b81515f036106095780602001516105de906134e4565b604051637b1c461b60e01b81526001600160e01b031990911660048201526024015b60405180910390fd5b851561062657818060200190518101906106239190613450565b91505b505b61067730848385604051602401610640929190613517565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611404565b50505050505050505050565b6040805160a08101825260608082525f60208301819052928201839052818101839052608082019290925286868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250505090825250604080516020601f89018190048102820181019092528781526107229189908990819084018382808284375f9201829052509250611429915050565b60408201526001600160a01b038816606082015261073f8161145a565b6107ac8186868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516001600160a01b038f16602082015289935063b4a8580160e01b9250015b604051602081830303815290604052611522565b509695505050505050565b5f8080806107c785870187613544565b935093509350935086515f036107fc57604051637b1c461b60e01b81526001600160e01b031984166004820152602401610600565b831561081957868060200190518101906108169190613450565b96505b61083130838984604051602401610640929190613517565b50505050505050565b60605f808061084b858701876135fa565b905061085987890189613191565b935083515f03610882576060015160408051602081019091525f80825290945092509050610991565b5f61088f6103448661188e565b905061098e81603c84602001511461090d57826040015184602001516040516024016108c5929190918252602082015260400190565b60408051601f198184030181529190526020810180516001600160e01b03167ff1cb7e0600000000000000000000000000000000000000000000000000000000179052610968565b826040015160405160240161092491815260200190565b60408051601f198184030181529190526020810180516001600160e01b03167f3b3b57de000000000000000000000000000000000000000000000000000000001790525b84604001516394fbfa8760e01b868a876060015160405160200161079893929190613683565b50505b9450945094915050565b60605f80610a278686867f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610a00573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610331919081019061374f565b92509250925093509350939050565b60605f610ac2868686867f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610a9b573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102c0919081019061374f565b9150915094509492505050565b60605f80610b056040518060800160405280606081526020015f8152602001606081526020015f6001600160a01b031681525090565b610b1185870187613781565b60208301519196509450909150606090603b1901610b6f575f610b36898b018b6137f4565b6040516bffffffffffffffffffffffff19606083901b166020820152909150603401604051602081830303815290604052915050610b7e565b610b7b888a018a613191565b90505b8151610b8a9082611a64565b610bc45784816040517fef9c03ce000000000000000000000000000000000000000000000000000000008152600401610600929190613517565b8160600151925050509450945094915050565b60408051808201909152606080825260208201525f5b825151811015610d8a575f835f01518281518110610c0d57610c0d6133e8565b6020026020010151905060408160600151165f14610c2b5750610d82565b60608101516030165f03610cd5575f610c46825f0151611a88565b610c51576010610c54565b60205b9050825b855151811015610cd257825f01516001600160a01b0316865f01518281518110610c8457610c846133e8565b60200260200101515f01516001600160a01b031603610cca5781865f01518281518110610cb357610cb36133e8565b602002602001015160600181815117915081815250505b600101610c58565b50505b5f60208260600151165f1490505f80610cf78315855f01518660200151611aba565b9150915081158015610d215750630556f18360e41b610d15826134e4565b6001600160e01b031916145b15610d36576060840180516001179052610d76565b6060840180516040179052828015610d4d57508051155b610d625781610d625760608401805160021790525b80515f03610d765760608401805160081790525b60409093019290925250505b600101610bed565b50610d9482611b4d565b5090565b60605f80610dda88888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061125c92505050565b9050610e3f8187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152505050506060840151604080516001600160a01b039092166020830152889163b4a8580160e01b9101610798565b509550959350505050565b5f805f610e787f0000000000000000000000000000000000000000000000000000000000000000855f611d38565b919790965090945092505050565b60605f8585610e97858701876137f4565b82828080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250929c939b50929950505050505050505050565b60408051808201909152606080825260208201525f80610efe8688018861380f565b915091508051825114610f245760405163252e18f560e11b815260040160405180910390fd5b610f3084860186612e7b565b92505f805b845151811015611100575f855f01518281518110610f5557610f556133e8565b6020026020010151905060408160600151165f036110f75783518310156110eb575f848481518110610f8957610f896133e8565b60200260200101519050858481518110610fa557610fa56133e8565b602002602001015115610fc25760608201805160441790526110e5565b5f610fd08360400151611ea4565b90505f815f01516001600160a01b03168260600151848460800151604051602401610ffc929190613517565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b031990941693909317909252905161103a91906138d8565b5f60405180830381855afa9150503d805f8114611072576040519150601f19603f3d011682016040523d82523d5f602084013e611077565b606091505b509350905080806110a15750630556f18360e41b611094846134e4565b6001600160e01b03191614155b156110e25760608401805160401790528015806110bd57508251155b156110ce5760608401805160021790525b82515f036110e25760608401805160081790525b50505b60408201525b6110f4836138f7565b92505b50600101610f35565b50815181146111225760405163252e18f560e11b815260040160405180910390fd5b61112b84611b4d565b505050949350505050565b60605f805f6111866103446111818a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508c9250611ee8915050565b61188e565b90506112518182604001516040516024016111a391815260200190565b60405160208183030381529060405263691f343160e01b6020820180516001600160e01b0383818316178352505050508763575de75060e01b60405180608001604052808e8e8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050509082525060208082018e905260408083018e905260608a8101516001600160a01b0316930192909252905161079892910161390f565b509450945094915050565b6040805160a08101825260608082525f602083018190529282018390528101829052608081019190915261128f82610e4a565b602084015260408301526001600160a01b031660608201528181526112b38161145a565b919050565b5f818060200190518101906112cd9190613937565b9050611338815f015182602001518584604001516040516024016112f2929190613517565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a086015161202d565b505050565b606061139e7f000000000000000000000000000000000000000000000000000000000000000084848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92018290525092506121f0915050565b9392505050565b637b1c461b60e01b6113b6826134e4565b6001600160e01b031916036113cd57805160208201fd5b806040517f95c0c7520000000000000000000000000000000000000000000000000000000081526004016106009190612d61565b50565b61142582825f60e01b5f60e01b60405180602001604052805f81525061202d565b5050565b5f611434838361229f565b9250905080156103f95761139e61144b8484611429565b825f9182526020526040902090565b60608101516001600160a01b0316611488578051604051630ee413fd60e31b81526106009190600401612d61565b61149d8160600151639061b92360e01b6122cc565b156114ac576001608082015250565b6020810151156114d2578051604051630ee413fd60e31b81526106009190600401612d61565b80606001516001600160a01b03163b5f0361140157805160608201516040517f1e9535f2000000000000000000000000000000000000000000000000000000008152610600929190600401612e51565b5f7fac9650d80000000000000000000000000000000000000000000000000000000061154d866134e4565b6001600160e01b03191614905061156f866060015163582de3e760e01b6122cc565b801561161657508015806116165750856080015180156116165750606086015160405163582de3e760e01b81527f96b62db80000000000000000000000000000000000000000000000000000000060048201526001600160a01b039091169063582de3e790602401602060405180830381865afa1580156115f2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116169190613a06565b156116ec576116ec866060015187608001516116325786611671565b875160405161164691908990602401613517565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b1790525b60808901517f55391bb800000000000000000000000000000000000000000000000000000000907f3c6cbda800000000000000000000000000000000000000000000000000000000906116c38b6134e4565b89896040516020016116d89493929190613a21565b60405160208183030381529060405261202d565b606081156117265761170c8660048089516117079190613a5f565b612352565b80602001905181019061171f9190613a72565b9050611771565b60408051600180825281830190925290816020015b606081526020019060019003908161173b57905050905085815f81518110611765576117656133e8565b60200260200101819052505b866080015115611808575f5b815181101561180657875f015182828151811061179c5761179c6133e8565b60200260200101516040516024016117b5929190613517565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b17905282518390839081106117f3576117f36133e8565b602090810291909101015260010161177d565b505b61083130306001600160a01b0316639f28e99d61182a8b60600151868b6123a7565b60405160240161183a919061303b565b604051602081830303815290604052915060e01b6020820180516001600160e01b03838183161783525050505063491fc4f960e01b5f60e01b8b60800151878a8a6040516020016116d89493929190613b1c565b80516060905f8190036118b657505060408051808201909152600181525f6020820152919050565b8060020167ffffffffffffffff8111156118d2576118d2612aca565b6040519080825280601f01601f1916602001820160405280156118fc576020820181803683370190505b5091506119106021830160208501836124bc565b5f805f5b838110156119e55785818151811061192e5761192e6133e8565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016601760f91b036119dd578281039150815f1480611972575060ff82115b156119925785604051639a4c3e3b60e01b81526004016106009190612d61565b8160f81b8584815181106119a8576119a86133e8565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053508060010192505b600101611914565b5050808203828214806119f8575060ff81115b15611a185784604051639a4c3e3b60e01b81526004016106009190612d61565b8060f81b848381518110611a2e57611a2e6133e8565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350505050919050565b5f8151835114801561139e5750508051602091820120825192909101919091201490565b5f306001600160a01b03831603611aa157506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685611af2577f0000000000000000000000000000000000000000000000000000000000000000611af4565b5a5b84604051611b0291906138d8565b5f604051808303818686fa925050503d805f8114611b3b576040519150601f19603f3d011682016040523d82523d5f602084013e611b40565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff811115611b6a57611b6a612aca565b604051908082528060200260200182016040528015611bc757816020015b611bb460405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b815260200190600190039081611b885790505b5090505f805b835151811015611c78575f845f01518281518110611bed57611bed6133e8565b6020026020010151905060408160600151165f03611c6f575f611c138260400151611ea4565b90506040518060600160405280825f01516001600160a01b03168152602001826020015181526020018260400151815250858580611c50906138f7565b965081518110611c6257611c626133e8565b6020026020010181905250505b50600101611bcd565b5080156113385780825230836020015183604051602401611c999190613b4e565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af760000000000000000000000000000000000000000000000000000000091611d0d9189910161303b565b60408051601f1981840301815290829052630556f18360e41b82526106009594939291600401613be8565b5f805f805f80611d48888861229f565b909250905081611d6657508794505f9350839250859150611e9b9050565b611d71898983611d38565b929850909650945092506001600160a01b03861615611e8c575f611d958989612505565b5090505f876001600160a01b031663e4ae7d77836040518263ffffffff1660e01b8152600401611dc59190612d61565b602060405180830381865afa158015611de0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611e049190613c4b565b90506001600160a01b03811615611e1c578096508894505b604051631ad7b10b60e11b81526001600160a01b038916906335af621690611e48908590600401612d61565b602060405180830381865afa158015611e63573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611e879190613c4b565b975050505b505f9283526020526040909120905b93509350935093565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091526103f9611ee38360048086516117079190613a5f565b612582565b606082515f03611f24576040517f7138356f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611f2d836125ed565b601760f91b603c8414611f905763800000008414611f5557611f50846001612656565b611fc7565b6040518060400160405280600781526020017f64656661756c7400000000000000000000000000000000000000000000000000815250611fc7565b6040518060400160405280600481526020017f61646472000000000000000000000000000000000000000000000000000000008152505b601760f91b6040518060400160405280600781526020017f7265766572736500000000000000000000000000000000000000000000000000815250604051602001612016959493929190613c66565b604051602081830303815290604052905092915050565b5f8061204261203b88611a88565b8888611aba565b915091508115801561206c5750630556f18360e41b612060826134e4565b6001600160e01b031916145b1561211a575f61207b82611ea4565b9050876001600160a01b0316815f01516001600160a01b03160361211857308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b031916815260200189815250604051602001611d0d9190613cb8565b505b5f826121265784612128565b855b90506001600160e01b03198116156121da57306001600160a01b0316818386604051602401612158929190613517565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b031990941693909317909252905161219691906138d8565b5f60405180830381855afa9150503d805f81146121ce576040519150601f19603f3d011682016040523d82523d5f602084013e6121d3565b606091505b5090935091505b82156121e857815160208301f35b815160208301fd5b60606121fc8383612728565b612207906001613d34565b67ffffffffffffffff81111561221f5761221f612aca565b604051908082528060200260200182016040528015612248578160200160208202803683370190505b50905083816001835161225b9190613a5f565b8151811061226b5761226b6133e8565b60200260200101906001600160a01b031690816001600160a01b0316815250506122978383835f612759565b509392505050565b5f805f6122ac8585612875565b9250905060ff8116156122c457806021858701012092505b509250929050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f51905082801561233c575060208210155b801561234757505f81115b979650505050505050565b60608167ffffffffffffffff81111561236d5761236d612aca565b6040519080825280601f01601f191660200182016040528015612397576020820181803683370190505b50905061139e8484835f866128f9565b60408051808201909152606080825260208201525f835167ffffffffffffffff8111156123d6576123d6612aca565b60405190808252806020026020018201604052801561243957816020015b61242660405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b8152602001906001900390816123f45790505b5090505f5b845181101561249f575f82828151811061245a5761245a6133e8565b60209081029190910101516001600160a01b03881681528651909150869083908110612488576124886133e8565b60209081029190910181015191015260010161243e565b506040805180820190915290815260208101929092525092915050565b5b601f8111156124dd578151835260209283019290910190601f19016124bd565b80156113385790518251600160209390930360031b9290921b5f190180199091169116179052565b60605f806125138585612875565b925090505f60ff821667ffffffffffffffff81111561253457612534612aca565b6040519080825280601f01601f19166020018201604052801561255e576020820181803683370190505b5090506125776020820160218888010160ff85166124bc565b959194509092505050565b6040805160a0810182525f808252606060208301819052928201839052828201526080810191909152818060200190518101906125bf9190613d47565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b805160609060011b8067ffffffffffffffff81111561260e5761260e612aca565b6040519080825280601f01601f191660200182016040528015612638576020820181803683370190505b509150602083810190830161264e828285612936565b505050919050565b6060825f60805b6008811061268e576001811b8310156126815761267a8183613d34565b9150612686565b91821c915b60011c61265d565b5083801561269c5750601082105b156126af576126ac600482613d34565b90505b5f6126bf600283901c6040613a5f565b90508067ffffffffffffffff8111156126da576126da612aca565b6040519080825280601f01601f191660200182016040528015612704576020820181803683370190505b5093505f86831b5f5260208501905061271e5f8284612936565b5050505092915050565b5f805b6127358484612875565b9350905060ff8116156127525761274b826138f7565b915061272b565b5092915050565b5f805f6127668787612505565b9150915081515f036127a25784600186516127819190613a5f565b81518110612791576127916133e8565b60200260200101519250505061286d565b6127b88782876127b3886001613d34565b612759565b92506001600160a01b0383161561286a57604051631ad7b10b60e11b81526001600160a01b038416906335af6216906127f5908590600401612d61565b602060405180830381865afa158015612810573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906128349190613c4b565b925082858581518110612849576128496133e8565b60200260200101906001600160a01b031690816001600160a01b0316815250505b50505b949350505050565b5f808351831061289a578360405163ba4adc2360e01b81526004016106009190612d61565b8383815181106128ac576128ac6133e8565b016020015160f81c915050818101600101816128cc5783518114156128d2565b83518110155b156128f2578360405163ba4adc2360e01b81526004016106009190612d61565b9250929050565b61290c856129078387613d34565b612999565b61291a836129078385613d34565b61292f826020850101856020880101836124bc565b5050505050565b8181015b8083101561043d5783516101005b828510801561295657505f81115b1561298c5760031901600f82821c16600a8110612976578060570161297b565b806030015b905080865350600190940193612948565b505060208401935061293a565b81518111156114255781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610600918391600401918252602082015260400190565b6001600160e01b031981168114611401575f80fd5b5f60208284031215612a06575f80fd5b813561139e816129e1565b5f8083601f840112612a21575f80fd5b50813567ffffffffffffffff811115612a38575f80fd5b6020830191508360208285010111156128f2575f80fd5b5f805f8060408587031215612a62575f80fd5b843567ffffffffffffffff80821115612a79575f80fd5b612a8588838901612a11565b90965094506020870135915080821115612a9d575f80fd5b50612aaa87828801612a11565b95989497509550505050565b6001600160a01b0381168114611401575f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff81118282101715612b0157612b01612aca565b60405290565b6040516080810167ffffffffffffffff81118282101715612b0157612b01612aca565b60405160c0810167ffffffffffffffff81118282101715612b0157612b01612aca565b604051601f8201601f1916810167ffffffffffffffff81118282101715612b7657612b76612aca565b604052919050565b5f67ffffffffffffffff821115612b9757612b97612aca565b5060051b60200190565b5f67ffffffffffffffff821115612bba57612bba612aca565b50601f01601f191660200190565b5f82601f830112612bd7575f80fd5b8135612bea612be582612ba1565b612b4d565b818152846020838601011115612bfe575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112612c29575f80fd5b81356020612c39612be583612b7e565b82815260059290921b84018101918181019086841115612c57575f80fd5b8286015b848110156107ac57803567ffffffffffffffff811115612c79575f80fd5b612c878986838b0101612bc8565b845250918301918301612c5b565b5f805f805f8060808789031215612caa575f80fd5b8635612cb581612ab6565b9550602087013567ffffffffffffffff80821115612cd1575f80fd5b612cdd8a838b01612a11565b90975095506040890135915080821115612cf5575f80fd5b612d018a838b01612a11565b90955093506060890135915080821115612d19575f80fd5b50612d2689828a01612c1a565b9150509295509295509295565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61139e6020830184612d33565b5f805f60408486031215612d85575f80fd5b833567ffffffffffffffff80821115612d9c575f80fd5b612da887838801612bc8565b94506020860135915080821115612dbd575f80fd5b50612dca86828701612a11565b9497909650939450505050565b606081525f612de96060830186612d33565b6001600160a01b0394851660208401529290931660409091015292915050565b5f805f60408486031215612e1b575f80fd5b833567ffffffffffffffff811115612e31575f80fd5b612e3d86828701612a11565b909790965060209590950135949350505050565b604081525f612e636040830185612d33565b90506001600160a01b03831660208301529392505050565b5f6020808385031215612e8c575f80fd5b823567ffffffffffffffff80821115612ea3575f80fd5b9084019060408287031215612eb6575f80fd5b612ebe612ade565b823582811115612ecc575f80fd5b8301601f81018813612edc575f80fd5b8035612eea612be582612b7e565b81815260059190911b8201860190868101908a831115612f08575f80fd5b8784015b83811015612fb057803587811115612f22575f80fd5b85016080818e03601f19011215612f37575f80fd5b612f3f612b07565b8a820135612f4c81612ab6565b8152604082013589811115612f5f575f80fd5b612f6d8f8d83860101612bc8565b8c83015250606082013589811115612f83575f80fd5b612f918f8d83860101612bc8565b6040830152506080919091013560608201528352918801918801612f0c565b5084525050508284013582811115612fc6575f80fd5b612fd288828601612c1a565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b8481101561302e57601f1986840301895261301c838351612d33565b98840198925090830190600101613000565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b828110156130d957607f198b830301845285516001600160a01b03815116835289810151888b8501526130a489850182612d33565b905086820151848203888601526130bb8282612d33565b928b0151948b0194909452509589019593890193915060010161306f565b50968a0151898803601f190160408b0152966130f58189612fe3565b9b9a5050505050505050505050565b5f805f805f60608688031215613118575f80fd5b853567ffffffffffffffff8082111561312f575f80fd5b61313b89838a01612a11565b90975095506020880135915080821115613153575f80fd5b61315f89838a01612a11565b90955093506040880135915080821115613177575f80fd5b5061318488828901612c1a565b9150509295509295909350565b5f602082840312156131a1575f80fd5b813567ffffffffffffffff8111156131b7575f80fd5b61286d84828501612bc8565b5f805f80606085870312156131d6575f80fd5b843567ffffffffffffffff808211156131ed575f80fd5b6131f988838901612a11565b9096509450602087013593506040870135915080821115613218575f80fd5b5061322587828801612c1a565b91505092959194509250565b602081525f825160a0602084015261324c60c0840182612d33565b905060208401516040840152604084015160608401526001600160a01b0360608501511660808401526080840151151560a08401528091505092915050565b5f806040838503121561329c575f80fd5b823567ffffffffffffffff808211156132b3575f80fd5b6132bf86838701612bc8565b935060208501359150808211156132d4575f80fd5b506132e185828601612bc8565b9150509250929050565b5f80602083850312156132fc575f80fd5b823567ffffffffffffffff811115613312575f80fd5b61331e85828601612a11565b90969095509350505050565b602080825282518282018190525f9190848201906040850190845b8181101561336a5783516001600160a01b031683529284019291840191600101613345565b50909695505050505050565b8015158114611401575f80fd5b5f805f8060808587031215613396575f80fd5b84356133a181613376565b935060208501356133b181613376565b925060408501356133c1816129e1565b9150606085013567ffffffffffffffff8111156133dc575f80fd5b61322587828801612bc8565b634e487b7160e01b5f52603260045260245ffd5b5f613409612be584612ba1565b905082815283838301111561341c575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f830112613441575f80fd5b61139e838351602085016133fc565b5f60208284031215613460575f80fd5b815167ffffffffffffffff811115613476575f80fd5b61286d84828501613432565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b828110156134d757603f198886030184526134c5858351612d33565b945092850192908501906001016134a9565b5092979650505050505050565b5f815160208301516001600160e01b03198082169350600483101561264e5760049290920360031b82901b161692915050565b604081525f6135296040830185612d33565b828103602084015261353b8185612d33565b95945050505050565b5f805f8060808587031215613557575f80fd5b843561356281613376565b935060208501356133b1816129e1565b5f60808284031215613582575f80fd5b61358a612b07565b9050813567ffffffffffffffff808211156135a3575f80fd5b6135af85838601612bc8565b83526020840135602084015260408401359150808211156135ce575f80fd5b506135db84828501612c1a565b60408301525060608201356135ef81612ab6565b606082015292915050565b5f6020828403121561360a575f80fd5b813567ffffffffffffffff811115613620575f80fd5b61286d84828501613572565b5f8151608084526136406080850182612d33565b905060208301516020850152604083015184820360408601526136638282612fe3565b9150506001600160a01b0360608401511660608501528091505092915050565b606081525f613695606083018661362c565b82810360208401526136a78186612d33565b9150506001600160a01b0383166040830152949350505050565b5f82601f8301126136d0575f80fd5b815160206136e0612be583612b7e565b82815260059290921b840181019181810190868411156136fe575f80fd5b8286015b848110156107ac57805167ffffffffffffffff811115613720575f80fd5b8701603f81018913613730575f80fd5b6137418986830151604084016133fc565b845250918301918301613702565b5f6020828403121561375f575f80fd5b815167ffffffffffffffff811115613775575f80fd5b61286d848285016136c1565b5f805f60608486031215613793575f80fd5b833567ffffffffffffffff808211156137aa575f80fd5b6137b687838801613572565b945060208601359150808211156137cb575f80fd5b506137d886828701612bc8565b92505060408401356137e981612ab6565b809150509250925092565b5f60208284031215613804575f80fd5b813561139e81612ab6565b5f8060408385031215613820575f80fd5b823567ffffffffffffffff80821115613837575f80fd5b818501915085601f83011261384a575f80fd5b8135602061385a612be583612b7e565b82815260059290921b84018101918181019089841115613878575f80fd5b948201945b8386101561389f57853561389081613376565b8252948201949082019061387d565b965050860135925050808211156138b4575f80fd5b506132e185828601612c1a565b5f81518060208401855e5f93019283525090919050565b5f61139e82846138c1565b634e487b7160e01b5f52601160045260245ffd5b5f60018201613908576139086138e3565b5060010190565b602081525f61139e602083018461362c565b80516112b381612ab6565b80516112b3816129e1565b5f60208284031215613947575f80fd5b815167ffffffffffffffff8082111561395e575f80fd5b9083019060c08286031215613971575f80fd5b613979612b2a565b61398283613921565b81526139906020840161392c565b60208201526040830151828111156139a6575f80fd5b6139b287828601613432565b6040830152506139c46060840161392c565b60608201526139d56080840161392c565b608082015260a0830151828111156139eb575f80fd5b6139f787828601613432565b60a08301525095945050505050565b5f60208284031215613a16575f80fd5b815161139e81613376565b84151581525f6001600160e01b0319808616602084015280851660408401525060806060830152613a556080830184612d33565b9695505050505050565b818103818111156103f9576103f96138e3565b5f6020808385031215613a83575f80fd5b825167ffffffffffffffff80821115613a9a575f80fd5b818501915085601f830112613aad575f80fd5b8151613abb612be582612b7e565b81815260059190911b83018401908481019088831115613ad9575f80fd5b8585015b83811015613b0f57805185811115613af3575f80fd5b613b018b89838a0101613432565b845250918601918601613add565b5098975050505050505050565b841515815283151560208201526001600160e01b031983166040820152608060608201525f613a556080830184612d33565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b83811015613bda57603f19898403018552815160606001600160a01b03825116855288820151818a870152613bac82870182612fe3565b91505087820151915084810388860152613bc68183612d33565b968901969450505090860190600101613b75565b509098975050505050505050565b6001600160a01b038616815260a060208201525f613c0960a0830187612fe3565b8281036040840152613c1b8187612d33565b90506001600160e01b0319851660608401528281036080840152613c3f8185612d33565b98975050505050505050565b5f60208284031215613c5b575f80fd5b815161139e81612ab6565b5f613c7182886138c1565b7fff000000000000000000000000000000000000000000000000000000000000008088168252613ca460018301886138c1565b90861681529050613c3f60018201856138c1565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c06060850152613cfe60e0850183612d33565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c085015261353b8282612d33565b808201808211156103f9576103f96138e3565b5f805f805f60a08688031215613d5b575f80fd5b8551613d6681612ab6565b602087015190955067ffffffffffffffff80821115613d83575f80fd5b613d8f89838a016136c1565b95506040880151915080821115613da4575f80fd5b613db089838a01613432565b945060608801519150613dc2826129e1565b608088015191935080821115613dd6575f80fd5b506131848882890161343256fea2646970667358221220595072c31c9a27a603aee3a9955dc4fb1f721ccd2208faaefe84cfdbb2bf9bc664736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b5060043610610163575f3560e01c80639f28e99d116100c7578063b7d6ca641161007d578063c92cc49a11610063578063c92cc49a14610356578063ef46c0b81461037d578063f272e2af14610390575f80fd5b8063b7d6ca6414610323578063c285238a14610336575f80fd5b8063a1cbcbaf116100ad578063a1cbcbaf146102c5578063b4a85801146102fd578063b536af7614610310575f80fd5b80639f28e99d14610292578063a1472844146102b2575f80fd5b806355391bb81161011c5780635d78a217116101025780635d78a2171461024b5780639061b9231461025e57806394fbfa871461027f575f80fd5b806355391bb814610216578063575de75014610229575f80fd5b80633c6cbda81161014c5780633c6cbda8146101ce578063491fc4f9146101e35780634a3e3994146101f6575f80fd5b806301ffc9a71461016757806302cf25781461018f575b5f80fd5b61017a6101753660046129f6565b6103b0565b60405190151581526020015b60405180910390f35b6101b67f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610186565b6101e16101dc366004612a4f565b6103ff565b005b6101e16101f1366004612a4f565b610443565b610209610204366004612c95565b610683565b6040516101869190612d61565b6101e1610224366004612d73565b6107b7565b61023c610237366004612a4f565b61083a565b60405161018693929190612dd7565b61023c610259366004612e09565b61099b565b61027161026c366004612a4f565b610a36565b604051610186929190612e51565b61023c61028d366004612a4f565b610acf565b6102a56102a0366004612e7b565b610bd7565b604051610186919061303b565b6102716102c0366004613104565b610d98565b6102d86102d3366004613191565b610e4a565b604080516001600160a01b039094168452602084019290925290820152606001610186565b61027161030b366004612a4f565b610e86565b6102a561031e366004612a4f565b610edc565b61023c6103313660046131c3565b611136565b610349610344366004613191565b61125c565b6040516101869190613231565b6101b67f000000000000000000000000000000000000000000000000000000000000000081565b6101e161038b36600461328b565b6112b8565b6103a361039e3660046132eb565b61133d565b604051610186919061332a565b5f7f6cd2d09b000000000000000000000000000000000000000000000000000000006001600160e01b0319831614806103f957506301ffc9a760e01b6001600160e01b03198316145b92915050565b61043d84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506113a592505050565b50505050565b5f61045084860186612e7b565b5190505f80808061046386880188613383565b935093509350935060608315610573575f865167ffffffffffffffff81111561048e5761048e612aca565b6040519080825280602002602001820160405280156104c157816020015b60608152602001906001900390816104ac5790505b5090505f5b875181101561054a575f8882815181106104e2576104e26133e8565b602002602001015190505f8160400151905088801561050657506060820151600e16155b15610522578080602001905181019061051f9190613450565b90505b80848481518110610535576105356133e8565b602090810291909101015250506001016104c6565b508060405160200161055c9190613482565b604051602081830303815290604052915050610628565b5f865f81518110610586576105866133e8565b602002602001015190508060400151915060048160600151165f146105ad57815160208301fd5b6060810151600216156105c8576105c3826113a5565b610609565b81515f036106095780602001516105de906134e4565b604051637b1c461b60e01b81526001600160e01b031990911660048201526024015b60405180910390fd5b851561062657818060200190518101906106239190613450565b91505b505b61067730848385604051602401610640929190613517565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611404565b50505050505050505050565b6040805160a08101825260608082525f60208301819052928201839052818101839052608082019290925286868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250505090825250604080516020601f89018190048102820181019092528781526107229189908990819084018382808284375f9201829052509250611429915050565b60408201526001600160a01b038816606082015261073f8161145a565b6107ac8186868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516001600160a01b038f16602082015289935063b4a8580160e01b9250015b604051602081830303815290604052611522565b509695505050505050565b5f8080806107c785870187613544565b935093509350935086515f036107fc57604051637b1c461b60e01b81526001600160e01b031984166004820152602401610600565b831561081957868060200190518101906108169190613450565b96505b61083130838984604051602401610640929190613517565b50505050505050565b60605f808061084b858701876135fa565b905061085987890189613191565b935083515f03610882576060015160408051602081019091525f80825290945092509050610991565b5f61088f6103448661188e565b905061098e81603c84602001511461090d57826040015184602001516040516024016108c5929190918252602082015260400190565b60408051601f198184030181529190526020810180516001600160e01b03167ff1cb7e0600000000000000000000000000000000000000000000000000000000179052610968565b826040015160405160240161092491815260200190565b60408051601f198184030181529190526020810180516001600160e01b03167f3b3b57de000000000000000000000000000000000000000000000000000000001790525b84604001516394fbfa8760e01b868a876060015160405160200161079893929190613683565b50505b9450945094915050565b60605f80610a278686867f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610a00573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610331919081019061374f565b92509250925093509350939050565b60605f610ac2868686867f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610a9b573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102c0919081019061374f565b9150915094509492505050565b60605f80610b056040518060800160405280606081526020015f8152602001606081526020015f6001600160a01b031681525090565b610b1185870187613781565b60208301519196509450909150606090603b1901610b6f575f610b36898b018b6137f4565b6040516bffffffffffffffffffffffff19606083901b166020820152909150603401604051602081830303815290604052915050610b7e565b610b7b888a018a613191565b90505b8151610b8a9082611a64565b610bc45784816040517fef9c03ce000000000000000000000000000000000000000000000000000000008152600401610600929190613517565b8160600151925050509450945094915050565b60408051808201909152606080825260208201525f5b825151811015610d8a575f835f01518281518110610c0d57610c0d6133e8565b6020026020010151905060408160600151165f14610c2b5750610d82565b60608101516030165f03610cd5575f610c46825f0151611a88565b610c51576010610c54565b60205b9050825b855151811015610cd257825f01516001600160a01b0316865f01518281518110610c8457610c846133e8565b60200260200101515f01516001600160a01b031603610cca5781865f01518281518110610cb357610cb36133e8565b602002602001015160600181815117915081815250505b600101610c58565b50505b5f60208260600151165f1490505f80610cf78315855f01518660200151611aba565b9150915081158015610d215750630556f18360e41b610d15826134e4565b6001600160e01b031916145b15610d36576060840180516001179052610d76565b6060840180516040179052828015610d4d57508051155b610d625781610d625760608401805160021790525b80515f03610d765760608401805160081790525b60409093019290925250505b600101610bed565b50610d9482611b4d565b5090565b60605f80610dda88888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061125c92505050565b9050610e3f8187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152505050506060840151604080516001600160a01b039092166020830152889163b4a8580160e01b9101610798565b509550959350505050565b5f805f610e787f0000000000000000000000000000000000000000000000000000000000000000855f611d38565b919790965090945092505050565b60605f8585610e97858701876137f4565b82828080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250929c939b50929950505050505050505050565b60408051808201909152606080825260208201525f80610efe8688018861380f565b915091508051825114610f245760405163252e18f560e11b815260040160405180910390fd5b610f3084860186612e7b565b92505f805b845151811015611100575f855f01518281518110610f5557610f556133e8565b6020026020010151905060408160600151165f036110f75783518310156110eb575f848481518110610f8957610f896133e8565b60200260200101519050858481518110610fa557610fa56133e8565b602002602001015115610fc25760608201805160441790526110e5565b5f610fd08360400151611ea4565b90505f815f01516001600160a01b03168260600151848460800151604051602401610ffc929190613517565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b031990941693909317909252905161103a91906138d8565b5f60405180830381855afa9150503d805f8114611072576040519150601f19603f3d011682016040523d82523d5f602084013e611077565b606091505b509350905080806110a15750630556f18360e41b611094846134e4565b6001600160e01b03191614155b156110e25760608401805160401790528015806110bd57508251155b156110ce5760608401805160021790525b82515f036110e25760608401805160081790525b50505b60408201525b6110f4836138f7565b92505b50600101610f35565b50815181146111225760405163252e18f560e11b815260040160405180910390fd5b61112b84611b4d565b505050949350505050565b60605f805f6111866103446111818a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508c9250611ee8915050565b61188e565b90506112518182604001516040516024016111a391815260200190565b60405160208183030381529060405263691f343160e01b6020820180516001600160e01b0383818316178352505050508763575de75060e01b60405180608001604052808e8e8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050509082525060208082018e905260408083018e905260608a8101516001600160a01b0316930192909252905161079892910161390f565b509450945094915050565b6040805160a08101825260608082525f602083018190529282018390528101829052608081019190915261128f82610e4a565b602084015260408301526001600160a01b031660608201528181526112b38161145a565b919050565b5f818060200190518101906112cd9190613937565b9050611338815f015182602001518584604001516040516024016112f2929190613517565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a086015161202d565b505050565b606061139e7f000000000000000000000000000000000000000000000000000000000000000084848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92018290525092506121f0915050565b9392505050565b637b1c461b60e01b6113b6826134e4565b6001600160e01b031916036113cd57805160208201fd5b806040517f95c0c7520000000000000000000000000000000000000000000000000000000081526004016106009190612d61565b50565b61142582825f60e01b5f60e01b60405180602001604052805f81525061202d565b5050565b5f611434838361229f565b9250905080156103f95761139e61144b8484611429565b825f9182526020526040902090565b60608101516001600160a01b0316611488578051604051630ee413fd60e31b81526106009190600401612d61565b61149d8160600151639061b92360e01b6122cc565b156114ac576001608082015250565b6020810151156114d2578051604051630ee413fd60e31b81526106009190600401612d61565b80606001516001600160a01b03163b5f0361140157805160608201516040517f1e9535f2000000000000000000000000000000000000000000000000000000008152610600929190600401612e51565b5f7fac9650d80000000000000000000000000000000000000000000000000000000061154d866134e4565b6001600160e01b03191614905061156f866060015163582de3e760e01b6122cc565b801561161657508015806116165750856080015180156116165750606086015160405163582de3e760e01b81527f96b62db80000000000000000000000000000000000000000000000000000000060048201526001600160a01b039091169063582de3e790602401602060405180830381865afa1580156115f2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116169190613a06565b156116ec576116ec866060015187608001516116325786611671565b875160405161164691908990602401613517565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b1790525b60808901517f55391bb800000000000000000000000000000000000000000000000000000000907f3c6cbda800000000000000000000000000000000000000000000000000000000906116c38b6134e4565b89896040516020016116d89493929190613a21565b60405160208183030381529060405261202d565b606081156117265761170c8660048089516117079190613a5f565b612352565b80602001905181019061171f9190613a72565b9050611771565b60408051600180825281830190925290816020015b606081526020019060019003908161173b57905050905085815f81518110611765576117656133e8565b60200260200101819052505b866080015115611808575f5b815181101561180657875f015182828151811061179c5761179c6133e8565b60200260200101516040516024016117b5929190613517565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b17905282518390839081106117f3576117f36133e8565b602090810291909101015260010161177d565b505b61083130306001600160a01b0316639f28e99d61182a8b60600151868b6123a7565b60405160240161183a919061303b565b604051602081830303815290604052915060e01b6020820180516001600160e01b03838183161783525050505063491fc4f960e01b5f60e01b8b60800151878a8a6040516020016116d89493929190613b1c565b80516060905f8190036118b657505060408051808201909152600181525f6020820152919050565b8060020167ffffffffffffffff8111156118d2576118d2612aca565b6040519080825280601f01601f1916602001820160405280156118fc576020820181803683370190505b5091506119106021830160208501836124bc565b5f805f5b838110156119e55785818151811061192e5761192e6133e8565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016601760f91b036119dd578281039150815f1480611972575060ff82115b156119925785604051639a4c3e3b60e01b81526004016106009190612d61565b8160f81b8584815181106119a8576119a86133e8565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053508060010192505b600101611914565b5050808203828214806119f8575060ff81115b15611a185784604051639a4c3e3b60e01b81526004016106009190612d61565b8060f81b848381518110611a2e57611a2e6133e8565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350505050919050565b5f8151835114801561139e5750508051602091820120825192909101919091201490565b5f306001600160a01b03831603611aa157506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685611af2577f0000000000000000000000000000000000000000000000000000000000000000611af4565b5a5b84604051611b0291906138d8565b5f604051808303818686fa925050503d805f8114611b3b576040519150601f19603f3d011682016040523d82523d5f602084013e611b40565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff811115611b6a57611b6a612aca565b604051908082528060200260200182016040528015611bc757816020015b611bb460405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b815260200190600190039081611b885790505b5090505f805b835151811015611c78575f845f01518281518110611bed57611bed6133e8565b6020026020010151905060408160600151165f03611c6f575f611c138260400151611ea4565b90506040518060600160405280825f01516001600160a01b03168152602001826020015181526020018260400151815250858580611c50906138f7565b965081518110611c6257611c626133e8565b6020026020010181905250505b50600101611bcd565b5080156113385780825230836020015183604051602401611c999190613b4e565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af760000000000000000000000000000000000000000000000000000000091611d0d9189910161303b565b60408051601f1981840301815290829052630556f18360e41b82526106009594939291600401613be8565b5f805f805f80611d48888861229f565b909250905081611d6657508794505f9350839250859150611e9b9050565b611d71898983611d38565b929850909650945092506001600160a01b03861615611e8c575f611d958989612505565b5090505f876001600160a01b031663e4ae7d77836040518263ffffffff1660e01b8152600401611dc59190612d61565b602060405180830381865afa158015611de0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611e049190613c4b565b90506001600160a01b03811615611e1c578096508894505b604051631ad7b10b60e11b81526001600160a01b038916906335af621690611e48908590600401612d61565b602060405180830381865afa158015611e63573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611e879190613c4b565b975050505b505f9283526020526040909120905b93509350935093565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091526103f9611ee38360048086516117079190613a5f565b612582565b606082515f03611f24576040517f7138356f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611f2d836125ed565b601760f91b603c8414611f905763800000008414611f5557611f50846001612656565b611fc7565b6040518060400160405280600781526020017f64656661756c7400000000000000000000000000000000000000000000000000815250611fc7565b6040518060400160405280600481526020017f61646472000000000000000000000000000000000000000000000000000000008152505b601760f91b6040518060400160405280600781526020017f7265766572736500000000000000000000000000000000000000000000000000815250604051602001612016959493929190613c66565b604051602081830303815290604052905092915050565b5f8061204261203b88611a88565b8888611aba565b915091508115801561206c5750630556f18360e41b612060826134e4565b6001600160e01b031916145b1561211a575f61207b82611ea4565b9050876001600160a01b0316815f01516001600160a01b03160361211857308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b031916815260200189815250604051602001611d0d9190613cb8565b505b5f826121265784612128565b855b90506001600160e01b03198116156121da57306001600160a01b0316818386604051602401612158929190613517565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b031990941693909317909252905161219691906138d8565b5f60405180830381855afa9150503d805f81146121ce576040519150601f19603f3d011682016040523d82523d5f602084013e6121d3565b606091505b5090935091505b82156121e857815160208301f35b815160208301fd5b60606121fc8383612728565b612207906001613d34565b67ffffffffffffffff81111561221f5761221f612aca565b604051908082528060200260200182016040528015612248578160200160208202803683370190505b50905083816001835161225b9190613a5f565b8151811061226b5761226b6133e8565b60200260200101906001600160a01b031690816001600160a01b0316815250506122978383835f612759565b509392505050565b5f805f6122ac8585612875565b9250905060ff8116156122c457806021858701012092505b509250929050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f51905082801561233c575060208210155b801561234757505f81115b979650505050505050565b60608167ffffffffffffffff81111561236d5761236d612aca565b6040519080825280601f01601f191660200182016040528015612397576020820181803683370190505b50905061139e8484835f866128f9565b60408051808201909152606080825260208201525f835167ffffffffffffffff8111156123d6576123d6612aca565b60405190808252806020026020018201604052801561243957816020015b61242660405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b8152602001906001900390816123f45790505b5090505f5b845181101561249f575f82828151811061245a5761245a6133e8565b60209081029190910101516001600160a01b03881681528651909150869083908110612488576124886133e8565b60209081029190910181015191015260010161243e565b506040805180820190915290815260208101929092525092915050565b5b601f8111156124dd578151835260209283019290910190601f19016124bd565b80156113385790518251600160209390930360031b9290921b5f190180199091169116179052565b60605f806125138585612875565b925090505f60ff821667ffffffffffffffff81111561253457612534612aca565b6040519080825280601f01601f19166020018201604052801561255e576020820181803683370190505b5090506125776020820160218888010160ff85166124bc565b959194509092505050565b6040805160a0810182525f808252606060208301819052928201839052828201526080810191909152818060200190518101906125bf9190613d47565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b805160609060011b8067ffffffffffffffff81111561260e5761260e612aca565b6040519080825280601f01601f191660200182016040528015612638576020820181803683370190505b509150602083810190830161264e828285612936565b505050919050565b6060825f60805b6008811061268e576001811b8310156126815761267a8183613d34565b9150612686565b91821c915b60011c61265d565b5083801561269c5750601082105b156126af576126ac600482613d34565b90505b5f6126bf600283901c6040613a5f565b90508067ffffffffffffffff8111156126da576126da612aca565b6040519080825280601f01601f191660200182016040528015612704576020820181803683370190505b5093505f86831b5f5260208501905061271e5f8284612936565b5050505092915050565b5f805b6127358484612875565b9350905060ff8116156127525761274b826138f7565b915061272b565b5092915050565b5f805f6127668787612505565b9150915081515f036127a25784600186516127819190613a5f565b81518110612791576127916133e8565b60200260200101519250505061286d565b6127b88782876127b3886001613d34565b612759565b92506001600160a01b0383161561286a57604051631ad7b10b60e11b81526001600160a01b038416906335af6216906127f5908590600401612d61565b602060405180830381865afa158015612810573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906128349190613c4b565b925082858581518110612849576128496133e8565b60200260200101906001600160a01b031690816001600160a01b0316815250505b50505b949350505050565b5f808351831061289a578360405163ba4adc2360e01b81526004016106009190612d61565b8383815181106128ac576128ac6133e8565b016020015160f81c915050818101600101816128cc5783518114156128d2565b83518110155b156128f2578360405163ba4adc2360e01b81526004016106009190612d61565b9250929050565b61290c856129078387613d34565b612999565b61291a836129078385613d34565b61292f826020850101856020880101836124bc565b5050505050565b8181015b8083101561043d5783516101005b828510801561295657505f81115b1561298c5760031901600f82821c16600a8110612976578060570161297b565b806030015b905080865350600190940193612948565b505060208401935061293a565b81518111156114255781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610600918391600401918252602082015260400190565b6001600160e01b031981168114611401575f80fd5b5f60208284031215612a06575f80fd5b813561139e816129e1565b5f8083601f840112612a21575f80fd5b50813567ffffffffffffffff811115612a38575f80fd5b6020830191508360208285010111156128f2575f80fd5b5f805f8060408587031215612a62575f80fd5b843567ffffffffffffffff80821115612a79575f80fd5b612a8588838901612a11565b90965094506020870135915080821115612a9d575f80fd5b50612aaa87828801612a11565b95989497509550505050565b6001600160a01b0381168114611401575f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff81118282101715612b0157612b01612aca565b60405290565b6040516080810167ffffffffffffffff81118282101715612b0157612b01612aca565b60405160c0810167ffffffffffffffff81118282101715612b0157612b01612aca565b604051601f8201601f1916810167ffffffffffffffff81118282101715612b7657612b76612aca565b604052919050565b5f67ffffffffffffffff821115612b9757612b97612aca565b5060051b60200190565b5f67ffffffffffffffff821115612bba57612bba612aca565b50601f01601f191660200190565b5f82601f830112612bd7575f80fd5b8135612bea612be582612ba1565b612b4d565b818152846020838601011115612bfe575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112612c29575f80fd5b81356020612c39612be583612b7e565b82815260059290921b84018101918181019086841115612c57575f80fd5b8286015b848110156107ac57803567ffffffffffffffff811115612c79575f80fd5b612c878986838b0101612bc8565b845250918301918301612c5b565b5f805f805f8060808789031215612caa575f80fd5b8635612cb581612ab6565b9550602087013567ffffffffffffffff80821115612cd1575f80fd5b612cdd8a838b01612a11565b90975095506040890135915080821115612cf5575f80fd5b612d018a838b01612a11565b90955093506060890135915080821115612d19575f80fd5b50612d2689828a01612c1a565b9150509295509295509295565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61139e6020830184612d33565b5f805f60408486031215612d85575f80fd5b833567ffffffffffffffff80821115612d9c575f80fd5b612da887838801612bc8565b94506020860135915080821115612dbd575f80fd5b50612dca86828701612a11565b9497909650939450505050565b606081525f612de96060830186612d33565b6001600160a01b0394851660208401529290931660409091015292915050565b5f805f60408486031215612e1b575f80fd5b833567ffffffffffffffff811115612e31575f80fd5b612e3d86828701612a11565b909790965060209590950135949350505050565b604081525f612e636040830185612d33565b90506001600160a01b03831660208301529392505050565b5f6020808385031215612e8c575f80fd5b823567ffffffffffffffff80821115612ea3575f80fd5b9084019060408287031215612eb6575f80fd5b612ebe612ade565b823582811115612ecc575f80fd5b8301601f81018813612edc575f80fd5b8035612eea612be582612b7e565b81815260059190911b8201860190868101908a831115612f08575f80fd5b8784015b83811015612fb057803587811115612f22575f80fd5b85016080818e03601f19011215612f37575f80fd5b612f3f612b07565b8a820135612f4c81612ab6565b8152604082013589811115612f5f575f80fd5b612f6d8f8d83860101612bc8565b8c83015250606082013589811115612f83575f80fd5b612f918f8d83860101612bc8565b6040830152506080919091013560608201528352918801918801612f0c565b5084525050508284013582811115612fc6575f80fd5b612fd288828601612c1a565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b8481101561302e57601f1986840301895261301c838351612d33565b98840198925090830190600101613000565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b828110156130d957607f198b830301845285516001600160a01b03815116835289810151888b8501526130a489850182612d33565b905086820151848203888601526130bb8282612d33565b928b0151948b0194909452509589019593890193915060010161306f565b50968a0151898803601f190160408b0152966130f58189612fe3565b9b9a5050505050505050505050565b5f805f805f60608688031215613118575f80fd5b853567ffffffffffffffff8082111561312f575f80fd5b61313b89838a01612a11565b90975095506020880135915080821115613153575f80fd5b61315f89838a01612a11565b90955093506040880135915080821115613177575f80fd5b5061318488828901612c1a565b9150509295509295909350565b5f602082840312156131a1575f80fd5b813567ffffffffffffffff8111156131b7575f80fd5b61286d84828501612bc8565b5f805f80606085870312156131d6575f80fd5b843567ffffffffffffffff808211156131ed575f80fd5b6131f988838901612a11565b9096509450602087013593506040870135915080821115613218575f80fd5b5061322587828801612c1a565b91505092959194509250565b602081525f825160a0602084015261324c60c0840182612d33565b905060208401516040840152604084015160608401526001600160a01b0360608501511660808401526080840151151560a08401528091505092915050565b5f806040838503121561329c575f80fd5b823567ffffffffffffffff808211156132b3575f80fd5b6132bf86838701612bc8565b935060208501359150808211156132d4575f80fd5b506132e185828601612bc8565b9150509250929050565b5f80602083850312156132fc575f80fd5b823567ffffffffffffffff811115613312575f80fd5b61331e85828601612a11565b90969095509350505050565b602080825282518282018190525f9190848201906040850190845b8181101561336a5783516001600160a01b031683529284019291840191600101613345565b50909695505050505050565b8015158114611401575f80fd5b5f805f8060808587031215613396575f80fd5b84356133a181613376565b935060208501356133b181613376565b925060408501356133c1816129e1565b9150606085013567ffffffffffffffff8111156133dc575f80fd5b61322587828801612bc8565b634e487b7160e01b5f52603260045260245ffd5b5f613409612be584612ba1565b905082815283838301111561341c575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f830112613441575f80fd5b61139e838351602085016133fc565b5f60208284031215613460575f80fd5b815167ffffffffffffffff811115613476575f80fd5b61286d84828501613432565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b828110156134d757603f198886030184526134c5858351612d33565b945092850192908501906001016134a9565b5092979650505050505050565b5f815160208301516001600160e01b03198082169350600483101561264e5760049290920360031b82901b161692915050565b604081525f6135296040830185612d33565b828103602084015261353b8185612d33565b95945050505050565b5f805f8060808587031215613557575f80fd5b843561356281613376565b935060208501356133b1816129e1565b5f60808284031215613582575f80fd5b61358a612b07565b9050813567ffffffffffffffff808211156135a3575f80fd5b6135af85838601612bc8565b83526020840135602084015260408401359150808211156135ce575f80fd5b506135db84828501612c1a565b60408301525060608201356135ef81612ab6565b606082015292915050565b5f6020828403121561360a575f80fd5b813567ffffffffffffffff811115613620575f80fd5b61286d84828501613572565b5f8151608084526136406080850182612d33565b905060208301516020850152604083015184820360408601526136638282612fe3565b9150506001600160a01b0360608401511660608501528091505092915050565b606081525f613695606083018661362c565b82810360208401526136a78186612d33565b9150506001600160a01b0383166040830152949350505050565b5f82601f8301126136d0575f80fd5b815160206136e0612be583612b7e565b82815260059290921b840181019181810190868411156136fe575f80fd5b8286015b848110156107ac57805167ffffffffffffffff811115613720575f80fd5b8701603f81018913613730575f80fd5b6137418986830151604084016133fc565b845250918301918301613702565b5f6020828403121561375f575f80fd5b815167ffffffffffffffff811115613775575f80fd5b61286d848285016136c1565b5f805f60608486031215613793575f80fd5b833567ffffffffffffffff808211156137aa575f80fd5b6137b687838801613572565b945060208601359150808211156137cb575f80fd5b506137d886828701612bc8565b92505060408401356137e981612ab6565b809150509250925092565b5f60208284031215613804575f80fd5b813561139e81612ab6565b5f8060408385031215613820575f80fd5b823567ffffffffffffffff80821115613837575f80fd5b818501915085601f83011261384a575f80fd5b8135602061385a612be583612b7e565b82815260059290921b84018101918181019089841115613878575f80fd5b948201945b8386101561389f57853561389081613376565b8252948201949082019061387d565b965050860135925050808211156138b4575f80fd5b506132e185828601612c1a565b5f81518060208401855e5f93019283525090919050565b5f61139e82846138c1565b634e487b7160e01b5f52601160045260245ffd5b5f60018201613908576139086138e3565b5060010190565b602081525f61139e602083018461362c565b80516112b381612ab6565b80516112b3816129e1565b5f60208284031215613947575f80fd5b815167ffffffffffffffff8082111561395e575f80fd5b9083019060c08286031215613971575f80fd5b613979612b2a565b61398283613921565b81526139906020840161392c565b60208201526040830151828111156139a6575f80fd5b6139b287828601613432565b6040830152506139c46060840161392c565b60608201526139d56080840161392c565b608082015260a0830151828111156139eb575f80fd5b6139f787828601613432565b60a08301525095945050505050565b5f60208284031215613a16575f80fd5b815161139e81613376565b84151581525f6001600160e01b0319808616602084015280851660408401525060806060830152613a556080830184612d33565b9695505050505050565b818103818111156103f9576103f96138e3565b5f6020808385031215613a83575f80fd5b825167ffffffffffffffff80821115613a9a575f80fd5b818501915085601f830112613aad575f80fd5b8151613abb612be582612b7e565b81815260059190911b83018401908481019088831115613ad9575f80fd5b8585015b83811015613b0f57805185811115613af3575f80fd5b613b018b89838a0101613432565b845250918601918601613add565b5098975050505050505050565b841515815283151560208201526001600160e01b031983166040820152608060608201525f613a556080830184612d33565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b83811015613bda57603f19898403018552815160606001600160a01b03825116855288820151818a870152613bac82870182612fe3565b91505087820151915084810388860152613bc68183612d33565b968901969450505090860190600101613b75565b509098975050505050505050565b6001600160a01b038616815260a060208201525f613c0960a0830187612fe3565b8281036040840152613c1b8187612d33565b90506001600160e01b0319851660608401528281036080840152613c3f8185612d33565b98975050505050505050565b5f60208284031215613c5b575f80fd5b815161139e81612ab6565b5f613c7182886138c1565b7fff000000000000000000000000000000000000000000000000000000000000008088168252613ca460018301886138c1565b90861681529050613c3f60018201856138c1565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c06060850152613cfe60e0850183612d33565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c085015261353b8282612d33565b808201808211156103f9576103f96138e3565b5f805f805f60a08688031215613d5b575f80fd5b8551613d6681612ab6565b602087015190955067ffffffffffffffff80821115613d83575f80fd5b613d8f89838a016136c1565b95506040880151915080821115613da4575f80fd5b613db089838a01613432565b945060608801519150613dc2826129e1565b608088015191935080821115613dd6575f80fd5b506131848882890161343256fea2646970667358221220595072c31c9a27a603aee3a9955dc4fb1f721ccd2208faaefe84cfdbb2bf9bc664736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "1090": [
      {
        "length": 32,
        "start": 6862
      }
    ],
    "2996": [
      {
        "length": 32,
        "start": 404
      },
      {
        "length": 32,
        "start": 2471
      },
      {
        "length": 32,
        "start": 2626
      }
    ],
    "18078": [
      {
        "length": 32,
        "start": 859
      },
      {
        "length": 32,
        "start": 3666
      },
      {
        "length": 32,
        "start": 4932
      }
    ]
  },
  "inputSourceName": "project/src/universalResolver/UniversalResolverV2.sol",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "DNSEncodingFailed(string)": [
        {
          "details": "A label of the ENS name has an invalid size.      Error selector: `0x9a4c3e3b`"
        }
      ],
      "EmptyAddress()": [
        {
          "details": "The supplied address was `0x`.      Error selector: `0x7138356f`"
        }
      ],
      "HttpError(uint16,string)": [
        {
          "details": "Error selector: `0x01800152`"
        }
      ],
      "InvalidBatchGatewayResponse()": [
        {
          "details": "Error selector: `0x4a5c31ea`"
        }
      ],
      "OffchainLookup(address,string[],bytes,bytes4,bytes)": [
        {
          "details": "https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`"
        }
      ],
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ],
      "ResolverError(bytes)": [
        {
          "details": "Error selector: `0x95c0c752`"
        }
      ],
      "ResolverNotContract(bytes,address)": [
        {
          "details": "Error selector: `0x1e9535f2`"
        }
      ],
      "ResolverNotFound(bytes)": [
        {
          "details": "Error selector: `0x77209fe8`"
        }
      ],
      "ReverseAddressMismatch(string,bytes)": [
        {
          "details": "Error selector: `0xef9c03ce`"
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "details": "Error selector: `0x7b1c461b`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": {
        "details": "Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`."
      },
      "ccipBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \"done\".",
        "params": {
          "extraData": "The contextual data passed from `ccipBatch()`.",
          "response": "The response from the batch gateway."
        },
        "returns": {
          "batch": "The batch where every lookup is \"done\"."
        }
      },
      "ccipReadCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.",
        "params": {
          "extraData": "The contextual data passed from `ccipRead()`.",
          "response": "The response from offchain."
        }
      },
      "findRegistries(bytes)": {
        "params": {
          "name": "The DNS-encoded name."
        },
        "returns": {
          "_0": "Array of registries in label-order."
        }
      },
      "findResolver(bytes)": {
        "details": "Find the resolver address for `name`.      Does not perform any validity checks on the resolver.",
        "params": {
          "name": "The name to search."
        },
        "returns": {
          "node": "The namehash of `name`.",
          "offset": "The offset into `name` corresponding to `resolver`.",
          "resolver": "The resolver or `address(0)` if not found."
        }
      },
      "requireResolver(bytes)": {
        "details": "Returns a valid resolver for `name` or reverts.",
        "params": {
          "name": "The name to search."
        },
        "returns": {
          "info": "The resolver information."
        }
      },
      "resolveBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `_callResolver()` from calling the batch gateway successfully."
      },
      "resolveCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `resolveWithGateways()`.",
        "params": {
          "extraData": "The contextual data passed from `resolveWith*()`.",
          "response": "The response from the resolver."
        }
      },
      "resolveDirectCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `_callResolver()` from calling the resolver successfully."
      },
      "resolveDirectCallbackError(bytes,bytes)": {
        "details": "CCIP-Read callback for `_callResolver()` from calling the resolver unsuccessfully."
      },
      "resolveWithGateways(bytes,bytes,string[])": {
        "details": "This function executes over multiple steps.",
        "params": {
          "data": "The resolution data, as specified in ENSIP-10.",
          "gateways": "The list of batch gateway URLs to use.",
          "name": "The name to resolve, in normalised and DNS-encoded form."
        },
        "returns": {
          "resolver": "The address of the resolver that supplied `result`.",
          "result": "The encoded response for the requested call."
        }
      },
      "reverseAddressCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `reverseNameCallback()`.      Reverts `ReverseAddressMismatch`.",
        "params": {
          "extraData": "The contextual data passed from `reverseNameCallback()`.",
          "response": "The abi-encoded `addr()` response from the forward resolver."
        }
      },
      "reverseNameCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `reverseWithGateways()`.",
        "params": {
          "extraData": "The contextual data passed from `reverseWithGateways()`.",
          "response": "The abi-encoded `name()` response from the reverse resolver."
        }
      },
      "reverseWithGateways(bytes,uint256,string[])": {
        "details": "This function executes over multiple steps.",
        "params": {
          "coinType": "The coin type.",
          "gateways": "The list of batch gateway URLs to use.",
          "lookupAddress": "The input address."
        },
        "returns": {
          "primary": "The resolved primary name.",
          "resolver": "The resolver address for primary name.",
          "reverseResolver": "The resolver address for the reverse name."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "3179400",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "ROOT_REGISTRY()": "infinite",
        "batchGatewayProvider()": "infinite",
        "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": "infinite",
        "ccipBatchCallback(bytes,bytes)": "infinite",
        "ccipReadCallback(bytes,bytes)": "infinite",
        "findRegistries(bytes)": "infinite",
        "findResolver(bytes)": "infinite",
        "requireResolver(bytes)": "infinite",
        "resolve(bytes,bytes)": "infinite",
        "resolveBatchCallback(bytes,bytes)": "infinite",
        "resolveCallback(bytes,bytes)": "infinite",
        "resolveDirectCallback(bytes,bytes)": "infinite",
        "resolveDirectCallbackError(bytes,bytes)": "infinite",
        "resolveWithGateways(bytes,bytes,string[])": "infinite",
        "resolveWithResolver(address,bytes,bytes,string[])": "infinite",
        "reverse(bytes,uint256)": "infinite",
        "reverseAddressCallback(bytes,bytes)": "infinite",
        "reverseNameCallback(bytes,bytes)": "infinite",
        "reverseWithGateways(bytes,uint256,string[])": "infinite",
        "supportsInterface(bytes4)": "493"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"root\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayProvider\",\"name\":\"batchGatewayProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ens\",\"type\":\"string\"}],\"name\":\"DNSEncodingFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"status\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"HttpError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchGatewayResponse\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"errorData\",\"type\":\"bytes\"}],\"name\":\"ResolverError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"ResolverNotContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"ResolverNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"primary\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"primaryAddress\",\"type\":\"bytes\"}],\"name\":\"ReverseAddressMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedResolverProfile\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ROOT_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchGatewayProvider\",\"outputs\":[{\"internalType\":\"contract IGatewayProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"ccipBatch\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipBatchCallback\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipReadCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"findRegistries\",\"outputs\":[{\"internalType\":\"contract IRegistry[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"findResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"requireResolver\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"extended\",\"type\":\"bool\"}],\"internalType\":\"struct AbstractUniversalResolver.ResolverInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveBatchCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveDirectCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"resolveDirectCallbackError\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"name\":\"resolveWithGateways\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"name\":\"resolveWithResolver\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"lookupAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"}],\"name\":\"reverse\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"reverseAddressCallback\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"primary\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reverseResolver\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"reverseNameCallback\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"primary\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"lookupAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"name\":\"reverseWithGateways\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"primary\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reverseResolver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"DNSEncodingFailed(string)\":[{\"details\":\"A label of the ENS name has an invalid size.      Error selector: `0x9a4c3e3b`\"}],\"EmptyAddress()\":[{\"details\":\"The supplied address was `0x`.      Error selector: `0x7138356f`\"}],\"HttpError(uint16,string)\":[{\"details\":\"Error selector: `0x01800152`\"}],\"InvalidBatchGatewayResponse()\":[{\"details\":\"Error selector: `0x4a5c31ea`\"}],\"OffchainLookup(address,string[],bytes,bytes4,bytes)\":[{\"details\":\"https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`\"}],\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}],\"ResolverError(bytes)\":[{\"details\":\"Error selector: `0x95c0c752`\"}],\"ResolverNotContract(bytes,address)\":[{\"details\":\"Error selector: `0x1e9535f2`\"}],\"ResolverNotFound(bytes)\":[{\"details\":\"Error selector: `0x77209fe8`\"}],\"ReverseAddressMismatch(string,bytes)\":[{\"details\":\"Error selector: `0xef9c03ce`\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"details\":\"Error selector: `0x7b1c461b`\"}]},\"kind\":\"dev\",\"methods\":{\"ccipBatch(((address,bytes,bytes,uint256)[],string[]))\":{\"details\":\"Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`.\"},\"ccipBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\",\"params\":{\"extraData\":\"The contextual data passed from `ccipBatch()`.\",\"response\":\"The response from the batch gateway.\"},\"returns\":{\"batch\":\"The batch where every lookup is \\\"done\\\".\"}},\"ccipReadCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.\",\"params\":{\"extraData\":\"The contextual data passed from `ccipRead()`.\",\"response\":\"The response from offchain.\"}},\"findRegistries(bytes)\":{\"params\":{\"name\":\"The DNS-encoded name.\"},\"returns\":{\"_0\":\"Array of registries in label-order.\"}},\"findResolver(bytes)\":{\"details\":\"Find the resolver address for `name`.      Does not perform any validity checks on the resolver.\",\"params\":{\"name\":\"The name to search.\"},\"returns\":{\"node\":\"The namehash of `name`.\",\"offset\":\"The offset into `name` corresponding to `resolver`.\",\"resolver\":\"The resolver or `address(0)` if not found.\"}},\"requireResolver(bytes)\":{\"details\":\"Returns a valid resolver for `name` or reverts.\",\"params\":{\"name\":\"The name to search.\"},\"returns\":{\"info\":\"The resolver information.\"}},\"resolveBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `_callResolver()` from calling the batch gateway successfully.\"},\"resolveCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `resolveWithGateways()`.\",\"params\":{\"extraData\":\"The contextual data passed from `resolveWith*()`.\",\"response\":\"The response from the resolver.\"}},\"resolveDirectCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `_callResolver()` from calling the resolver successfully.\"},\"resolveDirectCallbackError(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `_callResolver()` from calling the resolver unsuccessfully.\"},\"resolveWithGateways(bytes,bytes,string[])\":{\"details\":\"This function executes over multiple steps.\",\"params\":{\"data\":\"The resolution data, as specified in ENSIP-10.\",\"gateways\":\"The list of batch gateway URLs to use.\",\"name\":\"The name to resolve, in normalised and DNS-encoded form.\"},\"returns\":{\"resolver\":\"The address of the resolver that supplied `result`.\",\"result\":\"The encoded response for the requested call.\"}},\"reverseAddressCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `reverseNameCallback()`.      Reverts `ReverseAddressMismatch`.\",\"params\":{\"extraData\":\"The contextual data passed from `reverseNameCallback()`.\",\"response\":\"The abi-encoded `addr()` response from the forward resolver.\"}},\"reverseNameCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `reverseWithGateways()`.\",\"params\":{\"extraData\":\"The contextual data passed from `reverseWithGateways()`.\",\"response\":\"The abi-encoded `name()` response from the reverse resolver.\"}},\"reverseWithGateways(bytes,uint256,string[])\":{\"details\":\"This function executes over multiple steps.\",\"params\":{\"coinType\":\"The coin type.\",\"gateways\":\"The list of batch gateway URLs to use.\",\"lookupAddress\":\"The input address.\"},\"returns\":{\"primary\":\"The resolved primary name.\",\"resolver\":\"The resolver address for primary name.\",\"reverseResolver\":\"The resolver address for the reverse name.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"HttpError(uint16,string)\":[{\"notice\":\"An HTTP error occurred on a resolving gateway.\"}],\"InvalidBatchGatewayResponse()\":[{\"notice\":\"The batch gateway supplied an incorrect number of responses.\"}],\"ResolverError(bytes)\":[{\"notice\":\"The resolver returned an error.\"}],\"ResolverNotContract(bytes,address)\":[{\"notice\":\"The resolver is not a contract.\"}],\"ResolverNotFound(bytes)\":[{\"notice\":\"A resolver could not be found for the supplied name.\"}],\"ReverseAddressMismatch(string,bytes)\":[{\"notice\":\"The resolved address from reverse resolution does not match the supplied address.\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"notice\":\"The resolver did not respond.\"}]},\"kind\":\"user\",\"methods\":{\"findRegistries(bytes)\":{\"notice\":\"Find all registries in the ancestry of `name`. * `findRegistries(\\\"\\\") = [<root>]` * `findRegistries(\\\"eth\\\") = [<eth>, <root>]` * `findRegistries(\\\"nick.eth\\\") = [<nick>, <eth>, <root>]` * `findRegistries(\\\"sub.nick.eth\\\") = [null, <nick>, <eth>, <root>]`\"},\"resolve(bytes,bytes)\":{\"notice\":\"Same as `resolveWithGateways()` but uses default batch gateways.\"},\"resolveWithGateways(bytes,bytes,string[])\":{\"notice\":\"Performs ENS resolution process for the supplied name and resolution data.         Caller should enable EIP-3668.\"},\"resolveWithResolver(address,bytes,bytes,string[])\":{\"notice\":\"Same as `resolveWithGateways()` but uses the supplied resolver.\"},\"reverse(bytes,uint256)\":{\"notice\":\"Same as `reverseWithGateways()` but uses default batch gateways.\"},\"reverseWithGateways(bytes,uint256,string[])\":{\"notice\":\"Performs ENS reverse resolution for the supplied address and coin type.         Caller should enable EIP-3668.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/universalResolver/UniversalResolverV2.sol\":\"UniversalResolverV2\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/ccipRead/CCIPBatcher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IBatchGateway} from \\\"./IBatchGateway.sol\\\";\\nimport {CCIPReader, EIP3668, OffchainLookup} from \\\"./CCIPReader.sol\\\";\\n\\nabstract contract CCIPBatcher is CCIPReader {\\n    /// @notice The batch gateway supplied an incorrect number of responses.\\n    /// @dev Error selector: `0x4a5c31ea`\\n    error InvalidBatchGatewayResponse();\\n\\n    uint256 constant FLAG_OFFCHAIN = 1 << 0; // the lookup reverted `OffchainLookup`\\n    uint256 constant FLAG_CALL_ERROR = 1 << 1; // the initial call or callback reverted\\n    uint256 constant FLAG_BATCH_ERROR = 1 << 2; // `OffchainLookup` failed on the batch gateway\\n    uint256 constant FLAG_EMPTY_RESPONSE = 1 << 3; // the initial call or callback returned `0x`\\n    uint256 constant FLAG_EIP140_BEFORE = 1 << 4; // does not have revert op code\\n    uint256 constant FLAG_EIP140_AFTER = 1 << 5; // has revert op code\\n    uint256 constant FLAG_DONE = 1 << 6; // the lookup has finished processing (private)\\n\\n    uint256 constant FLAGS_ANY_ERROR =\\n        FLAG_CALL_ERROR | FLAG_BATCH_ERROR | FLAG_EMPTY_RESPONSE;\\n    uint256 constant FLAGS_ANY_EIP140 = FLAG_EIP140_BEFORE | FLAG_EIP140_AFTER;\\n\\n    /// @dev An independent `OffchainLookup` session.\\n    struct Lookup {\\n        address target; // contract to call\\n        bytes call; // initial calldata\\n        bytes data; // response or error\\n        uint256 flags; // see: FLAG_*\\n    }\\n\\n    /// @dev A batch gateway session.\\n    struct Batch {\\n        Lookup[] lookups;\\n        string[] gateways;\\n    }\\n\\n    /// @dev Create a batch for a single target with multiple calls.\\n    /// @param target The target contract.\\n    /// @param calls The list of calldata.\\n    /// @param gateways The batch gateway URLs.\\n    function createBatch(\\n        address target,\\n        bytes[] memory calls,\\n        string[] memory gateways\\n    ) internal pure returns (Batch memory) {\\n        Lookup[] memory lookups = new Lookup[](calls.length);\\n        for (uint256 i; i < calls.length; ++i) {\\n            Lookup memory lu = lookups[i];\\n            lu.target = target;\\n            lu.call = calls[i];\\n        }\\n        return Batch(lookups, gateways);\\n    }\\n\\n    /// @dev Use `ccipRead()` to call this function with a batch.\\n    ///      The callback response will be `abi.encode(batch)`.\\n    function ccipBatch(\\n        Batch memory batch\\n    ) external view returns (Batch memory) {\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) != 0) {\\n                continue; // don't call a lookup that's already done\\n            }\\n            if ((lu.flags & FLAGS_ANY_EIP140) == 0) {\\n                uint256 flags = detectEIP140(lu.target)\\n                    ? FLAG_EIP140_AFTER\\n                    : FLAG_EIP140_BEFORE;\\n                for (uint256 j = i; j < batch.lookups.length; ++j) {\\n                    if (batch.lookups[j].target == lu.target) {\\n                        batch.lookups[j].flags |= flags;\\n                    }\\n                }\\n            }\\n            bool unsafe = (lu.flags & FLAG_EIP140_AFTER) == 0;\\n            (bool ok, bytes memory v) = safeCall(!unsafe, lu.target, lu.call);\\n            if (!ok && bytes4(v) == OffchainLookup.selector) {\\n                lu.flags |= FLAG_OFFCHAIN;\\n            } else {\\n                lu.flags |= FLAG_DONE;\\n                if (unsafe && v.length == 0) {\\n                    // unsafe contracts appear the same for throw and unimplemented fallback\\n                    // decision: interpret like an unimplemented function selector response\\n                } else if (!ok) {\\n                    lu.flags |= FLAG_CALL_ERROR;\\n                }\\n                if (v.length == 0) {\\n                    lu.flags |= FLAG_EMPTY_RESPONSE;\\n                }\\n            }\\n            lu.data = v;\\n        }\\n        _revertBatchGateway(batch); // reverts if any offchain\\n        return batch;\\n    }\\n\\n    /// @dev Check if the batch is \\\"done\\\".  If not, revert `OffchainLookup` for batch gateway.\\n    function _revertBatchGateway(Batch memory batch) internal view {\\n        IBatchGateway.Request[] memory requests = new IBatchGateway.Request[](\\n            batch.lookups.length\\n        );\\n        uint256 count;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                requests[count++] = IBatchGateway.Request(\\n                    p.sender,\\n                    p.urls,\\n                    p.callData\\n                );\\n            }\\n        }\\n        if (count > 0) {\\n            assembly {\\n                mstore(requests, count) // truncate to number of offchain requests\\n            }\\n            revert OffchainLookup(\\n                address(this),\\n                batch.gateways,\\n                abi.encodeCall(IBatchGateway.query, (requests)),\\n                this.ccipBatchCallback.selector,\\n                abi.encode(batch)\\n            );\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipBatch()`.\\n    ///      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\\n    /// @param response The response from the batch gateway.\\n    /// @param extraData The contextual data passed from `ccipBatch()`.\\n    /// @return batch The batch where every lookup is \\\"done\\\".\\n    function ccipBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (Batch memory batch) {\\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\\n            response,\\n            (bool[], bytes[])\\n        );\\n        if (failures.length != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        batch = abi.decode(extraData, (Batch));\\n        uint256 expected;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                if (expected < responses.length) {\\n                    bytes memory v = responses[expected];\\n                    if (failures[expected]) {\\n                        lu.flags |= FLAG_DONE | FLAG_BATCH_ERROR;\\n                    } else {\\n                        EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                        bool ok;\\n                        // assumption: unsafe contracts don't revert OffchainLookup()\\n                        (ok, v) = p.sender.staticcall(\\n                            abi.encodeWithSelector(\\n                                p.callbackFunction,\\n                                v,\\n                                p.extraData\\n                            )\\n                        );\\n                        if (ok || bytes4(v) != OffchainLookup.selector) {\\n                            lu.flags |= FLAG_DONE;\\n                            // decision: promote empty response from the callback => call error\\n                            // ie. the initial function was implemented but the callback was not\\n                            // this can be detected via FLAG_OFFCHAIN\\n                            if (!ok || v.length == 0) {\\n                                lu.flags |= FLAG_CALL_ERROR;\\n                            }\\n                            if (v.length == 0) {\\n                                lu.flags |= FLAG_EMPTY_RESPONSE;\\n                            }\\n                        }\\n                    }\\n                    lu.data = v;\\n                }\\n                ++expected;\\n            }\\n        }\\n        if (expected != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        _revertBatchGateway(batch);\\n    }\\n}\\n\",\"keccak256\":\"0x8315d7930568e488eac59ac205e4ed20a3ebf19445358b4218c62a49f2e5ebf6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/CCIPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @author Modified from https://github.com/unruggable-labs/CCIPReader.sol/blob/341576fe7ff2b6e0c93fc08f37740cf6439f5873/contracts/CCIPReader.sol\\n\\n/// MIT License\\n/// Portions Copyright (c) 2025 Unruggable\\n/// Portions Copyright (c) 2025 ENS Labs Ltd\\n\\n/// @dev Instructions:\\n/// 1. inherit this contract\\n/// 2. call `ccipRead()` similar to `staticcall()`\\n/// 3. do not put logic after this invocation\\n/// 4. implement all response logic in callback\\n/// 5. ensure that return type of calling function == callback function\\n\\nimport {EIP3668, OffchainLookup} from \\\"./EIP3668.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\n\\ncontract CCIPReader {\\n    /// @dev Default unsafe call gas (sufficient for legacy ENS resolver profiles).\\n    uint256 constant DEFAULT_UNSAFE_CALL_GAS = 50000;\\n\\n    /// @dev Special-purpose value for identity callback: `f(x) = x`.\\n    bytes4 constant IDENTITY_FUNCTION = bytes4(0);\\n\\n    /// @dev The gas limit for calling functions on unsafe contracts.\\n    uint256 immutable unsafeCallGas;\\n\\n    constructor(uint256 _unsafeCallGas) {\\n        unsafeCallGas = _unsafeCallGas;\\n    }\\n\\n    /// @dev A recursive CCIP-Read session.\\n    struct Context {\\n        address target;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n        bytes4 successCallbackFunction;\\n        bytes4 failureCallbackFunction;\\n        bytes myExtraData;\\n    }\\n\\n    /// @dev Same as `ccipRead()` but the callback function is the identity.\\n    function ccipRead(address target, bytes memory call) internal view {\\n        ccipRead(target, call, IDENTITY_FUNCTION, IDENTITY_FUNCTION, \\\"\\\");\\n    }\\n\\n    /// @dev Performs a CCIP-Read and handles internal recursion.\\n    ///      Reverts `OffchainLookup` if necessary.\\n    ///      Use `IDENTITY_FUNCTION` as the callback function selector for return/revert behavior.\\n    /// @param target The contract address.\\n    /// @param call The calldata to `staticcall()` on `target`.\\n    /// @param successCallbackFunction The function selector of callback on success.\\n    /// @param failureCallbackFunction The function selector of callback on failure.\\n    /// @param extraData The contextual data relayed to callback function.\\n    function ccipRead(\\n        address target,\\n        bytes memory call,\\n        bytes4 successCallbackFunction,\\n        bytes4 failureCallbackFunction,\\n        bytes memory extraData\\n    ) internal view {\\n        // We call the intended function that **could** revert with an `OffchainLookup`\\n        // We destructure the response into an execution status bool and our return bytes\\n        (bool ok, bytes memory v) = safeCall(\\n            detectEIP140(target),\\n            target,\\n            call\\n        );\\n        // IF the function reverted with an `OffchainLookup`\\n        if (!ok && bytes4(v) == OffchainLookup.selector) {\\n            // We decode the response error into a tuple\\n            // tuples allow flexibility noting stack too deep constraints\\n            EIP3668.Params memory p = decodeOffchainLookup(v);\\n            if (p.sender == target) {\\n                // We then wrap the error data in an `OffchainLookup` sent/'owned' by this contract\\n                revert OffchainLookup(\\n                    address(this),\\n                    p.urls,\\n                    p.callData,\\n                    this.ccipReadCallback.selector,\\n                    abi.encode(\\n                        Context(\\n                            target,\\n                            p.callbackFunction,\\n                            p.extraData,\\n                            successCallbackFunction,\\n                            failureCallbackFunction,\\n                            extraData\\n                        )\\n                    )\\n                );\\n            }\\n        }\\n        // IF we have gotten here, the 'real' target does not revert with an `OffchainLookup` error\\n        // figure out what callback to call\\n        bytes4 callbackFunction = ok\\n            ? successCallbackFunction\\n            : failureCallbackFunction;\\n        if (callbackFunction != IDENTITY_FUNCTION) {\\n            // The exit point of this architecture is OUR callback in the 'real'\\n            // We pass through the response to that callback\\n            (ok, v) = address(this).staticcall(\\n                abi.encodeWithSelector(callbackFunction, v, extraData)\\n            );\\n        }\\n        // OR the call to the 'real' target reverts with a different error selector\\n        // OR the call to OUR callback reverts with ANY error selector\\n        if (ok) {\\n            assembly {\\n                return(add(v, 32), mload(v))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(v, 32), mload(v))\\n            }\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipRead()`.\\n    /// @param response The response from offchain.\\n    /// @param extraData The contextual data passed from `ccipRead()`.\\n    /// @dev The return type of this function is polymorphic depending on the caller.\\n    function ccipReadCallback(\\n        bytes memory response,\\n        bytes memory extraData\\n    ) external view {\\n        Context memory ctx = abi.decode(extraData, (Context));\\n        // Since the callback can revert too (but has the same return structure)\\n        // We can reuse the calling infrastructure to call the callback\\n        ccipRead(\\n            ctx.target,\\n            abi.encodeWithSelector(\\n                ctx.callbackFunction,\\n                response,\\n                ctx.extraData\\n            ),\\n            ctx.successCallbackFunction,\\n            ctx.failureCallbackFunction,\\n            ctx.myExtraData\\n        );\\n    }\\n\\n    /// @dev Decode `OffchainLookup` error data into a struct.\\n    /// @param v The error data of the revert.\\n    /// @return p The decoded `OffchainLookup` params.\\n    function decodeOffchainLookup(\\n        bytes memory v\\n    ) internal pure returns (EIP3668.Params memory p) {\\n        p = EIP3668.decode(BytesUtils.substring(v, 4, v.length - 4));\\n    }\\n\\n    /// @dev Determine if `target` uses `revert()` instead of `invalid()`.\\n    //       Assumption: only newer contracts revert `OffchainLookup`.\\n    /// @param target The contract to test.\\n    /// @return safe True if safe to call.\\n    function detectEIP140(address target) internal view returns (bool safe) {\\n        if (target == address(this)) return true;\\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md\\n        assembly {\\n            let G := 5000\\n            let g := gas()\\n            pop(staticcall(G, target, 0, 0, 0, 0))\\n            safe := lt(sub(g, gas()), G)\\n        }\\n    }\\n\\n    /// @dev Same as `staticcall()` but prevents OOG when not `safe`.\\n    function safeCall(\\n        bool safe,\\n        address target,\\n        bytes memory call\\n    ) internal view returns (bool ok, bytes memory v) {\\n        (ok, v) = target.staticcall{gas: safe ? gasleft() : unsafeCallGas}(\\n            call\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xa6f483e89e779385c2b7ea6376d92cd3c05c98f91d1a3c7c43dc7422fe6b014f\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/EIP3668.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev https://eips.ethereum.org/EIPS/eip-3668\\n/// Error selector: `0x556f1830`\\nerror OffchainLookup(\\n    address sender,\\n    string[] urls,\\n    bytes callData,\\n    bytes4 callbackFunction,\\n    bytes extraData\\n);\\n\\n/// @dev Simple library for decoding `OffchainLookup` error data.\\n/// Avoids \\\"stack too deep\\\" issues as the natural decoding consumes 5 variables.\\nlibrary EIP3668 {\\n    /// @dev Struct with members matching `OffchainLookup`.\\n    struct Params {\\n        address sender;\\n        string[] urls;\\n        bytes callData;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n    }\\n\\n    /// @dev Decode an `OffchainLookup` into a struct from the data after the error selector.\\n    function decode(bytes memory v) internal pure returns (Params memory p) {\\n        (p.sender, p.urls, p.callData, p.callbackFunction, p.extraData) = abi\\n            .decode(v, (address, string[], bytes, bytes4, bytes));\\n    }\\n}\\n\",\"keccak256\":\"0x14619de0f3d9f085e6209767b35c2888b8d2af6d787af535f30db7b51e843bf8\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IBatchGateway.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for Batch Gateway Offchain Lookup Protocol.\\n///         https://docs.ens.domains/ensip/21/\\n/// @dev Interface selector: `0xa780bab6`\\ninterface IBatchGateway {\\n    /// @notice An HTTP error occurred.\\n    /// @dev Error selector: `0x01800152`\\n    error HttpError(uint16 status, string message);\\n\\n    /// @dev Information extracted from an `OffchainLookup` revert.\\n    struct Request {\\n        address sender;\\n        string[] urls;\\n        bytes data;\\n    }\\n\\n    /// @notice Perform multiple `OffchainLookup` in parallel.\\n    ///         Callers should enable EIP-3668.\\n    /// @param requests The array of requests to lookup in parallel.\\n    /// @return failures The failure status of the corresponding request.\\n    /// @return responses The response or error data of the corresponding request.\\n    function query(\\n        Request[] memory requests\\n    ) external view returns (bool[] memory failures, bytes[] memory responses);\\n}\\n\",\"keccak256\":\"0xfd7f0c7bdc29fc732ec54da2ebaea241873e55082e484729901811bc9374d6f6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IGatewayProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for shared gateway URLs.\\n/// @dev Interface selector: `0x093a86d3`\\ninterface IGatewayProvider {\\n    /// @notice Get the gateways.\\n    /// @return The gateway URLs.\\n    function gateways() external view returns (string[] memory);\\n}\\n\",\"keccak256\":\"0x7c169843cfb65657a88fb4d5f7ec44612994d7d87cb7b1a67cbfdb18758823e0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/IMulticallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n\\n    function multicallWithNodeCheck(\\n        bytes32,\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x0334202e20bb11995997083d05963f5e8e7ed6194cba494e7f9371ab7bf4e2c3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/ResolverFeatures.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary ResolverFeatures {\\n    /// @notice Implements `resolve(multicall([...]))`.\\n    /// @dev Feature: `0x96b62db8`\\n    bytes4 constant RESOLVE_MULTICALL =\\n        bytes4(keccak256(\\\"eth.ens.resolver.extended.multicall\\\"));\\n\\n    /// @notice Returns the same records independent of name or node.\\n    /// @dev Feature: `0x86fb8da8`\\n    bytes4 constant SINGULAR = bytes4(keccak256(\\\"eth.ens.resolver.singular\\\"));\\n}\\n\",\"keccak256\":\"0x87d131fcbdd7951a17b0a94f7f02470ec3f62c6004cf91c2d2acc54098373be6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the legacy (ETH-only) addr function.\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /// Returns the address associated with an ENS node.\\n    /// @param node The ENS node to query.\\n    /// @return The associated address.\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the new (multicoin) addr function.\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x8da5dd0fc1c5ab4f47e03c23126976a86d4b2dbeac161e70e3af9e2a13330cf0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /// Returns the name associated with an ENS node, for reverse records.\\n    /// Defined in EIP181.\\n    /// @param node The ENS node to query.\\n    /// @return The associated name.\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x3ab986332e0baad7aeb4b426aace3aa1c235be5efff8db4b6f1ce501bcdd9e68\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/AbstractUniversalResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {IUniversalResolver} from \\\"./IUniversalResolver.sol\\\";\\nimport {CCIPBatcher, CCIPReader} from \\\"../ccipRead/CCIPBatcher.sol\\\";\\nimport {IGatewayProvider} from \\\"../ccipRead/IGatewayProvider.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\nimport {ENSIP19, COIN_TYPE_ETH, COIN_TYPE_DEFAULT} from \\\"../utils/ENSIP19.sol\\\";\\nimport {IERC7996} from \\\"../utils/IERC7996.sol\\\";\\nimport {ResolverFeatures} from \\\"../resolvers/ResolverFeatures.sol\\\";\\n\\n// resolver profiles\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {INameResolver} from \\\"../resolvers/profiles/INameResolver.sol\\\";\\nimport {IAddrResolver} from \\\"../resolvers/profiles/IAddrResolver.sol\\\";\\nimport {IAddressResolver} from \\\"../resolvers/profiles/IAddressResolver.sol\\\";\\nimport {IMulticallable} from \\\"../resolvers/IMulticallable.sol\\\";\\n\\nabstract contract AbstractUniversalResolver is\\n    IUniversalResolver,\\n    CCIPBatcher,\\n    ERC165\\n{\\n    /// @dev The default batch gateways.\\n    IGatewayProvider public immutable batchGatewayProvider;\\n\\n    constructor(\\n        IGatewayProvider _batchGatewayProvider\\n    ) CCIPReader(DEFAULT_UNSAFE_CALL_GAS) {\\n        batchGatewayProvider = _batchGatewayProvider;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165) returns (bool) {\\n        return\\n            type(IUniversalResolver).interfaceId == interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc IUniversalResolver\\n    function findResolver(\\n        bytes memory name\\n    ) public view virtual returns (address, bytes32, uint256);\\n\\n    /// @dev A valid resolver and its relevant properties.\\n    struct ResolverInfo {\\n        bytes name; // dns-encoded name (safe to decode)\\n        uint256 offset; // byte offset into name used for resolver\\n        bytes32 node; // namehash(name)\\n        address resolver;\\n        bool extended; // IExtendedResolver\\n    }\\n\\n    /// @dev Returns a valid resolver for `name` or reverts.\\n    /// @param name The name to search.\\n    /// @return info The resolver information.\\n    function requireResolver(\\n        bytes memory name\\n    ) public view returns (ResolverInfo memory info) {\\n        // https://docs.ens.domains/ensip/10\\n        (info.resolver, info.node, info.offset) = findResolver(name);\\n        info.name = name;\\n        _checkResolver(info);\\n    }\\n\\n    /// @dev Asserts that the resolver information is valid.\\n    function _checkResolver(ResolverInfo memory info) internal view {\\n        if (info.resolver == address(0)) {\\n            revert ResolverNotFound(info.name);\\n        } else if (\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                info.resolver,\\n                type(IExtendedResolver).interfaceId\\n            )\\n        ) {\\n            info.extended = true;\\n        } else if (info.offset != 0) {\\n            revert ResolverNotFound(info.name); // immediate resolver requires exact match\\n        } else if (info.resolver.code.length == 0) {\\n            revert ResolverNotContract(info.name, info.resolver);\\n        }\\n    }\\n\\n    /// @notice Same as `resolveWithGateways()` but uses default batch gateways.\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory, address) {\\n        return resolveWithGateways(name, data, batchGatewayProvider.gateways());\\n    }\\n\\n    /// @notice Performs ENS resolution process for the supplied name and resolution data.\\n    ///         Caller should enable EIP-3668.\\n    /// @dev This function executes over multiple steps.\\n    /// @param name The name to resolve, in normalised and DNS-encoded form.\\n    /// @param data The resolution data, as specified in ENSIP-10.\\n    /// @param gateways The list of batch gateway URLs to use.\\n    /// @return result The encoded response for the requested call.\\n    /// @return resolver The address of the resolver that supplied `result`.\\n    function resolveWithGateways(\\n        bytes calldata name,\\n        bytes calldata data,\\n        string[] memory gateways\\n    ) public view returns (bytes memory result, address resolver) {\\n        result;\\n        resolver;\\n        ResolverInfo memory info = requireResolver(name);\\n        _callResolver(\\n            info,\\n            data,\\n            gateways,\\n            this.resolveCallback.selector, // ==> step 2\\n            abi.encode(info.resolver)\\n        );\\n    }\\n\\n    /// @notice Same as `resolveWithGateways()` but uses the supplied resolver.\\n    function resolveWithResolver(\\n        address resolver,\\n        bytes calldata name,\\n        bytes calldata data,\\n        string[] memory gateways\\n    ) external view returns (bytes memory) {\\n        ResolverInfo memory info;\\n        info.name = name;\\n        info.node = NameCoder.namehash(name, 0);\\n        info.resolver = resolver;\\n        _checkResolver(info);\\n        _callResolver(\\n            info,\\n            data,\\n            gateways,\\n            this.resolveCallback.selector, // ==> step 2\\n            abi.encode(resolver) // this value is ignored\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `resolveWithGateways()`.\\n    /// @param response The response from the resolver.\\n    /// @param extraData The contextual data passed from `resolveWith*()`.\\n    function resolveCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external pure returns (bytes memory, address) {\\n        return (response, abi.decode(extraData, (address)));\\n    }\\n\\n    /// @notice Same as `reverseWithGateways()` but uses default batch gateways.\\n    function reverse(\\n        bytes calldata lookupAddress,\\n        uint256 coinType\\n    ) external view returns (string memory, address, address) {\\n        return\\n            reverseWithGateways(\\n                lookupAddress,\\n                coinType,\\n                batchGatewayProvider.gateways()\\n            );\\n    }\\n\\n    struct ReverseArgs {\\n        bytes lookupAddress; // parsed input address\\n        uint256 coinType; // parsed coinType\\n        string[] gateways; // supplied gateways\\n        address resolver; // valid reverse resolver\\n    }\\n\\n    /// @notice Performs ENS reverse resolution for the supplied address and coin type.\\n    ///         Caller should enable EIP-3668.\\n    /// @dev This function executes over multiple steps.\\n    /// @param lookupAddress The input address.\\n    /// @param coinType The coin type.\\n    /// @param gateways The list of batch gateway URLs to use.\\n    /// @return primary The resolved primary name.\\n    /// @return resolver The resolver address for primary name.\\n    /// @return reverseResolver The resolver address for the reverse name.\\n    function reverseWithGateways(\\n        bytes calldata lookupAddress,\\n        uint256 coinType,\\n        string[] memory gateways\\n    )\\n        public\\n        view\\n        returns (\\n            string memory primary,\\n            address resolver,\\n            address reverseResolver\\n        )\\n    {\\n        primary;\\n        resolver;\\n        reverseResolver;\\n        // https://docs.ens.domains/ensip/19\\n        ResolverInfo memory info = requireResolver(\\n            NameCoder.encode(ENSIP19.reverseName(lookupAddress, coinType)) // reverts EmptyAddress\\n        );\\n        _callResolver(\\n            info,\\n            abi.encodeCall(INameResolver.name, (info.node)),\\n            gateways,\\n            this.reverseNameCallback.selector, // ==> step 2\\n            abi.encode(\\n                ReverseArgs(lookupAddress, coinType, gateways, info.resolver)\\n            )\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `reverseWithGateways()`.\\n    /// @param response The abi-encoded `name()` response from the reverse resolver.\\n    /// @param extraData The contextual data passed from `reverseWithGateways()`.\\n    function reverseNameCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (string memory primary, address, address) {\\n        ReverseArgs memory args = abi.decode(extraData, (ReverseArgs));\\n        primary = abi.decode(response, (string));\\n        if (bytes(primary).length == 0) {\\n            return (\\\"\\\", address(0), args.resolver);\\n        }\\n        ResolverInfo memory info = requireResolver(NameCoder.encode(primary));\\n        _callResolver(\\n            info,\\n            args.coinType == COIN_TYPE_ETH\\n                ? abi.encodeCall(IAddrResolver.addr, (info.node))\\n                : abi.encodeCall(\\n                    IAddressResolver.addr,\\n                    (info.node, args.coinType)\\n                ),\\n            args.gateways,\\n            this.reverseAddressCallback.selector, // ==> step 3\\n            abi.encode(args, primary, info.resolver)\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `reverseNameCallback()`.\\n    ///      Reverts `ReverseAddressMismatch`.\\n    /// @param response The abi-encoded `addr()` response from the forward resolver.\\n    /// @param extraData The contextual data passed from `reverseNameCallback()`.\\n    function reverseAddressCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    )\\n        external\\n        pure\\n        returns (\\n            string memory primary,\\n            address resolver,\\n            address reverseResolver\\n        )\\n    {\\n        ReverseArgs memory args;\\n        (args, primary, resolver) = abi.decode(\\n            extraData,\\n            (ReverseArgs, string, address)\\n        );\\n        bytes memory primaryAddress;\\n        if (args.coinType == COIN_TYPE_ETH) {\\n            address addr = abi.decode(response, (address));\\n            primaryAddress = abi.encodePacked(addr);\\n        } else {\\n            primaryAddress = abi.decode(response, (bytes));\\n        }\\n        if (!BytesUtils.equals(args.lookupAddress, primaryAddress)) {\\n            revert ReverseAddressMismatch(primary, primaryAddress);\\n        }\\n        reverseResolver = args.resolver;\\n    }\\n\\n    /// @dev Efficiently call a resolver.\\n    ///      If ENSIP-22 is supported, performs a direct call.\\n    ///      Otherwise, uses the batch gateway.\\n    /// @param info The resolver to call.\\n    /// @param call The resolution calldata.\\n    /// @param gateways The list of batch gateway URLs to use.\\n    /// @param callbackFunction The function selector to call after resolution.\\n    /// @param extraData The contextual data passed to `callbackFunction`.\\n    function _callResolver(\\n        ResolverInfo memory info,\\n        bytes memory call,\\n        string[] memory gateways,\\n        bytes4 callbackFunction,\\n        bytes memory extraData\\n    ) internal view {\\n        bool multi = bytes4(call) == IMulticallable.multicall.selector;\\n        if (\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                info.resolver,\\n                type(IERC7996).interfaceId\\n            ) &&\\n            (!multi ||\\n                (info.extended &&\\n                    IERC7996(info.resolver).supportsFeature(\\n                        ResolverFeatures.RESOLVE_MULTICALL\\n                    )))\\n        ) {\\n            ccipRead(\\n                address(info.resolver),\\n                info.extended\\n                    ? abi.encodeCall(\\n                        IExtendedResolver.resolve,\\n                        (info.name, call)\\n                    )\\n                    : call,\\n                this.resolveDirectCallback.selector,\\n                this.resolveDirectCallbackError.selector,\\n                abi.encode(\\n                    info.extended,\\n                    bytes4(call),\\n                    callbackFunction,\\n                    extraData\\n                )\\n            );\\n        }\\n        bytes[] memory calls;\\n        if (multi) {\\n            calls = abi.decode(\\n                BytesUtils.substring(call, 4, call.length - 4),\\n                (bytes[])\\n            );\\n        } else {\\n            calls = new bytes[](1);\\n            calls[0] = call;\\n        }\\n        if (info.extended) {\\n            for (uint256 i; i < calls.length; ++i) {\\n                calls[i] = abi.encodeCall(\\n                    IExtendedResolver.resolve,\\n                    (info.name, calls[i])\\n                );\\n            }\\n        }\\n        ccipRead(\\n            address(this),\\n            abi.encodeCall(\\n                this.ccipBatch,\\n                (createBatch(info.resolver, calls, gateways))\\n            ),\\n            this.resolveBatchCallback.selector,\\n            IDENTITY_FUNCTION,\\n            abi.encode(info.extended, multi, callbackFunction, extraData)\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `_callResolver()` from calling the resolver successfully.\\n    function resolveDirectCallback(\\n        bytes memory response,\\n        bytes calldata extraData\\n    ) external view {\\n        (\\n            bool extended,\\n            bytes4 callSelector,\\n            bytes4 callbackFunction,\\n            bytes memory extraData_\\n        ) = abi.decode(extraData, (bool, bytes4, bytes4, bytes));\\n        if (response.length == 0) {\\n            revert UnsupportedResolverProfile(callSelector);\\n        }\\n        if (extended) {\\n            response = abi.decode(response, (bytes)); // unwrap resolve()\\n        }\\n        ccipRead(\\n            address(this),\\n            abi.encodeWithSelector(callbackFunction, response, extraData_)\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `_callResolver()` from calling the resolver unsuccessfully.\\n    function resolveDirectCallbackError(\\n        bytes calldata response,\\n        bytes calldata\\n    ) external pure {\\n        _propagateResolverError(response);\\n    }\\n\\n    /// @dev CCIP-Read callback for `_callResolver()` from calling the batch gateway successfully.\\n    function resolveBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view {\\n        Lookup[] memory lookups = abi.decode(response, (Batch)).lookups;\\n        (\\n            bool extended,\\n            bool multi,\\n            bytes4 callbackFunction,\\n            bytes memory extraData_\\n        ) = abi.decode(extraData, (bool, bool, bytes4, bytes));\\n        bytes memory answer;\\n        if (multi) {\\n            bytes[] memory m = new bytes[](lookups.length);\\n            for (uint256 i; i < lookups.length; ++i) {\\n                Lookup memory lu = lookups[i];\\n                bytes memory v = lu.data;\\n                if (extended && (lu.flags & FLAGS_ANY_ERROR) == 0) {\\n                    v = abi.decode(v, (bytes)); // unwrap resolve()\\n                }\\n                m[i] = v;\\n            }\\n            answer = abi.encode(m);\\n        } else {\\n            Lookup memory lu = lookups[0];\\n            answer = lu.data;\\n            if ((lu.flags & FLAG_BATCH_ERROR) != 0) {\\n                assembly {\\n                    revert(add(answer, 32), mload(answer)) // propagate batch gateway errors\\n                }\\n            } else if ((lu.flags & FLAG_CALL_ERROR) != 0) {\\n                _propagateResolverError(answer);\\n            } else if (answer.length == 0) {\\n                revert UnsupportedResolverProfile(bytes4(lu.call));\\n            }\\n            if (extended) {\\n                answer = abi.decode(answer, (bytes)); // unwrap resolve()\\n            }\\n        }\\n        ccipRead(\\n            address(this),\\n            abi.encodeWithSelector(callbackFunction, answer, extraData_)\\n        );\\n    }\\n\\n    /// @dev Propagate the revert from the resolver.\\n    /// @param v The error data.\\n    function _propagateResolverError(bytes memory v) internal pure {\\n        if (bytes4(v) == UnsupportedResolverProfile.selector) {\\n            assembly {\\n                revert(add(v, 32), mload(v))\\n            }\\n        } else {\\n            revert ResolverError(v);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb02ea5b17670d0759a8c2cc80975a5936adfb0c489e02c9a9f0275889f085f6e\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/IUniversalResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for the UniversalResolver.\\n/// @dev Interface selector: `0xcd191b34`\\ninterface IUniversalResolver {\\n    /// @notice A resolver could not be found for the supplied name.\\n    /// @dev Error selector: `0x77209fe8`\\n    error ResolverNotFound(bytes name);\\n\\n    /// @notice The resolver is not a contract.\\n    /// @dev Error selector: `0x1e9535f2`\\n    error ResolverNotContract(bytes name, address resolver);\\n\\n    /// @notice The resolver did not respond.\\n    /// @dev Error selector: `0x7b1c461b`\\n    error UnsupportedResolverProfile(bytes4 selector);\\n\\n    /// @notice The resolver returned an error.\\n    /// @dev Error selector: `0x95c0c752`\\n    error ResolverError(bytes errorData);\\n\\n    /// @notice The resolved address from reverse resolution does not match the supplied address.\\n    /// @dev Error selector: `0xef9c03ce`\\n    error ReverseAddressMismatch(string primary, bytes primaryAddress);\\n\\n    /// @notice An HTTP error occurred on a resolving gateway.\\n    /// @dev Error selector: `0x01800152`\\n    error HttpError(uint16 status, string message);\\n\\n    /// @dev Find the resolver address for `name`.\\n    ///      Does not perform any validity checks on the resolver.\\n    /// @param name The name to search.\\n    /// @return resolver The resolver or `address(0)` if not found.\\n    /// @return node The namehash of `name`.\\n    /// @return offset The offset into `name` corresponding to `resolver`.\\n    function findResolver(\\n        bytes memory name\\n    ) external view returns (address resolver, bytes32 node, uint256 offset);\\n\\n    /// @notice Performs ENS name resolution for the supplied name and resolution data.\\n    /// @notice Caller should enable EIP-3668.\\n    /// @param name The name to resolve, in normalised and DNS-encoded form.\\n    /// @param data The resolution data, as specified in ENSIP-10.\\n    ///             For a multicall, the data should be encoded as `multicall(bytes[])`.\\n    /// @return result The result of the resolution.\\n    ///                For a multicall, the result is encoded as `(bytes[])`.\\n    /// @return resolver The resolver that was used to resolve the name.\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory result, address resolver);\\n\\n    /// @notice Performs ENS reverse resolution for the supplied address and coin type.\\n    /// @notice Caller should enable EIP-3668.\\n    /// @param lookupAddress The address to reverse resolve, in encoded form.\\n    /// @param coinType The coin type to use for the reverse resolution.\\n    ///                 For ETH, this is 60.\\n    ///                 For other EVM chains, coinType is calculated as `0x80000000 | chainId`.\\n    /// @return primary The reverse resolution result.\\n    /// @return resolver The resolver that was used to resolve the name.\\n    /// @return reverseResolver The resolver that was used to resolve the reverse name.\\n    function reverse(\\n        bytes calldata lookupAddress,\\n        uint256 coinType\\n    )\\n        external\\n        view\\n        returns (\\n            string memory primary,\\n            address resolver,\\n            address reverseResolver\\n        );\\n}\\n\",\"keccak256\":\"0x36b8a75295e7b74dff3d890e3ee19459eca878c597b791ebd726e638696e48ee\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/ENSIP19.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nuint32 constant CHAIN_ID_ETH = 1;\\n\\nuint256 constant COIN_TYPE_ETH = 60;\\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\\n\\nstring constant SLUG_ETH = \\\"addr\\\"; // <=> COIN_TYPE_ETH\\nstring constant SLUG_DEFAULT = \\\"default\\\"; // <=> COIN_TYPE_DEFAULT\\nstring constant TLD_REVERSE = \\\"reverse\\\";\\n\\n/// @dev Library for generating reverse names according to ENSIP-19.\\n/// https://docs.ens.domains/ensip/19\\nlibrary ENSIP19 {\\n    /// @dev The supplied address was `0x`.\\n    ///      Error selector: `0x7138356f`\\n    error EmptyAddress();\\n\\n    /// @dev Extract Chain ID from `coinType`.\\n    /// @param coinType The coin type.\\n    /// @return The Chain ID or 0 if non-EVM Chain.\\n    function chainFromCoinType(\\n        uint256 coinType\\n    ) internal pure returns (uint32) {\\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\\n        coinType ^= COIN_TYPE_DEFAULT;\\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\\n    }\\n\\n    /// @dev Determine if Coin Type is for an EVM address.\\n    /// @param coinType The coin type.\\n    /// @return True if coin type represents an EVM address.\\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\\n    }\\n\\n    /// @dev Generate Reverse Name from Address + Coin Type.\\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\\n    /// @param addressBytes The input address.\\n    /// @param coinType The coin type.\\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\\n    function reverseName(\\n        bytes memory addressBytes,\\n        uint256 coinType\\n    ) internal pure returns (string memory) {\\n        if (addressBytes.length == 0) {\\n            revert EmptyAddress();\\n        }\\n        return\\n            string(\\n                abi.encodePacked(\\n                    HexUtils.bytesToHex(addressBytes),\\n                    bytes1(\\\".\\\"),\\n                    coinType == COIN_TYPE_ETH\\n                        ? SLUG_ETH\\n                        : coinType == COIN_TYPE_DEFAULT\\n                            ? SLUG_DEFAULT\\n                            : HexUtils.unpaddedUintToHex(coinType, true),\\n                    bytes1(\\\".\\\"),\\n                    TLD_REVERSE\\n                )\\n            );\\n    }\\n\\n    /// @dev Parse Reverse Name into Address + Coin Type.\\n    ///      Matches: `/^[0-9a-fA-F]+\\\\.([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @return addressBytes The address or empty if invalid.\\n    /// @return coinType The coin type.\\n    function parse(\\n        bytes memory name\\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\\n        bool valid;\\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\\n        if (!valid || addressBytes.length == 0) return (\\\"\\\", 0); // addressBytes not 1+ hex\\n        (valid, coinType) = parseNamespace(name, offset);\\n        if (!valid) return (\\\"\\\", 0); // invalid namespace\\n    }\\n\\n    /// @dev Parse Reverse Namespace into Coin Type.\\n    ///      Matches: `/^([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset to begin parsing.\\n    /// @return valid True if a valid reverse namespace.\\n    /// @return coinType The coin type.\\n    function parseNamespace(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bool valid, uint256 coinType) {\\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\\n            name,\\n            offset\\n        );\\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\\n            coinType = COIN_TYPE_ETH;\\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\\n            coinType = COIN_TYPE_DEFAULT;\\n        } else if (labelHash == bytes32(0)) {\\n            return (false, 0); // no slug\\n        } else {\\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\\n                name,\\n                1 + offset,\\n                offsetTLD\\n            );\\n            if (!validHex) return (false, 0); // invalid coinType or too long\\n            coinType = uint256(word);\\n        }\\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\\n        (labelHash, ) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\\n        valid = true;\\n    }\\n}\\n\",\"keccak256\":\"0xd1af09b014028de4c50489bd58ae424273180bb96d95353d8eefd14845f31824\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary HexUtils {\\n    /// @dev Convert `hexString[off:end]` to `bytes32`.\\n    ///      Accepts 0-64 hex-chars.\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return word The parsed bytes32.\\n    /// @return valid True if the parse was successful.\\n    function hexStringToBytes32(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes32 word, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        if (nibbles > 64 || end > hexString.length) {\\n            return (bytes32(0), false); // too large or out of bounds\\n        }\\n        uint256 src;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n        }\\n        valid = unsafeBytes(src, 0, nibbles);\\n        assembly {\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\n            word := shr(shl(3, pad), mload(0)) // right align\\n        }\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `address`.\\n    ///      Accepts exactly 40 hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return addr The parsed address.\\n    /// @return valid True if the parse was successful.\\n    function hexToAddress(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (address addr, bool valid) {\\n        if (off + 40 != end) return (address(0), false); // wrong length\\n        bytes32 word;\\n        (word, valid) = hexStringToBytes32(hexString, off, end);\\n        addr = address(uint160(uint256(word)));\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `bytes`.\\n    ///      Accepts 0+ hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return v The parsed bytes.\\n    /// @return valid True if the parse was successful.\\n    function hexToBytes(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes memory v, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        v = new bytes((1 + nibbles) >> 1); // round up\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n            dst := add(v, 32)\\n        }\\n        valid = unsafeBytes(src, dst, nibbles);\\n    }\\n\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\n    ///      Matches: `/^[0-9a-f]*$/i`.\\n    /// @param src The memory offset of first hex-char of input.\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\n    /// @param nibbles The number of hex-chars to convert.\\n    /// @return valid True if all characters were hex.\\n    function unsafeBytes(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure returns (bool valid) {\\n        assembly {\\n            function getHex(c, i) -> ascii {\\n                c := byte(i, c)\\n                // chars 48-57: 0-9\\n                if and(gt(c, 47), lt(c, 58)) {\\n                    ascii := sub(c, 48)\\n                    leave\\n                }\\n                // chars 65-70: A-F\\n                if and(gt(c, 64), lt(c, 71)) {\\n                    ascii := add(sub(c, 65), 10)\\n                    leave\\n                }\\n                // chars 97-102: a-f\\n                if and(gt(c, 96), lt(c, 103)) {\\n                    ascii := add(sub(c, 97), 10)\\n                    leave\\n                }\\n                // invalid char\\n                ascii := 0x100\\n            }\\n            valid := true\\n            let end := add(src, nibbles)\\n            if and(nibbles, 1) {\\n                let b := getHex(mload(src), 0) // \\\"f\\\" -> 15\\n                mstore8(dst, b) // write ascii byte\\n                src := add(src, 1) // update pointers\\n                dst := add(dst, 1)\\n                if gt(b, 255) {\\n                    valid := false\\n                    src := end // terminate loop\\n                }\\n            }\\n            // prettier-ignore\\n            for {} lt(src, end) {\\n                src := add(src, 2) // 2 nibbles\\n                dst := add(dst, 1) // per byte\\n            } {\\n                let word := mload(src) // read word (left aligned)\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\"ff\\\" -> 255\\n                if gt(b, 255) {\\n                    valid := false\\n                    break\\n                }\\n                mstore8(dst, b) // write ascii byte\\n            }\\n        }\\n    }\\n\\n    /// @dev Format `address` as a hex string.\\n    /// @param addr The address to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function addressToHex(\\n        address addr\\n    ) internal pure returns (string memory hexString) {\\n        // return bytesToHex(abi.encodePacked(addr));\\n        hexString = new string(40);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, addr)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(12, dst, 40);\\n    }\\n\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\n    /// * unpaddedUintToHex(0, true)  = \\\"0\\\"\\n    /// * unpaddedUintToHex(1, true)  = \\\"1\\\"\\n    /// * unpaddedUintToHex(0, false) = \\\"00\\\"\\n    /// * unpaddedUintToHex(1, false) = \\\"01\\\"\\n    /// @param value The number to format.\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\n    function unpaddedUintToHex(\\n        uint256 value,\\n        bool dropZeroNibble\\n    ) internal pure returns (string memory hexString) {\\n        uint256 temp = value;\\n        uint256 shift;\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\n            if (temp < (1 << b)) {\\n                shift += b; // number of zero upper bits\\n            } else {\\n                temp >>= b; // shift away lower half\\n            }\\n        }\\n        if (dropZeroNibble && temp < 16) shift += 4;\\n        uint256 nibbles = 64 - (shift >> 2);\\n        hexString = new string(nibbles);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, shl(shift, value)) // left-align\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(0, dst, nibbles);\\n    }\\n\\n    /// @dev Format `bytes` as a hex string.\\n    /// @param v The bytes to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function bytesToHex(\\n        bytes memory v\\n    ) internal pure returns (string memory hexString) {\\n        uint256 nibbles = v.length << 1;\\n        hexString = new string(nibbles);\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(v, 32)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(src, dst, nibbles);\\n    }\\n\\n    /// @dev Converts arbitrary memory to a hex string.\\n    /// @param src The memory offset of first nibble of input.\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\n    function unsafeHex(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure {\\n        unchecked {\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(src)\\n                }\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\"a\\\" - 10) => 0x57\\n                    assembly {\\n                        mstore8(dst, b)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab784cab15b7a06154be3555edf0d25bcdad8e6bf116aa2016119a233875b02b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/IERC7996.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for expressing contract features not visible from the ABI.\\n/// @dev Interface selector: `0x582de3e7`\\ninterface IERC7996 {\\n    /// @notice Check if a feature is supported.\\n    /// @param featureId The feature identifier.\\n    /// @return `true` if the feature is supported by the contract.\\n    function supportsFeature(bytes4 featureId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf499a48e4e879ec7775f375d2cb5af047720ab6ae4b6f89a40a578c4e0f51631\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5a08ad61f4e82b8a3323562661a86fb10b10190848073fdc13d4ac43710ffba5\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the zero address.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1d7a05b3219532ea5ece50a80cf390cac9109dc74e07763adfa463ab5a3af0dc\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"project/src/erc1155/interfaces/IERC1155Singleton.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IERC1155Singleton is IERC1155 {\\n    function ownerOf(uint256 id) external view returns (address owner);\\n}\\n\",\"keccak256\":\"0xbfa4f4f1da56c42a6e878895cbcfc50d0d612ca9d75dda04c6df1ca0fdb72494\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155Singleton} from \\\"../../erc1155/interfaces/IERC1155Singleton.sol\\\";\\n\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\ninterface IRegistry is IERC1155Singleton {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Events\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev SHOULD be emitted when a new label is registered\\n    event NameRegistered(\\n        uint256 indexed tokenId,\\n        string label,\\n        uint64 expiry,\\n        address registeredBy\\n    );\\n\\n    /// @notice Expiry was changed.\\n    /// @dev Error selector: `0x`\\n    event ExpiryUpdated(uint256 indexed tokenId, uint64 newExpiry, address changedBy);\\n\\n    /// @notice Subregistry was changed.\\n    event SubregistryUpdated(uint256 indexed tokenId, IRegistry subregistry);\\n\\n    /// @notice Resolver was changed.\\n    event ResolverUpdated(uint256 indexed tokenId, address resolver);\\n\\n    /// @notice Token was regenerated with a new token ID.\\n    ///         This occurs when roles are granted or revoked to maintain ERC1155 compliance.\\n    event TokenRegenerated(\\n        uint256 indexed oldTokenId,\\n        uint256 indexed newTokenId,\\n        uint256 resource\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Fetches the registry for a subdomain.\\n     * @param label The label to resolve.\\n     * @return The address of the registry for this subdomain, or `address(0)` if none exists.\\n     */\\n    function getSubregistry(string calldata label) external view returns (IRegistry);\\n\\n    /**\\n     * @dev Fetches the resolver responsible for the specified label.\\n     * @param label The label to fetch a resolver for.\\n     * @return resolver The address of a resolver responsible for this name, or `address(0)` if none exists.\\n     */\\n    function getResolver(string calldata label) external view returns (address);\\n}\\n\",\"keccak256\":\"0xc3c7b964bbaadd35412ce44163ab335f802ac9b5f19d72b0fbb64bf772f63634\",\"license\":\"MIT\"},\"project/src/universalResolver/UniversalResolverV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {\\n    AbstractUniversalResolver,\\n    IGatewayProvider\\n} from \\\"@ens/contracts/universalResolver/AbstractUniversalResolver.sol\\\";\\n\\nimport {LibRegistry, IRegistry} from \\\"./libraries/LibRegistry.sol\\\";\\n\\ncontract UniversalResolverV2 is AbstractUniversalResolver {\\n    IRegistry public immutable ROOT_REGISTRY;\\n\\n    constructor(\\n        IRegistry root,\\n        IGatewayProvider batchGatewayProvider\\n    ) AbstractUniversalResolver(batchGatewayProvider) {\\n        ROOT_REGISTRY = root;\\n    }\\n\\n    /// @notice Find all registries in the ancestry of `name`.\\n    /// * `findRegistries(\\\"\\\") = [<root>]`\\n    /// * `findRegistries(\\\"eth\\\") = [<eth>, <root>]`\\n    /// * `findRegistries(\\\"nick.eth\\\") = [<nick>, <eth>, <root>]`\\n    /// * `findRegistries(\\\"sub.nick.eth\\\") = [null, <nick>, <eth>, <root>]`\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return Array of registries in label-order.\\n    function findRegistries(bytes calldata name) external view returns (IRegistry[] memory) {\\n        return LibRegistry.findRegistries(ROOT_REGISTRY, name, 0);\\n    }\\n\\n    /// @inheritdoc AbstractUniversalResolver\\n    function findResolver(\\n        bytes memory name\\n    ) public view override returns (address resolver, bytes32 node, uint256 offset) {\\n        (, resolver, node, offset) = LibRegistry.findResolver(ROOT_REGISTRY, name, 0);\\n    }\\n}\\n\",\"keccak256\":\"0xf6017114a5511f734adc43d2aef4ed091ea4c3ae174e9c8543147e45f2465b20\",\"license\":\"MIT\"},\"project/src/universalResolver/libraries/LibRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.24;\\n\\nimport {NameCoder} from \\\"@ens/contracts/utils/NameCoder.sol\\\";\\n\\nimport {IRegistry} from \\\"../../registry/interfaces/IRegistry.sol\\\";\\n\\nlibrary LibRegistry {\\n    /// @dev Find the resolver address for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    ///\\n    /// @return exactRegistry The exact registry or null if not exact.\\n    /// @return resolver The resolver or null if not found.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return resolverOffset The offset into `name` corresponding to `resolver`.\\n    function findResolver(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    )\\n        internal\\n        view\\n        returns (IRegistry exactRegistry, address resolver, bytes32 node, uint256 resolverOffset)\\n    {\\n        // supply <root> if end of name\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash == bytes32(0)) {\\n            return (rootRegistry, address(0), bytes32(0), offset);\\n        }\\n        // lookup parent name\\n        (exactRegistry, resolver, node, resolverOffset) = findResolver(rootRegistry, name, next);\\n        // if there was a parent registry...\\n        if (address(exactRegistry) != address(0)) {\\n            (string memory label, ) = NameCoder.extractLabel(name, offset);\\n            // remember the resolver (if it exists)\\n            address res = exactRegistry.getResolver(label);\\n            if (res != address(0)) {\\n                resolver = res;\\n                resolverOffset = offset;\\n            }\\n            exactRegistry = exactRegistry.getSubregistry(label);\\n        }\\n        node = NameCoder.namehash(node, labelHash); // update namehash\\n    }\\n\\n    /// @notice Find (registry, resolver) for `name[offset:]` starting from\\n    ///         (parentRegistry, parentRegistry) for `name[:parentOffset]`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    /// @param parentOffset The offset into `name` to use parent values.\\n    /// @param parentRegistry The registry at `name[length:]`.\\n    /// @param parentResolver The resolver at `name[length:]`.\\n    ///\\n    /// @return registry The exact registry or null if not exact.\\n    /// @return resolver The resolver or null if not found.\\n    function findResolverFromParent(\\n        bytes memory name,\\n        uint256 offset,\\n        uint256 parentOffset,\\n        IRegistry parentRegistry,\\n        address parentResolver\\n    ) internal view returns (IRegistry registry, address resolver) {\\n        if (offset > parentOffset) {\\n            revert NameCoder.DNSDecodingFailed(name);\\n        } else if (offset == parentOffset) {\\n            return (parentRegistry, parentResolver);\\n        } else {\\n            string memory label;\\n            (label, offset) = NameCoder.extractLabel(name, offset);\\n            (registry, resolver) = findResolverFromParent(\\n                name,\\n                offset,\\n                parentOffset,\\n                parentRegistry,\\n                parentResolver\\n            );\\n            if (address(registry) != address(0)) {\\n                address res = registry.getResolver(label);\\n                if (res != address(0)) {\\n                    resolver = res;\\n                }\\n                registry = registry.getSubregistry(label);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the exact registry for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    ///\\n    /// @return exactRegistry The exact registry or null if not found.\\n    function findExactRegistry(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry exactRegistry) {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash == bytes32(0)) {\\n            return rootRegistry;\\n        }\\n        IRegistry parent = findExactRegistry(rootRegistry, name, next);\\n        if (address(parent) != address(0)) {\\n            (string memory label, ) = NameCoder.extractLabel(name, offset);\\n            exactRegistry = parent.getSubregistry(label);\\n        }\\n    }\\n\\n    /// @dev Find the parent registry for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    ///\\n    /// @return parentRegistry The parent registry or null if not found.\\n    function findParentRegistry(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry parentRegistry) {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            parentRegistry = findExactRegistry(rootRegistry, name, next);\\n        }\\n    }\\n\\n    /// @notice Find all registries in the ancestry of `name`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to begin the search.\\n    ///\\n    /// @return registries Array of registries in label-order.\\n    function findRegistries(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry[] memory registries) {\\n        registries = new IRegistry[](1 + NameCoder.countLabels(name, offset));\\n        registries[registries.length - 1] = rootRegistry;\\n        _findRegistries(name, offset, registries, 0);\\n    }\\n\\n    /// @dev Recursive function for building ancestory.\\n    function _findRegistries(\\n        bytes memory name,\\n        uint256 offset,\\n        IRegistry[] memory registries,\\n        uint256 index\\n    ) private view returns (IRegistry registry) {\\n        (string memory label, uint256 nextOffset) = NameCoder.extractLabel(name, offset);\\n        if (bytes(label).length == 0) {\\n            return registries[registries.length - 1];\\n        }\\n        registry = _findRegistries(name, nextOffset, registries, index + 1);\\n        if (address(registry) != address(0)) {\\n            registry = registry.getSubregistry(label);\\n            registries[index] = registry;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd80793afdb36a5f7a2c7556a0dbcc1a4fefcdfb89357579b77cd31390fd1988d\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "HttpError(uint16,string)": [
        {
          "notice": "An HTTP error occurred on a resolving gateway."
        }
      ],
      "InvalidBatchGatewayResponse()": [
        {
          "notice": "The batch gateway supplied an incorrect number of responses."
        }
      ],
      "ResolverError(bytes)": [
        {
          "notice": "The resolver returned an error."
        }
      ],
      "ResolverNotContract(bytes,address)": [
        {
          "notice": "The resolver is not a contract."
        }
      ],
      "ResolverNotFound(bytes)": [
        {
          "notice": "A resolver could not be found for the supplied name."
        }
      ],
      "ReverseAddressMismatch(string,bytes)": [
        {
          "notice": "The resolved address from reverse resolution does not match the supplied address."
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "notice": "The resolver did not respond."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "findRegistries(bytes)": {
        "notice": "Find all registries in the ancestry of `name`. * `findRegistries(\"\") = [<root>]` * `findRegistries(\"eth\") = [<eth>, <root>]` * `findRegistries(\"nick.eth\") = [<nick>, <eth>, <root>]` * `findRegistries(\"sub.nick.eth\") = [null, <nick>, <eth>, <root>]`"
      },
      "resolve(bytes,bytes)": {
        "notice": "Same as `resolveWithGateways()` but uses default batch gateways."
      },
      "resolveWithGateways(bytes,bytes,string[])": {
        "notice": "Performs ENS resolution process for the supplied name and resolution data.         Caller should enable EIP-3668."
      },
      "resolveWithResolver(address,bytes,bytes,string[])": {
        "notice": "Same as `resolveWithGateways()` but uses the supplied resolver."
      },
      "reverse(bytes,uint256)": {
        "notice": "Same as `reverseWithGateways()` but uses default batch gateways."
      },
      "reverseWithGateways(bytes,uint256,string[])": {
        "notice": "Performs ENS reverse resolution for the supplied address and coin type.         Caller should enable EIP-3668."
      }
    },
    "version": 1
  },
  "argsData": "0x000000000000000000000000610178da211fef7d417bc0e6fed39f05609ad788000000000000000000000000dc64a140aa3e981100a9beca4e685f962f0cf6c9",
  "transaction": {
    "hash": "0x7b2c9f8956d9dd890c2ee50350465d5bc0aac58180972274cdc1a66eab032534",
    "nonce": "0x3e",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x9400166b3bf61c8c33eaa3ba93100fea0334bc39efb2c515a0f8110006e89b48",
    "blockNumber": "0x49",
    "transactionIndex": "0x0"
  }
}
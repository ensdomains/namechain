{
  "address": "0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "key",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "sig",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "RSASHA1Algorithm",
  "sourceName": "lib/ens-contracts/contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol",
  "bytecode": "0x6080604052348015600e575f80fd5b50610b908061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063de8f50a11461002d575b5f80fd5b61004061003b3660046109f1565b610054565b604051901515815260200160405180910390f35b5f6060805f61009c60048b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092939250506102f39050565b60ff1690508015610166576100f060058261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092949392505061032b9050565b925061015f610100826005610a98565b61ffff908116906005906101169085168d610aba565b6101209190610aba565b8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092949392505061032b9050565b915061021d565b6101a960058b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092939250506103879050565b90506101f460078261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092949392505061032b9050565b925061021a610204826007610a98565b61ffff908116906007906101169085168d610aba565b91505b5f606061026084868a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506103a392505050565b90925090508180156102e357506102856014825161027e9190610aba565b82906103bd565b6bffffffffffffffffffffffff19166102d28b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506103d992505050565b6bffffffffffffffffffffffff1916145b9c9b505050505050505050505050565b5f61030883610303846001610acd565b610841565b82828151811061031a5761031a610ae0565b016020015160f81c90505b92915050565b60608167ffffffffffffffff81111561034657610346610af4565b6040519080825280601f01601f191660200182016040528015610370576020820181803683370190505b5090506103808484835f86610896565b9392505050565b5f61039783610303846002610acd565b50016020015160f01c90565b5f60606103b18385876108ce565b91509150935093915050565b5f6103cd83610303846014610acd565b50016014015160601b90565b5f6040518251602084019350604067ffffffffffffffc06001830116016009828203106001810361040b576040820191505b50776745230100efcdab890098badcfe001032547600c3d2e1f061045b565b5f8383101561038057508082015192829003926020841015610380575f1960208590036101000a0119169392505050565b5f5b828110156107c15761047084828961042a565b855261048084602083018961042a565b60208601526040818503106001810361049c5760808286038701535b50604083038114600181036104b957602086018051600887021790525b5060405b608081101561054157858101603f19810151603719820151601f19830151600b198401516002911891909218189081027ffffffffefffffffefffffffefffffffefffffffefffffffefffffffefffffffe1663800000009091047c010000000100000001000000010000000100000001000000010000000116179052600c016104bd565b5060805b6101408110156105ca57858101607f19810151606f19820151603f198301516017198401516004911891909218189081027ffffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffc1663400000009091047c030000000300000003000000030000000300000003000000030000000316179052601801610545565b50815f805f5b60508110156107975760148104801561060057600181146106295760028114610650576003811461067c5761069f565b650100000000008504600160501b86048118600160781b870416189350635a827999925061069f565b650100000000008504600160781b8604600160501b870418189350636ed9eba1925061069f565b600160501b8504600160781b8604818117650100000000008804169116179350638f1bbcdc925061069f565b650100000000008504600160781b8604600160501b87041818935063ca62c1d692505b50601f770800000000000000000000000000000000000000000000008504168063ffffffe073080000000000000000000000000000000000000087041617905080840190508063ffffffff86160190508083019050807c0100000000000000000000000000000000000000000000000000000000600484028c01510401905074010000000000000000000000000000000000000000810265010000000000860417945050600160501b633fffffff6a040000000000000000000086041663c00000006604000000000000870416170277ffffffff00ffffffff000000000000ffffffff00ffffffff85161793506001810190506105d0565b5050509190910177ffffffff00ffffffff00ffffffff00ffffffff00ffffffff169060400161045d565b506c0100000000000000000000000063ffffffff821667ffffffff000000006101008404166bffffffff0000000000000000620100008504166fffffffff000000000000000000000000630100000086041673ffffffff000000000000000000000000000000006401000000008704161717171702945050505050919050565b81518111156108925781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610889918391600401918252602082015260400190565b60405180910390fd5b5050565b6108a4856103038387610acd565b6108b2836103038385610acd565b6108c782602085010185602088010183610963565b5050505050565b5f60605f8551855185518888886040516020016108f096959493929190610b1f565b6040516020818303038152906040529050835167ffffffffffffffff81111561091b5761091b610af4565b6040519080825280601f01601f191660200182016040528015610945576020820181803683370190505b50915083516020830182516020840160055afa925050935093915050565b5b601f811115610984578151835260209283019290910190601f1901610964565b80156109a757815183516001602084900360031b1b5f1901801990921691161783525b505050565b5f8083601f8401126109bc575f80fd5b50813567ffffffffffffffff8111156109d3575f80fd5b6020830191508360208285010111156109ea575f80fd5b9250929050565b5f805f805f8060608789031215610a06575f80fd5b863567ffffffffffffffff80821115610a1d575f80fd5b610a298a838b016109ac565b90985096506020890135915080821115610a41575f80fd5b610a4d8a838b016109ac565b90965094506040890135915080821115610a65575f80fd5b50610a7289828a016109ac565b979a9699509497509295939492505050565b634e487b7160e01b5f52601160045260245ffd5b61ffff818116838216019080821115610ab357610ab3610a84565b5092915050565b8181038181111561032557610325610a84565b8082018082111561032557610325610a84565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b5f81518060208401855e5f93019283525090919050565b8681528560208201528460408201525f610b4e610b48610b426060850188610b08565b86610b08565b84610b08565b9897505050505050505056fea2646970667358221220e639b1850bdcbb2e55efd08191446473d419e3108c513156f26cabdda438eb5c64736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063de8f50a11461002d575b5f80fd5b61004061003b3660046109f1565b610054565b604051901515815260200160405180910390f35b5f6060805f61009c60048b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092939250506102f39050565b60ff1690508015610166576100f060058261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092949392505061032b9050565b925061015f610100826005610a98565b61ffff908116906005906101169085168d610aba565b6101209190610aba565b8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092949392505061032b9050565b915061021d565b6101a960058b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092939250506103879050565b90506101f460078261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525092949392505061032b9050565b925061021a610204826007610a98565b61ffff908116906007906101169085168d610aba565b91505b5f606061026084868a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506103a392505050565b90925090508180156102e357506102856014825161027e9190610aba565b82906103bd565b6bffffffffffffffffffffffff19166102d28b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506103d992505050565b6bffffffffffffffffffffffff1916145b9c9b505050505050505050505050565b5f61030883610303846001610acd565b610841565b82828151811061031a5761031a610ae0565b016020015160f81c90505b92915050565b60608167ffffffffffffffff81111561034657610346610af4565b6040519080825280601f01601f191660200182016040528015610370576020820181803683370190505b5090506103808484835f86610896565b9392505050565b5f61039783610303846002610acd565b50016020015160f01c90565b5f60606103b18385876108ce565b91509150935093915050565b5f6103cd83610303846014610acd565b50016014015160601b90565b5f6040518251602084019350604067ffffffffffffffc06001830116016009828203106001810361040b576040820191505b50776745230100efcdab890098badcfe001032547600c3d2e1f061045b565b5f8383101561038057508082015192829003926020841015610380575f1960208590036101000a0119169392505050565b5f5b828110156107c15761047084828961042a565b855261048084602083018961042a565b60208601526040818503106001810361049c5760808286038701535b50604083038114600181036104b957602086018051600887021790525b5060405b608081101561054157858101603f19810151603719820151601f19830151600b198401516002911891909218189081027ffffffffefffffffefffffffefffffffefffffffefffffffefffffffefffffffe1663800000009091047c010000000100000001000000010000000100000001000000010000000116179052600c016104bd565b5060805b6101408110156105ca57858101607f19810151606f19820151603f198301516017198401516004911891909218189081027ffffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffc1663400000009091047c030000000300000003000000030000000300000003000000030000000316179052601801610545565b50815f805f5b60508110156107975760148104801561060057600181146106295760028114610650576003811461067c5761069f565b650100000000008504600160501b86048118600160781b870416189350635a827999925061069f565b650100000000008504600160781b8604600160501b870418189350636ed9eba1925061069f565b600160501b8504600160781b8604818117650100000000008804169116179350638f1bbcdc925061069f565b650100000000008504600160781b8604600160501b87041818935063ca62c1d692505b50601f770800000000000000000000000000000000000000000000008504168063ffffffe073080000000000000000000000000000000000000087041617905080840190508063ffffffff86160190508083019050807c0100000000000000000000000000000000000000000000000000000000600484028c01510401905074010000000000000000000000000000000000000000810265010000000000860417945050600160501b633fffffff6a040000000000000000000086041663c00000006604000000000000870416170277ffffffff00ffffffff000000000000ffffffff00ffffffff85161793506001810190506105d0565b5050509190910177ffffffff00ffffffff00ffffffff00ffffffff00ffffffff169060400161045d565b506c0100000000000000000000000063ffffffff821667ffffffff000000006101008404166bffffffff0000000000000000620100008504166fffffffff000000000000000000000000630100000086041673ffffffff000000000000000000000000000000006401000000008704161717171702945050505050919050565b81518111156108925781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610889918391600401918252602082015260400190565b60405180910390fd5b5050565b6108a4856103038387610acd565b6108b2836103038385610acd565b6108c782602085010185602088010183610963565b5050505050565b5f60605f8551855185518888886040516020016108f096959493929190610b1f565b6040516020818303038152906040529050835167ffffffffffffffff81111561091b5761091b610af4565b6040519080825280601f01601f191660200182016040528015610945576020820181803683370190505b50915083516020830182516020840160055afa925050935093915050565b5b601f811115610984578151835260209283019290910190601f1901610964565b80156109a757815183516001602084900360031b1b5f1901801990921691161783525b505050565b5f8083601f8401126109bc575f80fd5b50813567ffffffffffffffff8111156109d3575f80fd5b6020830191508360208285010111156109ea575f80fd5b9250929050565b5f805f805f8060608789031215610a06575f80fd5b863567ffffffffffffffff80821115610a1d575f80fd5b610a298a838b016109ac565b90985096506020890135915080821115610a41575f80fd5b610a4d8a838b016109ac565b90965094506040890135915080821115610a65575f80fd5b50610a7289828a016109ac565b979a9699509497509295939492505050565b634e487b7160e01b5f52601160045260245ffd5b61ffff818116838216019080821115610ab357610ab3610a84565b5092915050565b8181038181111561032557610325610a84565b8082018082111561032557610325610a84565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b5f81518060208401855e5f93019283525090919050565b8681528560208201528460408201525f610b4e610b48610b426060850188610b08565b86610b08565b84610b08565b9897505050505050505056fea2646970667358221220e639b1850bdcbb2e55efd08191446473d419e3108c513156f26cabdda438eb5c64736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {},
  "inputSourceName": "project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol",
  "devdoc": {
    "details": "Implements the DNSSEC RSASHA1 algorithm.",
    "errors": {
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "592000",
        "executionCost": "623",
        "totalCost": "592623"
      },
      "external": {
        "verify(bytes,bytes,bytes)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the DNSSEC RSASHA1 algorithm.\",\"errors\":{\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol\":\"RSASHA1Algorithm\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@ensdomains/solsha1/contracts/=project/lib/solsha1/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts-v5/=project/lib/openzeppelin-contracts/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/ens-contracts/:@unruggable/gateways/=project/lib/unruggable-gateways/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\",\"project/test/mocks/v1/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/// @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\ninterface Algorithm {\\n    /// @dev Verifies a signature.\\n    /// @param key The public key to verify with.\\n    /// @param data The signed data to verify.\\n    /// @param signature The signature to verify.\\n    /// @return True iff the signature is valid.\\n    function verify(\\n        bytes calldata key,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xbcbdc06d72b64903e733e7ddfbf59c35c984c3eb0022baacab12c97292cc13df\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary ModexpPrecompile {\\n    /// @dev Computes (base ^ exponent) % modulus over big numbers.\\n    function modexp(\\n        bytes memory base,\\n        bytes memory exponent,\\n        bytes memory modulus\\n    ) internal view returns (bool success, bytes memory output) {\\n        bytes memory input = abi.encodePacked(\\n            uint256(base.length),\\n            uint256(exponent.length),\\n            uint256(modulus.length),\\n            base,\\n            exponent,\\n            modulus\\n        );\\n\\n        output = new bytes(modulus.length);\\n\\n        assembly {\\n            success := staticcall(\\n                gas(),\\n                5,\\n                add(input, 32),\\n                mload(input),\\n                add(output, 32),\\n                mload(modulus)\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x06457e4fc1eda1e2ba6ef08cb270983756e760bdeaa3155e1ca69a5f4bc5dd1f\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./Algorithm.sol\\\";\\nimport \\\"./RSAVerify.sol\\\";\\nimport \\\"../../utils/BytesUtils.sol\\\";\\nimport \\\"@ensdomains/solsha1/contracts/SHA1.sol\\\";\\n\\n/// @dev Implements the DNSSEC RSASHA1 algorithm.\\ncontract RSASHA1Algorithm is Algorithm {\\n    using BytesUtils for *;\\n\\n    function verify(\\n        bytes calldata key,\\n        bytes calldata data,\\n        bytes calldata sig\\n    ) external view override returns (bool) {\\n        bytes memory exponent;\\n        bytes memory modulus;\\n\\n        uint16 exponentLen = uint16(key.readUint8(4));\\n        if (exponentLen != 0) {\\n            exponent = key.substring(5, exponentLen);\\n            modulus = key.substring(\\n                exponentLen + 5,\\n                key.length - exponentLen - 5\\n            );\\n        } else {\\n            exponentLen = key.readUint16(5);\\n            exponent = key.substring(7, exponentLen);\\n            modulus = key.substring(\\n                exponentLen + 7,\\n                key.length - exponentLen - 7\\n            );\\n        }\\n\\n        // Recover the message from the signature\\n        bool ok;\\n        bytes memory result;\\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\\n\\n        // Verify it ends with the hash of our data\\n        return ok && SHA1.sha1(data) == result.readBytes20(result.length - 20);\\n    }\\n}\\n\",\"keccak256\":\"0x1e2f9220611f73c1faee2556289ef9f107b5cd331063f6e485b0d17e67d8726f\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/RSAVerify.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./ModexpPrecompile.sol\\\";\\nimport \\\"../../utils/BytesUtils.sol\\\";\\n\\nlibrary RSAVerify {\\n    /// @dev Recovers the input data from an RSA signature, returning the result in S.\\n    /// @param N The RSA public modulus.\\n    /// @param E The RSA public exponent.\\n    /// @param S The signature to recover.\\n    /// @return True if the recovery succeeded.\\n    function rsarecover(\\n        bytes memory N,\\n        bytes memory E,\\n        bytes memory S\\n    ) internal view returns (bool, bytes memory) {\\n        return ModexpPrecompile.modexp(S, E, N);\\n    }\\n}\\n\",\"keccak256\":\"0x3de747c1a48c82031e79a35c6b844697e48c8d0549cb3475783b1447895ef8ab\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/solsha1/contracts/SHA1.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary SHA1 {\\n    event Debug(bytes32 x);\\n\\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\\n        assembly {\\n            // Get a safe scratch location\\n            let scratch := mload(0x40)\\n\\n            // Get the data length, and point data at the first byte\\n            let len := mload(data)\\n            data := add(data, 32)\\n\\n            // Find the length after padding\\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\\n            switch lt(sub(totallen, len), 9)\\n            case 1 { totallen := add(totallen, 64) }\\n\\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\\n\\n            function readword(ptr, off, count) -> result {\\n                result := 0\\n                if lt(off, count) {\\n                    result := mload(add(ptr, off))\\n                    count := sub(count, off)\\n                    if lt(count, 32) {\\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\\n                        result := and(result, mask)\\n                    }\\n                }\\n            }\\n\\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\\n                mstore(scratch, readword(data, i, len))\\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\\n\\n                // If we loaded the last byte, store the terminator byte\\n                switch lt(sub(len, i), 64)\\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\\n\\n                // If this is the last block, store the length\\n                switch eq(i, sub(totallen, 64))\\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\\n\\n                // Expand the 16 32-bit words into 80\\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\\n                    mstore(add(scratch, j), temp)\\n                }\\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\\n                    mstore(add(scratch, j), temp)\\n                }\\n\\n                let x := h\\n                let f := 0\\n                let k := 0\\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\\n                    switch div(j, 20)\\n                    case 0 {\\n                        // f = d xor (b and (c xor d))\\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0x5A827999\\n                    }\\n                    case 1{\\n                        // f = b xor c xor d\\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0x6ED9EBA1\\n                    }\\n                    case 2 {\\n                        // f = (b and c) or (d and (b or c))\\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := and(div(x, 0x10000000000), f)\\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\\n                        k := 0x8F1BBCDC\\n                    }\\n                    case 3 {\\n                        // f = b xor c xor d\\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0xCA62C1D6\\n                    }\\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\\n                    temp := add(f, temp)\\n                    temp := add(and(x, 0xFFFFFFFF), temp)\\n                    temp := add(k, temp)\\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\\n                }\\n\\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\\n            }\\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x746d9b85de197afbc13182cbe4ba4f7917f19594e07c655d6a0c85fdf7460a8a\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x",
  "transaction": {
    "hash": "0x52c3ddc944e2507a0b7b673b7546bea715ae661473742c0c60b099a51fcfa52e",
    "nonce": "0xc",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0xea87392137850f20e678e42f48f46eb3dbe3e9a3576881877bb188c4fe9b43ee",
    "blockNumber": "0xd",
    "transactionIndex": "0x0"
  }
}
{
  "address": "0x998abeb3e57409262ae5b751f60747921b33613e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IStandaloneReverseRegistrar",
          "name": "defaultRegistrar",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "UnreachableName",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        }
      ],
      "name": "UnsupportedResolverProfile",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "chainId",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "chainRegistrar",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "coinType",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addrs",
          "type": "address[]"
        }
      ],
      "name": "resolveNames",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "names",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "DefaultReverseResolver",
  "sourceName": "lib/ens-contracts/contracts/reverseResolver/DefaultReverseResolver.sol",
  "bytecode": "0x60c0604052348015600e575f80fd5b5060405161124a38038061124a833981016040819052602b916043565b63800000006080526001600160a01b031660a052606e565b5f602082840312156052575f80fd5b81516001600160a01b03811681146067575f80fd5b9392505050565b60805160a0516111856100c55f395f818160a0015281816104350152818161058f015261080501525f818160ec015281816102ac015281816102d20152818161040901528181610545015261063f01526111855ff3fe608060405234801561000f575f80fd5b506004361061006f575f3560e01c80639061b9231161004d5780639061b9231461011c5780639a8a05921461013c578063e38f713814610159575f80fd5b806301ffc9a7146100735780630d02e00f1461009b5780631fe93ea8146100e7575b5f80fd5b610086610081366004610d12565b610179565b60405190151581526020015b60405180910390f35b6100c27f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610092565b61010e7f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610092565b61012f61012a366004610d7e565b610215565b6040516100929190610e13565b610144610639565b60405163ffffffff9091168152602001610092565b61016c610167366004610e6a565b610668565b6040516100929190610f2f565b5f6001600160e01b031982167f9061b9230000000000000000000000000000000000000000000000000000000014806101db57506001600160e01b031982167f6beeaa0d00000000000000000000000000000000000000000000000000000000145b8061020f57507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b92915050565b60605f6102228385610f91565b90507f96e0cbcf000000000000000000000000000000000000000000000000000000006001600160e01b0319821601610370575f8061029588888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061071292505050565b9150915081516014141580610303575063800000007f0000000000000000000000000000000000000000000000000000000000000000146102f8577f00000000000000000000000000000000000000000000000000000000000000008114610301565b61030181610798565b155b1561032e578787604051635fe9a5df60e01b8152600401610325929190610fc1565b60405180910390fd5b5f61033883610fef565b60601c9050610346816107bd565b6040516020016103569190610e13565b604051602081830303815290604052945050505050610631565b7fc4c4a822000000000000000000000000000000000000000000000000000000006001600160e01b031982160161048f575f6103e087878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610872915050565b50905080610405578686604051635fe9a5df60e01b8152600401610325929190610fc1565b603c7f000000000000000000000000000000000000000000000000000000000000000014610433575f610455565b7f00000000000000000000000000000000000000000000000000000000000000005b6040805173ffffffffffffffffffffffffffffffffffffffff90921660208301520160405160208183030381529060405292505050610631565b7f0e3481fa000000000000000000000000000000000000000000000000000000006001600160e01b03198216016105f3575f6104ff87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610872915050565b50905080610524578686604051635fe9a5df60e01b8152600401610325929190610fc1565b5f610532856004818961102b565b81019061053f9190611052565b915050807f00000000000000000000000000000000000000000000000000000000000000001461057c57604080515f8152602081019091526105ca565b6040516bffffffffffffffffffffffff197f000000000000000000000000000000000000000000000000000000000000000060601b1660208201526034016040516020818303038152906040525b6040516020016105da9190610e13565b6040516020818303038152906040529350505050610631565b6040517f7b1c461b0000000000000000000000000000000000000000000000000000000081526001600160e01b031982166004820152602401610325565b949350505050565b5f6106637f0000000000000000000000000000000000000000000000000000000000000000610a3c565b905090565b6060815167ffffffffffffffff81111561068457610684610e25565b6040519080825280602002602001820160405280156106b757816020015b60608152602001906001900390816106a25790505b5090505f5b825181101561070c576106e78382815181106106da576106da611072565b60200260200101516107bd565b8282815181106106f9576106f9611072565b60209081029190910101526001016106bc565b50919050565b60605f80610720845f610a66565b9150505f61073085600184610a93565b909450905080158061074157508351155b15610762575f60405180602001604052805f81525090935093505050915091565b61076c8583610872565b9350905080610791575f60405180602001604052805f81525090935093505050915091565b5050915091565b5f638000000082148061020f57505f6107b083610a3c565b63ffffffff161192915050565b6040517f4ec3bd2300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526060917f000000000000000000000000000000000000000000000000000000000000000090911690634ec3bd23906024015f60405180830381865afa15801561084b573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261020f9190810190611086565b5f805f806108808686610a66565b60408051808201909152600481527f616464720000000000000000000000000000000000000000000000000000000060209091015290925090507f1a1ebb7848707a05591e7f7176db930a822cb7ceab700d19f68c7f26724dafb682016108ea57603c9250610997565b60408051808201909152600781527f64656661756c74000000000000000000000000000000000000000000000000006020909101527f301183f75670b4a9a2edb381b1d7533ad1e4387f1c77824f5fd582d2a43998d882016109525763800000009250610997565b81610964575f80935093505050610a35565b5f8061097b88610975896001611129565b85610b37565b9150915080610993575f809550955050505050610a35565b5092505b6109a18682610a66565b60408051808201909152600781527f7265766572736500000000000000000000000000000000000000000000000000602090910152955091507fdec08c9dbbdd0890e300eb5062089b2d4b1c40e3673bbccb5423f7b37dcf9a9c8214610a0e575f80935093505050610a35565b610a188686610a66565b5091508115610a2e575f80935093505050610a35565b6001935050505b9250929050565b5f603c8203610a4d57506001919050565b6380000000918218918210610a62575f61020f565b5090565b5f805f610a738585610ba9565b9250905060ff811615610a8b57806021858701012092505b509250929050565b60605f83831015610ab457505060408051602081019091525f808252610b2f565b5f610abf858561113c565b90506001610acd8282611129565b901c67ffffffffffffffff811115610ae757610ae7610e25565b6040519080825280601f01601f191660200182016040528015610b11576020820181803683370190505b50925060208587018101908401610b29828285610c26565b93505050505b935093915050565b5f8083831015610b4b57505f905080610b2f565b5f610b56858561113c565b90506040811180610b675750855184115b15610b7857505f9150819050610b2f565b858501602001610b89815f84610c26565b92506001820160011c6020035f518160031b1c9450505050935093915050565b5f8083518310610bce578360405163ba4adc2360e01b81526004016103259190610e13565b838381518110610be057610be0611072565b016020015160f81c91505081810160010181610c00578351811415610c06565b83518110155b15610a35578360405163ba4adc2360e01b81526004016103259190610e13565b5f610c84565b811a5f602f8211603a83101615610c485750602f19810161020f565b60478210604083111615610c615750603619810161020f565b60678210606083111615610c7a5750605619810161020f565b5061010092915050565b50600183820182821615610cbe57610c9d5f8651610c2c565b80855360018601955060018501945060ff811115610cbc575f92508195505b505b80851015610d0a578451610cd3600182610c2c565b610cdd5f83610c2c565b60041b17905060ff811115610cf5575f925050610d0a565b80855350600285019450600184019350610cbe565b509392505050565b5f60208284031215610d22575f80fd5b81356001600160e01b031981168114610d39575f80fd5b9392505050565b5f8083601f840112610d50575f80fd5b50813567ffffffffffffffff811115610d67575f80fd5b602083019150836020828501011115610a35575f80fd5b5f805f8060408587031215610d91575f80fd5b843567ffffffffffffffff80821115610da8575f80fd5b610db488838901610d40565b90965094506020870135915080821115610dcc575f80fd5b50610dd987828801610d40565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610d396020830184610de5565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610e6257610e62610e25565b604052919050565b5f6020808385031215610e7b575f80fd5b823567ffffffffffffffff80821115610e92575f80fd5b818501915085601f830112610ea5575f80fd5b813581811115610eb757610eb7610e25565b8060051b9150610ec8848301610e39565b8181529183018401918481019088841115610ee1575f80fd5b938501935b83851015610f23578435925073ffffffffffffffffffffffffffffffffffffffff83168314610f13575f80fd5b8282529385019390850190610ee6565b98975050505050505050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b82811015610f8457603f19888603018452610f72858351610de5565b94509285019290850190600101610f56565b5092979650505050505050565b6001600160e01b03198135818116916004851015610fb95780818660040360031b1b83161692505b505092915050565b60208152816020820152818360408301375f818301604090810191909152601f909201601f19160101919050565b805160208201516bffffffffffffffffffffffff1980821692919060148310156110235780818460140360031b1b83161693505b505050919050565b5f8085851115611039575f80fd5b83861115611045575f80fd5b5050820193919092039150565b5f8060408385031215611063575f80fd5b50508035926020909101359150565b634e487b7160e01b5f52603260045260245ffd5b5f6020808385031215611097575f80fd5b825167ffffffffffffffff808211156110ae575f80fd5b818501915085601f8301126110c1575f80fd5b8151818111156110d3576110d3610e25565b6110e5601f8201601f19168501610e39565b915080825286848285010111156110fa575f80fd5b808484018584015e5f90820190930192909252509392505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561020f5761020f611115565b8181038181111561020f5761020f61111556fea26469706673582212201e8a9cdd8be1704c8b5ef9e6d8ed90d778f947b9d52c2615f69da45e9bd4edf464736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b506004361061006f575f3560e01c80639061b9231161004d5780639061b9231461011c5780639a8a05921461013c578063e38f713814610159575f80fd5b806301ffc9a7146100735780630d02e00f1461009b5780631fe93ea8146100e7575b5f80fd5b610086610081366004610d12565b610179565b60405190151581526020015b60405180910390f35b6100c27f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610092565b61010e7f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610092565b61012f61012a366004610d7e565b610215565b6040516100929190610e13565b610144610639565b60405163ffffffff9091168152602001610092565b61016c610167366004610e6a565b610668565b6040516100929190610f2f565b5f6001600160e01b031982167f9061b9230000000000000000000000000000000000000000000000000000000014806101db57506001600160e01b031982167f6beeaa0d00000000000000000000000000000000000000000000000000000000145b8061020f57507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b92915050565b60605f6102228385610f91565b90507f96e0cbcf000000000000000000000000000000000000000000000000000000006001600160e01b0319821601610370575f8061029588888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061071292505050565b9150915081516014141580610303575063800000007f0000000000000000000000000000000000000000000000000000000000000000146102f8577f00000000000000000000000000000000000000000000000000000000000000008114610301565b61030181610798565b155b1561032e578787604051635fe9a5df60e01b8152600401610325929190610fc1565b60405180910390fd5b5f61033883610fef565b60601c9050610346816107bd565b6040516020016103569190610e13565b604051602081830303815290604052945050505050610631565b7fc4c4a822000000000000000000000000000000000000000000000000000000006001600160e01b031982160161048f575f6103e087878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610872915050565b50905080610405578686604051635fe9a5df60e01b8152600401610325929190610fc1565b603c7f000000000000000000000000000000000000000000000000000000000000000014610433575f610455565b7f00000000000000000000000000000000000000000000000000000000000000005b6040805173ffffffffffffffffffffffffffffffffffffffff90921660208301520160405160208183030381529060405292505050610631565b7f0e3481fa000000000000000000000000000000000000000000000000000000006001600160e01b03198216016105f3575f6104ff87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610872915050565b50905080610524578686604051635fe9a5df60e01b8152600401610325929190610fc1565b5f610532856004818961102b565b81019061053f9190611052565b915050807f00000000000000000000000000000000000000000000000000000000000000001461057c57604080515f8152602081019091526105ca565b6040516bffffffffffffffffffffffff197f000000000000000000000000000000000000000000000000000000000000000060601b1660208201526034016040516020818303038152906040525b6040516020016105da9190610e13565b6040516020818303038152906040529350505050610631565b6040517f7b1c461b0000000000000000000000000000000000000000000000000000000081526001600160e01b031982166004820152602401610325565b949350505050565b5f6106637f0000000000000000000000000000000000000000000000000000000000000000610a3c565b905090565b6060815167ffffffffffffffff81111561068457610684610e25565b6040519080825280602002602001820160405280156106b757816020015b60608152602001906001900390816106a25790505b5090505f5b825181101561070c576106e78382815181106106da576106da611072565b60200260200101516107bd565b8282815181106106f9576106f9611072565b60209081029190910101526001016106bc565b50919050565b60605f80610720845f610a66565b9150505f61073085600184610a93565b909450905080158061074157508351155b15610762575f60405180602001604052805f81525090935093505050915091565b61076c8583610872565b9350905080610791575f60405180602001604052805f81525090935093505050915091565b5050915091565b5f638000000082148061020f57505f6107b083610a3c565b63ffffffff161192915050565b6040517f4ec3bd2300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526060917f000000000000000000000000000000000000000000000000000000000000000090911690634ec3bd23906024015f60405180830381865afa15801561084b573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261020f9190810190611086565b5f805f806108808686610a66565b60408051808201909152600481527f616464720000000000000000000000000000000000000000000000000000000060209091015290925090507f1a1ebb7848707a05591e7f7176db930a822cb7ceab700d19f68c7f26724dafb682016108ea57603c9250610997565b60408051808201909152600781527f64656661756c74000000000000000000000000000000000000000000000000006020909101527f301183f75670b4a9a2edb381b1d7533ad1e4387f1c77824f5fd582d2a43998d882016109525763800000009250610997565b81610964575f80935093505050610a35565b5f8061097b88610975896001611129565b85610b37565b9150915080610993575f809550955050505050610a35565b5092505b6109a18682610a66565b60408051808201909152600781527f7265766572736500000000000000000000000000000000000000000000000000602090910152955091507fdec08c9dbbdd0890e300eb5062089b2d4b1c40e3673bbccb5423f7b37dcf9a9c8214610a0e575f80935093505050610a35565b610a188686610a66565b5091508115610a2e575f80935093505050610a35565b6001935050505b9250929050565b5f603c8203610a4d57506001919050565b6380000000918218918210610a62575f61020f565b5090565b5f805f610a738585610ba9565b9250905060ff811615610a8b57806021858701012092505b509250929050565b60605f83831015610ab457505060408051602081019091525f808252610b2f565b5f610abf858561113c565b90506001610acd8282611129565b901c67ffffffffffffffff811115610ae757610ae7610e25565b6040519080825280601f01601f191660200182016040528015610b11576020820181803683370190505b50925060208587018101908401610b29828285610c26565b93505050505b935093915050565b5f8083831015610b4b57505f905080610b2f565b5f610b56858561113c565b90506040811180610b675750855184115b15610b7857505f9150819050610b2f565b858501602001610b89815f84610c26565b92506001820160011c6020035f518160031b1c9450505050935093915050565b5f8083518310610bce578360405163ba4adc2360e01b81526004016103259190610e13565b838381518110610be057610be0611072565b016020015160f81c91505081810160010181610c00578351811415610c06565b83518110155b15610a35578360405163ba4adc2360e01b81526004016103259190610e13565b5f610c84565b811a5f602f8211603a83101615610c485750602f19810161020f565b60478210604083111615610c615750603619810161020f565b60678210606083111615610c7a5750605619810161020f565b5061010092915050565b50600183820182821615610cbe57610c9d5f8651610c2c565b80855360018601955060018501945060ff811115610cbc575f92508195505b505b80851015610d0a578451610cd3600182610c2c565b610cdd5f83610c2c565b60041b17905060ff811115610cf5575f925050610d0a565b80855350600285019450600184019350610cbe565b509392505050565b5f60208284031215610d22575f80fd5b81356001600160e01b031981168114610d39575f80fd5b9392505050565b5f8083601f840112610d50575f80fd5b50813567ffffffffffffffff811115610d67575f80fd5b602083019150836020828501011115610a35575f80fd5b5f805f8060408587031215610d91575f80fd5b843567ffffffffffffffff80821115610da8575f80fd5b610db488838901610d40565b90965094506020870135915080821115610dcc575f80fd5b50610dd987828801610d40565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610d396020830184610de5565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610e6257610e62610e25565b604052919050565b5f6020808385031215610e7b575f80fd5b823567ffffffffffffffff80821115610e92575f80fd5b818501915085601f830112610ea5575f80fd5b813581811115610eb757610eb7610e25565b8060051b9150610ec8848301610e39565b8181529183018401918481019088841115610ee1575f80fd5b938501935b83851015610f23578435925073ffffffffffffffffffffffffffffffffffffffff83168314610f13575f80fd5b8282529385019390850190610ee6565b98975050505050505050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b82811015610f8457603f19888603018452610f72858351610de5565b94509285019290850190600101610f56565b5092979650505050505050565b6001600160e01b03198135818116916004851015610fb95780818660040360031b1b83161692505b505092915050565b60208152816020820152818360408301375f818301604090810191909152601f909201601f19160101919050565b805160208201516bffffffffffffffffffffffff1980821692919060148310156110235780818460140360031b1b83161693505b505050919050565b5f8085851115611039575f80fd5b83861115611045575f80fd5b5050820193919092039150565b5f8060408385031215611063575f80fd5b50508035926020909101359150565b634e487b7160e01b5f52603260045260245ffd5b5f6020808385031215611097575f80fd5b825167ffffffffffffffff808211156110ae575f80fd5b818501915085601f8301126110c1575f80fd5b8151818111156110d3576110d3610e25565b6110e5601f8201601f19168501610e39565b915080825286848285010111156110fa575f80fd5b808484018584015e5f90820190930192909252509392505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561020f5761020f611115565b8181038181111561020f5761020f61111556fea26469706673582212201e8a9cdd8be1704c8b5ef9e6d8ed90d778f947b9d52c2615f69da45e9bd4edf464736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "16592": [
      {
        "length": 32,
        "start": 236
      },
      {
        "length": 32,
        "start": 684
      },
      {
        "length": 32,
        "start": 722
      },
      {
        "length": 32,
        "start": 1033
      },
      {
        "length": 32,
        "start": 1349
      },
      {
        "length": 32,
        "start": 1599
      }
    ],
    "16595": [
      {
        "length": 32,
        "start": 160
      },
      {
        "length": 32,
        "start": 1077
      },
      {
        "length": 32,
        "start": 1423
      },
      {
        "length": 32,
        "start": 2053
      }
    ]
  },
  "inputSourceName": "project/lib/ens-contracts/contracts/reverseResolver/DefaultReverseResolver.sol",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "UnreachableName(bytes)": [
        {
          "details": "Error selector: `0x5fe9a5df`"
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "details": "Error selector: `0x7b1c461b`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "resolve(bytes,bytes)": {
        "details": "This function may execute over multiple steps.",
        "params": {
          "data": "The resolution data, as specified in ENSIP-10.",
          "name": "The reverse name to resolve, in normalised and DNS-encoded form."
        },
        "returns": {
          "result": "The encoded response for the requested profile."
        }
      },
      "resolveNames(address[])": {
        "details": "This function may execute over multiple steps.",
        "params": {
          "addrs": "The addresses to resolve."
        },
        "returns": {
          "names": "The resolved names."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "title": "Default Reverse Resolver",
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "897000",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "chainId()": "infinite",
        "chainRegistrar()": "infinite",
        "coinType()": "infinite",
        "resolve(bytes,bytes)": "infinite",
        "resolveNames(address[])": "infinite",
        "supportsInterface(bytes4)": "461"
      },
      "internal": {
        "_resolveName(address)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IStandaloneReverseRegistrar\",\"name\":\"defaultRegistrar\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"UnreachableName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedResolverProfile\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"resolveNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"UnreachableName(bytes)\":[{\"details\":\"Error selector: `0x5fe9a5df`\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"details\":\"Error selector: `0x7b1c461b`\"}]},\"kind\":\"dev\",\"methods\":{\"resolve(bytes,bytes)\":{\"details\":\"This function may execute over multiple steps.\",\"params\":{\"data\":\"The resolution data, as specified in ENSIP-10.\",\"name\":\"The reverse name to resolve, in normalised and DNS-encoded form.\"},\"returns\":{\"result\":\"The encoded response for the requested profile.\"}},\"resolveNames(address[])\":{\"details\":\"This function may execute over multiple steps.\",\"params\":{\"addrs\":\"The addresses to resolve.\"},\"returns\":{\"names\":\"The resolved names.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"title\":\"Default Reverse Resolver\",\"version\":1},\"userdoc\":{\"errors\":{\"UnreachableName(bytes)\":[{\"notice\":\"`name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"notice\":\"`resolve()` was called with a profile other than `name()` or `addr(*)`.\"}]},\"kind\":\"user\",\"methods\":{\"chainId()\":{\"notice\":\"The EVM Chain ID derived from `coinType()`.\"},\"chainRegistrar()\":{\"notice\":\"The reverse registrar address on the corresponding chain.         The address returned by `addr(coinType)` for the resolver.\"},\"coinType()\":{\"notice\":\"The coin type for the resolver.\"},\"resolve(bytes,bytes)\":{\"notice\":\"Resolves the following profiles according to ENSIP-10:         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.         Caller should enable EIP-3668.\"},\"resolveNames(address[])\":{\"notice\":\"Resolve multiple EVM addresses to names.         Caller should enable EIP-3668.\"}},\"notice\":\"Reverses an EVM address using the `IStandaloneReverseRegistrar` for \\\"default.reverse\\\".\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/lib/ens-contracts/contracts/reverseResolver/DefaultReverseResolver.sol\":\"DefaultReverseResolver\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@ensdomains/solsha1/contracts/=project/lib/solsha1/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts-v5/=project/lib/openzeppelin-contracts/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/ens-contracts/:@unruggable/gateways/=project/lib/unruggable-gateways/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\",\"project/test/mocks/v1/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the legacy (ETH-only) addr function.\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /// Returns the address associated with an ENS node.\\n    /// @param node The ENS node to query.\\n    /// @return The associated address.\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the new (multicoin) addr function.\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x8da5dd0fc1c5ab4f47e03c23126976a86d4b2dbeac161e70e3af9e2a13330cf0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /// Returns the name associated with an ENS node, for reverse records.\\n    /// Defined in EIP181.\\n    /// @param node The ENS node to query.\\n    /// @return The associated name.\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x3ab986332e0baad7aeb4b426aace3aa1c235be5efff8db4b6f1ce501bcdd9e68\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseRegistrar/IStandaloneReverseRegistrar.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Interface for a standalone reverse registrar.\\ninterface IStandaloneReverseRegistrar {\\n    /// @notice Emitted when the name for an address is changed.\\n    ///\\n    /// @param addr The address of the reverse record.\\n    /// @param name The name of the reverse record.\\n    event NameForAddrChanged(address indexed addr, string name);\\n\\n    /// @notice Returns the name for an address.\\n    ///\\n    /// @param addr The address to get the name for.\\n    /// @return The name for the address.\\n    function nameForAddr(address addr) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x693ab3a5dcd95a80a2a4a2418ce48092d20d11da1e39d17c87ab3f1641ceaf6e\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseResolver/AbstractReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ERC165} from \\\"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\\\";\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IAddressResolver} from \\\"../resolvers/profiles/IAddressResolver.sol\\\";\\nimport {IAddrResolver} from \\\"../resolvers/profiles/IAddrResolver.sol\\\";\\nimport {INameResolver} from \\\"../resolvers/profiles/INameResolver.sol\\\";\\nimport {INameReverser} from \\\"./INameReverser.sol\\\";\\nimport {ENSIP19, COIN_TYPE_DEFAULT, COIN_TYPE_ETH} from \\\"../utils/ENSIP19.sol\\\";\\n\\nabstract contract AbstractReverseResolver is\\n    IExtendedResolver,\\n    INameReverser,\\n    ERC165\\n{\\n    /// @inheritdoc INameReverser\\n    uint256 public immutable coinType;\\n\\n\\t/// @inheritdoc INameReverser\\n    address public immutable chainRegistrar;\\n\\n    /// @notice `resolve()` was called with a profile other than `name()` or `addr(*)`.\\n    /// @dev Error selector: `0x7b1c461b`\\n    error UnsupportedResolverProfile(bytes4 selector);\\n\\n    /// @notice `name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\\n    /// @dev Error selector: `0x5fe9a5df`\\n    error UnreachableName(bytes name);\\n\\n    constructor(uint256 _coinType, address registrar) {\\n        coinType = _coinType;\\n        chainRegistrar = registrar;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IExtendedResolver).interfaceId ||\\n            interfaceId == type(INameReverser).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc INameReverser\\n    function chainId() external view returns (uint32) {\\n        return ENSIP19.chainFromCoinType(coinType);\\n    }\\n\\n    /// @dev Resolve one address to a name.\\n    ///      If this reverts `OffchainLookup`, it must return an abi-encoded result since\\n    ///      it is invoked during `resolve()`.\\n    function _resolveName(\\n        address addr\\n    ) internal view virtual returns (string memory name);\\n\\n    /// @notice Resolves the following profiles according to ENSIP-10:\\n    ///         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.\\n    ///         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.\\n    ///         Caller should enable EIP-3668.\\n    /// @dev This function may execute over multiple steps.\\n    /// @param name The reverse name to resolve, in normalised and DNS-encoded form.\\n    /// @param data The resolution data, as specified in ENSIP-10.\\n    /// @return result The encoded response for the requested profile.\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory result) {\\n        bytes4 selector = bytes4(data);\\n        if (selector == INameResolver.name.selector) {\\n            (bytes memory a, uint256 ct) = ENSIP19.parse(name);\\n            if (\\n                a.length != 20 ||\\n                !(\\n                    coinType == COIN_TYPE_DEFAULT\\n                        ? ENSIP19.isEVMCoinType(ct)\\n                        : ct == coinType\\n                )\\n            ) {\\n                revert UnreachableName(name);\\n            }\\n            address addr = address(bytes20(a));\\n            return abi.encode(_resolveName(addr));\\n        } else if (selector == IAddrResolver.addr.selector) {\\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\\n            if (!valid) revert UnreachableName(name);\\n            return\\n                abi.encode(coinType == COIN_TYPE_ETH ? chainRegistrar : address(0));\\n        } else if (selector == IAddressResolver.addr.selector) {\\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\\n            if (!valid) revert UnreachableName(name);\\n            (, uint256 ct) = abi.decode(data[4:], (bytes32, uint256));\\n            return\\n                abi.encode(\\n                    coinType == ct ? abi.encodePacked(chainRegistrar) : new bytes(0)\\n                );\\n        } else {\\n            revert UnsupportedResolverProfile(selector);\\n        }\\n    }\\n\\n    // `INameReverser.resolveNames()` is not implemented here because it causes\\n    // an incorrect \\\"Unreachable code\\\" compiler warning if `_resolveName()` reverts.\\n    // https://github.com/ethereum/solidity/issues/15426#issuecomment-2917868211\\n    //\\n    // /// @inheritdoc INameReverser\\n    // function resolveNames(\\n    //     address[] memory addrs,\\n    //     uint8 /*perPage*/\\n    // ) external view returns (string[] memory names) {\\n    //     names = new string[](addrs.length);\\n    //     for (uint256 i; i < addrs.length; i++) {\\n    //         names[i] = _resolveName(addrs[i]);\\n    //     }\\n    // }\\n}\\n\",\"keccak256\":\"0x492aa5a5e0d184035247aae2e8ed6e283068e2a9f2ec03b02851d240ffe6960f\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseResolver/DefaultReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {AbstractReverseResolver} from \\\"./AbstractReverseResolver.sol\\\";\\nimport {IStandaloneReverseRegistrar} from \\\"../reverseRegistrar/IStandaloneReverseRegistrar.sol\\\";\\nimport {INameReverser} from \\\"./INameReverser.sol\\\";\\nimport {COIN_TYPE_DEFAULT} from \\\"../utils/ENSIP19.sol\\\";\\n\\n/// @title Default Reverse Resolver\\n/// @notice Reverses an EVM address using the `IStandaloneReverseRegistrar` for \\\"default.reverse\\\".\\ncontract DefaultReverseResolver is AbstractReverseResolver {\\n    constructor(\\n        IStandaloneReverseRegistrar defaultRegistrar\\n    ) AbstractReverseResolver(COIN_TYPE_DEFAULT, address(defaultRegistrar)) {}\\n\\n    /// @inheritdoc AbstractReverseResolver\\n    function _resolveName(\\n        address addr\\n    ) internal view override returns (string memory name) {\\n        name = IStandaloneReverseRegistrar(chainRegistrar).nameForAddr(addr);\\n    }\\n\\n    /// @inheritdoc INameReverser\\n    function resolveNames(\\n        address[] memory addrs\\n    ) external view returns (string[] memory names) {\\n        names = new string[](addrs.length);\\n        for (uint256 i; i < addrs.length; ++i) {\\n            names[i] = _resolveName(addrs[i]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0195ecf72a12a8431216340ec1c99a56f9321a5918bd5c5d83475ac6d95246a1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/reverseResolver/INameReverser.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice A resolver for primary name resolution.\\n/// @dev Interface selector: `0x6beeaa0d`\\ninterface INameReverser {\\n    /// @notice Resolve multiple EVM addresses to names.\\n    ///         Caller should enable EIP-3668.\\n    /// @dev This function may execute over multiple steps.\\n    /// @param addrs The addresses to resolve.\\n    /// @return names The resolved names.\\n    function resolveNames(\\n        address[] memory addrs\\n    ) external view returns (string[] memory names);\\n\\n    /// @notice The coin type for the resolver.\\n    function coinType() external view returns (uint256);\\n\\n    /// @notice The EVM Chain ID derived from `coinType()`.\\n    function chainId() external view returns (uint32);\\n\\n    /// @notice The reverse registrar address on the corresponding chain.\\n    ///         The address returned by `addr(coinType)` for the resolver.\\n    function chainRegistrar() external view returns (address);\\n}\\n\",\"keccak256\":\"0x74873da2d0f06ff236802bf9378aee03db8f2793c7113015cafe7515c3e61244\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/ENSIP19.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nuint32 constant CHAIN_ID_ETH = 1;\\n\\nuint256 constant COIN_TYPE_ETH = 60;\\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\\n\\nstring constant SLUG_ETH = \\\"addr\\\"; // <=> COIN_TYPE_ETH\\nstring constant SLUG_DEFAULT = \\\"default\\\"; // <=> COIN_TYPE_DEFAULT\\nstring constant TLD_REVERSE = \\\"reverse\\\";\\n\\n/// @dev Library for generating reverse names according to ENSIP-19.\\n/// https://docs.ens.domains/ensip/19\\nlibrary ENSIP19 {\\n    /// @dev The supplied address was `0x`.\\n    ///      Error selector: `0x7138356f`\\n    error EmptyAddress();\\n\\n    /// @dev Extract Chain ID from `coinType`.\\n    /// @param coinType The coin type.\\n    /// @return The Chain ID or 0 if non-EVM Chain.\\n    function chainFromCoinType(\\n        uint256 coinType\\n    ) internal pure returns (uint32) {\\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\\n        coinType ^= COIN_TYPE_DEFAULT;\\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\\n    }\\n\\n    /// @dev Determine if Coin Type is for an EVM address.\\n    /// @param coinType The coin type.\\n    /// @return True if coin type represents an EVM address.\\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\\n    }\\n\\n    /// @dev Generate Reverse Name from Address + Coin Type.\\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\\n    /// @param addressBytes The input address.\\n    /// @param coinType The coin type.\\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\\n    function reverseName(\\n        bytes memory addressBytes,\\n        uint256 coinType\\n    ) internal pure returns (string memory) {\\n        if (addressBytes.length == 0) {\\n            revert EmptyAddress();\\n        }\\n        return\\n            string(\\n                abi.encodePacked(\\n                    HexUtils.bytesToHex(addressBytes),\\n                    bytes1(\\\".\\\"),\\n                    coinType == COIN_TYPE_ETH\\n                        ? SLUG_ETH\\n                        : coinType == COIN_TYPE_DEFAULT\\n                            ? SLUG_DEFAULT\\n                            : HexUtils.unpaddedUintToHex(coinType, true),\\n                    bytes1(\\\".\\\"),\\n                    TLD_REVERSE\\n                )\\n            );\\n    }\\n\\n    /// @dev Parse Reverse Name into Address + Coin Type.\\n    ///      Matches: `/^[0-9a-fA-F]+\\\\.([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @return addressBytes The address or empty if invalid.\\n    /// @return coinType The coin type.\\n    function parse(\\n        bytes memory name\\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\\n        bool valid;\\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\\n        if (!valid || addressBytes.length == 0) return (\\\"\\\", 0); // addressBytes not 1+ hex\\n        (valid, coinType) = parseNamespace(name, offset);\\n        if (!valid) return (\\\"\\\", 0); // invalid namespace\\n    }\\n\\n    /// @dev Parse Reverse Namespace into Coin Type.\\n    ///      Matches: `/^([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset to begin parsing.\\n    /// @return valid True if a valid reverse namespace.\\n    /// @return coinType The coin type.\\n    function parseNamespace(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bool valid, uint256 coinType) {\\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\\n            name,\\n            offset\\n        );\\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\\n            coinType = COIN_TYPE_ETH;\\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\\n            coinType = COIN_TYPE_DEFAULT;\\n        } else if (labelHash == bytes32(0)) {\\n            return (false, 0); // no slug\\n        } else {\\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\\n                name,\\n                1 + offset,\\n                offsetTLD\\n            );\\n            if (!validHex) return (false, 0); // invalid coinType or too long\\n            coinType = uint256(word);\\n        }\\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\\n        (labelHash, ) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\\n        valid = true;\\n    }\\n}\\n\",\"keccak256\":\"0xd1af09b014028de4c50489bd58ae424273180bb96d95353d8eefd14845f31824\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary HexUtils {\\n    /// @dev Convert `hexString[off:end]` to `bytes32`.\\n    ///      Accepts 0-64 hex-chars.\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return word The parsed bytes32.\\n    /// @return valid True if the parse was successful.\\n    function hexStringToBytes32(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes32 word, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        if (nibbles > 64 || end > hexString.length) {\\n            return (bytes32(0), false); // too large or out of bounds\\n        }\\n        uint256 src;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n        }\\n        valid = unsafeBytes(src, 0, nibbles);\\n        assembly {\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\n            word := shr(shl(3, pad), mload(0)) // right align\\n        }\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `address`.\\n    ///      Accepts exactly 40 hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return addr The parsed address.\\n    /// @return valid True if the parse was successful.\\n    function hexToAddress(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (address addr, bool valid) {\\n        if (off + 40 != end) return (address(0), false); // wrong length\\n        bytes32 word;\\n        (word, valid) = hexStringToBytes32(hexString, off, end);\\n        addr = address(uint160(uint256(word)));\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `bytes`.\\n    ///      Accepts 0+ hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return v The parsed bytes.\\n    /// @return valid True if the parse was successful.\\n    function hexToBytes(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes memory v, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        v = new bytes((1 + nibbles) >> 1); // round up\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n            dst := add(v, 32)\\n        }\\n        valid = unsafeBytes(src, dst, nibbles);\\n    }\\n\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\n    ///      Matches: `/^[0-9a-f]*$/i`.\\n    /// @param src The memory offset of first hex-char of input.\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\n    /// @param nibbles The number of hex-chars to convert.\\n    /// @return valid True if all characters were hex.\\n    function unsafeBytes(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure returns (bool valid) {\\n        assembly {\\n            function getHex(c, i) -> ascii {\\n                c := byte(i, c)\\n                // chars 48-57: 0-9\\n                if and(gt(c, 47), lt(c, 58)) {\\n                    ascii := sub(c, 48)\\n                    leave\\n                }\\n                // chars 65-70: A-F\\n                if and(gt(c, 64), lt(c, 71)) {\\n                    ascii := add(sub(c, 65), 10)\\n                    leave\\n                }\\n                // chars 97-102: a-f\\n                if and(gt(c, 96), lt(c, 103)) {\\n                    ascii := add(sub(c, 97), 10)\\n                    leave\\n                }\\n                // invalid char\\n                ascii := 0x100\\n            }\\n            valid := true\\n            let end := add(src, nibbles)\\n            if and(nibbles, 1) {\\n                let b := getHex(mload(src), 0) // \\\"f\\\" -> 15\\n                mstore8(dst, b) // write ascii byte\\n                src := add(src, 1) // update pointers\\n                dst := add(dst, 1)\\n                if gt(b, 255) {\\n                    valid := false\\n                    src := end // terminate loop\\n                }\\n            }\\n            // prettier-ignore\\n            for {} lt(src, end) {\\n                src := add(src, 2) // 2 nibbles\\n                dst := add(dst, 1) // per byte\\n            } {\\n                let word := mload(src) // read word (left aligned)\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\"ff\\\" -> 255\\n                if gt(b, 255) {\\n                    valid := false\\n                    break\\n                }\\n                mstore8(dst, b) // write ascii byte\\n            }\\n        }\\n    }\\n\\n    /// @dev Format `address` as a hex string.\\n    /// @param addr The address to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function addressToHex(\\n        address addr\\n    ) internal pure returns (string memory hexString) {\\n        // return bytesToHex(abi.encodePacked(addr));\\n        hexString = new string(40);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, addr)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(12, dst, 40);\\n    }\\n\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\n    /// * unpaddedUintToHex(0, true)  = \\\"0\\\"\\n    /// * unpaddedUintToHex(1, true)  = \\\"1\\\"\\n    /// * unpaddedUintToHex(0, false) = \\\"00\\\"\\n    /// * unpaddedUintToHex(1, false) = \\\"01\\\"\\n    /// @param value The number to format.\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\n    function unpaddedUintToHex(\\n        uint256 value,\\n        bool dropZeroNibble\\n    ) internal pure returns (string memory hexString) {\\n        uint256 temp = value;\\n        uint256 shift;\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\n            if (temp < (1 << b)) {\\n                shift += b; // number of zero upper bits\\n            } else {\\n                temp >>= b; // shift away lower half\\n            }\\n        }\\n        if (dropZeroNibble && temp < 16) shift += 4;\\n        uint256 nibbles = 64 - (shift >> 2);\\n        hexString = new string(nibbles);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, shl(shift, value)) // left-align\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(0, dst, nibbles);\\n    }\\n\\n    /// @dev Format `bytes` as a hex string.\\n    /// @param v The bytes to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function bytesToHex(\\n        bytes memory v\\n    ) internal pure returns (string memory hexString) {\\n        uint256 nibbles = v.length << 1;\\n        hexString = new string(nibbles);\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(v, 32)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(src, dst, nibbles);\\n    }\\n\\n    /// @dev Converts arbitrary memory to a hex string.\\n    /// @param src The memory offset of first nibble of input.\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\n    function unsafeHex(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure {\\n        unchecked {\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(src)\\n                }\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\"a\\\" - 10) => 0x57\\n                    assembly {\\n                        mstore8(dst, b)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab784cab15b7a06154be3555edf0d25bcdad8e6bf116aa2016119a233875b02b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "UnreachableName(bytes)": [
        {
          "notice": "`name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace."
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "notice": "`resolve()` was called with a profile other than `name()` or `addr(*)`."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "chainId()": {
        "notice": "The EVM Chain ID derived from `coinType()`."
      },
      "chainRegistrar()": {
        "notice": "The reverse registrar address on the corresponding chain.         The address returned by `addr(coinType)` for the resolver."
      },
      "coinType()": {
        "notice": "The coin type for the resolver."
      },
      "resolve(bytes,bytes)": {
        "notice": "Resolves the following profiles according to ENSIP-10:         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.         Caller should enable EIP-3668."
      },
      "resolveNames(address[])": {
        "notice": "Resolve multiple EVM addresses to names.         Caller should enable EIP-3668."
      }
    },
    "notice": "Reverses an EVM address using the `IStandaloneReverseRegistrar` for \"default.reverse\".",
    "version": 1
  },
  "argsData": "0x000000000000000000000000f5059a5d33d5853360d16c683c16e67980206f36",
  "transaction": {
    "hash": "0xeda33f09bebf7511b46026b743d0678c5af09109621a4eeec1dd0fb44fb081d8",
    "nonce": "0x27",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x6e69a9d9aa28004f8fd366be7a9a8624c316faa4df16021bf52a7030eacffc09",
    "blockNumber": "0x2b",
    "transactionIndex": "0x0"
  }
}
{
  "address": "0x9a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_anchors",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "class",
          "type": "uint16"
        }
      ],
      "name": "InvalidClass",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "labelsExpected",
          "type": "uint256"
        }
      ],
      "name": "InvalidLabelCount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "proofType",
          "type": "uint16"
        }
      ],
      "name": "InvalidProofType",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidRRSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "rrsetName",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signerName",
          "type": "bytes"
        }
      ],
      "name": "InvalidSignerName",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "signerName",
          "type": "bytes"
        }
      ],
      "name": "NoMatchingProof",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "signerName",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "proofName",
          "type": "bytes"
        }
      ],
      "name": "ProofNameMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "expiration",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "now",
          "type": "uint32"
        }
      ],
      "name": "SignatureExpired",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "now",
          "type": "uint32"
        }
      ],
      "name": "SignatureNotValidYet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "rrsetType",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "sigType",
          "type": "uint16"
        }
      ],
      "name": "SignatureTypeMismatch",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "AlgorithmUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "DigestUpdated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "algorithms",
      "outputs": [
        {
          "internalType": "contract Algorithm",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "anchors",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "digests",
      "outputs": [
        {
          "internalType": "contract Digest",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "internalType": "contract Algorithm",
          "name": "algo",
          "type": "address"
        }
      ],
      "name": "setAlgorithm",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "internalType": "contract Digest",
          "name": "digest",
          "type": "address"
        }
      ],
      "name": "setDigest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "rrset",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "sig",
              "type": "bytes"
            }
          ],
          "internalType": "struct DNSSEC.RRSetWithSignature[]",
          "name": "input",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "now",
          "type": "uint256"
        }
      ],
      "name": "verifyRRSet",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "rrs",
          "type": "bytes"
        },
        {
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "rrset",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "sig",
              "type": "bytes"
            }
          ],
          "internalType": "struct DNSSEC.RRSetWithSignature[]",
          "name": "input",
          "type": "tuple[]"
        }
      ],
      "name": "verifyRRSet",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "rrs",
          "type": "bytes"
        },
        {
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "DNSSECImpl",
  "sourceName": "lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol",
  "bytecode": "0x608060405234801561000f575f80fd5b50604051611f65380380611f6583398101604081905261002e91610066565b600180546001600160a01b031916331790555f61004b8282610194565b5050610253565b634e487b7160e01b5f52604160045260245ffd5b5f60208284031215610076575f80fd5b81516001600160401b038082111561008c575f80fd5b818401915084601f83011261009f575f80fd5b8151818111156100b1576100b1610052565b604051601f8201601f19908116603f011681019083821181831017156100d9576100d9610052565b816040528281528760208487010111156100f1575f80fd5b8260208601602083015e5f928101602001929092525095945050505050565b600181811c9082168061012457607f821691505b60208210810361014257634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561018f57805f5260205f20601f840160051c8101602085101561016d5750805b601f840160051c820191505b8181101561018c575f8155600101610179565b50505b505050565b81516001600160401b038111156101ad576101ad610052565b6101c1816101bb8454610110565b84610148565b602080601f8311600181146101f4575f84156101dd5750858301515b5f19600386901b1c1916600185901b17855561024b565b5f85815260208120601f198616915b8281101561022257888601518255948401946001909101908401610203565b508582101561023f57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b611d05806102605f395ff3fe608060405234801561000f575f80fd5b506004361061009f575f3560e01c806373cc48a61161007257806398d35f201161005857806398d35f201461015b578063bdf95fef14610170578063c327deef14610183575f80fd5b806373cc48a6146101085780638da5cb5b14610148575f80fd5b8063020ed8d3146100a357806313af4035146100b857806328e7677d146100cb578063440f3d42146100de575b5f80fd5b6100b66100b1366004611835565b6101ab565b005b6100b66100c636600461186a565b610238565b6100b66100d9366004611835565b61027d565b6100f16100ec366004611a4e565b610302565b6040516100ff929190611abe565b60405180910390f35b610130610116366004611ae5565b60036020525f90815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020016100ff565b600154610130906001600160a01b031681565b6101636103e3565b6040516100ff9190611afe565b6100f161017e366004611b10565b61046e565b610130610191366004611ae5565b60026020525f90815260409020546001600160a01b031681565b6001546001600160a01b031633146101c1575f80fd5b60ff82165f81815260026020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527ff73c3c226af96b7f1ba666a21b3ceaf2be3ee6a365e3178fd9cd1eaae0075aa891015b60405180910390a15050565b6001546001600160a01b0316331461024e575f80fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6001546001600160a01b03163314610293575f80fd5b60ff82165f81815260036020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527f2fcc274c3b72dd483ab201bfa87295e3817e8b9b10693219873b722ca1af00c7910161022c565b60605f805f805461031290611b42565b80601f016020809104026020016040519081016040528092919081815260200182805461033e90611b42565b80156103895780601f1061036057610100808354040283529160200191610389565b820191905f5260205f20905b81548152906001019060200180831161036c57829003601f168201915b505050505090505f5b85518110156103d9575f6103c08783815181106103b1576103b1611b7a565b60200260200101518488610484565b61010081015160a0909101519450925050600101610392565b5091509250929050565b5f80546103ef90611b42565b80601f016020809104026020016040519081016040528092919081815260200182805461041b90611b42565b80156104665780601f1061043d57610100808354040283529160200191610466565b820191905f5260205f20905b81548152906001019060200180831161044957829003601f168201915b505050505081565b60605f61047b8342610302565b91509150915091565b60408051610140810182525f8082526020820181905291810182905260608082018390526080820183905260a0820183905260c082019290925260e08101829052610100810182905261012081019190915283516104e190610620565b90505f6104f182835f0151610761565b604083015190915060ff16610506825f6108bb565b1461054e578082604001516040517fe861b2bd000000000000000000000000000000000000000000000000000000008152600401610545929190611b8e565b60405180910390fd5b610120820181905260808201515f9084900360030b12156105b15760808201516040517fa784f87e00000000000000000000000000000000000000000000000000000000815263ffffffff91821660048201529084166024820152604401610545565b60a08201515f90840360030b121561060b5760a08201516040517fbd41036a00000000000000000000000000000000000000000000000000000000815263ffffffff91821660048201529084166024820152604401610545565b6106178183878761091e565b505b9392505050565b60408051610140810182525f8082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820181905261010082018190526101208201529061067a9083906109e7565b61ffff16815261068b826002610a08565b60ff16602082015261069e826003610a08565b60ff1660408201526106b1826004610a3a565b63ffffffff90811660608301526106cd908390600890610a3a16565b63ffffffff90811660808301526106e9908390600c90610a3a16565b63ffffffff90811660a08301526107059083906010906109e716565b61ffff1660c0820152610719826012610a56565b60e082018190525161075690610730906012611bc6565b8260e0015151601285516107449190611bd9565b61074e9190611bd9565b849190610a78565b610100820152919050565b60605f61076d84610acd565b90505b805151602082015110156108b457606081015161ffff166001146107cc5760608101516040517f98a5f31a00000000000000000000000000000000000000000000000000000000815261ffff9091166004820152602401610545565b81515f036107e4576107dd81610b24565b915061084d565b602081015181516107f491610b45565b825114158061081657508051602082015183516108149285925f92610b9c565b155b1561084d576040517fcbceee6f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8261ffff16816040015161ffff16146108a65760408082015190517fa6ff8a8a00000000000000000000000000000000000000000000000000000000815261ffff91821660048201529084166024820152604401610545565b6108af81610bbe565b610770565b5092915050565b5f805b835183106108ce576108ce611bec565b5f6108d98585610a08565b60ff1690506108e9816001611bc6565b6108f39085611bc6565b9350805f036109025750610915565b61090d600183611bc6565b9150506108be565b90505b92915050565b60e083015161092e908590610ca3565b61096b5760e08301516040517feaafc59b000000000000000000000000000000000000000000000000000000008152610545918691600401611c00565b5f6109768282610cfc565b9050602b61ffff16816040015161ffff160361099c57610997848483610d57565b6109e0565b603061ffff16816040015161ffff16036109bb57610997848483610e40565b60408082015190516361529e8760e01b815261ffff9091166004820152602401610545565b5050505050565b5f6109fc836109f7846002611bc6565b610f04565b50016020015160f01c90565b5f610a18836109f7846001611bc6565b828281518110610a2a57610a2a611b7a565b016020015160f81c905092915050565b5f610a4a836109f7846004611bc6565b50016020015160e01c90565b60605f610a638484610b45565b9050610a70848483610a78565b949350505050565b60608167ffffffffffffffff811115610a9357610a93611885565b6040519080825280601f01601f191660200182016040528015610abd576020820181803683370190505b5090506106198484835f86610f50565b610b156040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b6109188261010001515f610cfc565b6020810151815160609161091891610b3c9082610b45565b84519190610a78565b5f815b83518110610b5857610b58611bec565b5f610b638583610a08565b60ff169050610b73816001611bc6565b610b7d9083611bc6565b9150805f03610b8c5750610b92565b50610b48565b610a708382611bd9565b5f610ba8848484610f81565b610bb3878785610f81565b149695505050505050565b60c08101516020820181905281515111610bd55750565b5f610be7825f01518360200151610b45565b8260200151610bf69190611bc6565b8251909150610c0590826109e7565b61ffff166040830152610c19600282611bc6565b8251909150610c2890826109e7565b61ffff166060830152610c3c600282611bc6565b8251909150610c4b9082610a3a565b63ffffffff166080830152610c61600482611bc6565b82519091505f90610c7290836109e7565b61ffff169050610c83600283611bc6565b60a084018190529150610c968183611bc6565b60c0909301929092525050565b5f8080610cb085826108bb565b90505f610cbd855f6108bb565b90505b80821115610ce657610cd28684610f9a565b925081610cde81611c2d565b925050610cc0565b610cf28684875f610fbd565b9695505050505050565b610d446040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b82815260c0810182905261091881610bbe565b60208101515f610d6685610acd565b90505b80515160208201511015610e2057604081015161ffff16603014610dac5760408082015190516361529e8760e01b815261ffff9091166004820152602401610545565b5f610db682610ff8565b90505f610dcf5f8351846110149092919063ffffffff16565b9050610ddd818389896110b0565b15610e1057610df28760e001518683856111e4565b15610e005750505050505050565b60c08501849052610e1085610bbe565b5050610e1b81610bbe565b610d69565b508360e001516040516306cde0f360e01b81526004016105459190611afe565b80515160208201511015610ee5575f610e5882610b24565b9050610e718460e001518261131a90919063ffffffff16565b610e96578360e0015181604051636b80573f60e11b8152600401610545929190611c00565b5f610ea083610ff8565b90505f610eb95f8351846110149092919063ffffffff16565b9050610ec7818388886110b0565b15610ed457505050505050565b505050610ee081610bbe565b610e40565b8260e001516040516306cde0f360e01b81526004016105459190611afe565b8151811115610f4c5781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610545918391600401918252602082015260400190565b5050565b610f5e856109f78387611bc6565b610f6c836109f78385611bc6565b6109e08260208501018560208801018361133e565b5f610f90846109f78486611bc6565b5091016020012090565b5f610fa58383610a08565b60ff16610fb3836001611bc6565b6109159190611bc6565b5f610fc88585610f04565b610fd28383610f04565b610fe0838384865103610f81565b610fee868687895103610f81565b1495945050505050565b60a081015160c082015160609161091891610b3c908290611bd9565b604080516080810182525f808252602082018190529181019190915260608082015261104a6110435f85611bc6565b85906109e7565b61ffff16815261106561105e600285611bc6565b8590610a08565b60ff16602082015261107b61105e600385611bc6565b60ff1660408201526110a4611091600485611bc6565b61109c600485611bd9565b869190610a78565b60608201529392505050565b5f846020015160ff166003146110c757505f610a70565b826020015160ff16856040015160ff16146110e357505f610a70565b5f6110ed85611387565b90508360c0015161ffff168161ffff161461110b575f915050610a70565b8551610100165f03611120575f915050610a70565b60408087015160ff165f908152600260205220546001600160a01b03168061114c575f92505050610a70565b835160208501516040517fde8f50a10000000000000000000000000000000000000000000000000000000081526001600160a01b0384169263de8f50a19261119a928b929190600401611c42565b602060405180830381865afa1580156111b5573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906111d99190611c7a565b979650505050505050565b5f806111ef83611387565b90505b8451516020860151101561130f575f61120a86610b24565b9050611216818861131a565b611237578681604051636b80573f60e11b8152600401610545929190611c00565b60a086015160c08701515f9161125b91611252908290611bd9565b89519190611014565b90508261ffff16815f015161ffff1614611276575050611301565b856040015160ff16816020015160ff1614611292575050611301565b60408051808201909152606081525f60208201526112be86518a516112b79190611bc6565b82906115c7565b506112c9818a61163b565b506112d4818761163b565b506112eb8260400151825f0151846060015161165b565b156112fd576001945050505050610a70565b5050505b61130a85610bbe565b6111f2565b505f95945050505050565b5f815183511480156109155750508051602091820120825192909101919091201490565b5b601f81111561135f578151835260209283019290910190601f190161133f565b801561138257815183516001602084900360031b1b5f1901801990921691161783525b505050565b5f612000825111156113f5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4c6f6e67206b657973206e6f74207065726d69747465640000000000000000006044820152606401610545565b5f805f5b8451601f01811015611467575f816020870101519050855182602001111561142d5785518290036008026101000390811c901b5b7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff600882901c811694909401931691909101906020016113f9565b506010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c827dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff160191506010817fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff1601905080600883901b0191506020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c827bffffffff00000000ffffffff00000000ffffffff00000000ffffffff160191506040827fffffffffffffffff0000000000000000ffffffffffffffff000000000000000016901c8277ffffffffffffffff0000000000000000ffffffffffffffff16019150608082901c826fffffffffffffffffffffffffffffffff16019150601082901c61ffff16820191508192505050919050565b60408051808201909152606081525f60208201526115e6602083611c99565b1561160e576115f6602083611c99565b611601906020611bd9565b61160b9083611bc6565b91505b60208084018390526040518085525f8152908184010181811015611630575f80fd5b604052509192915050565b60408051808201909152606081525f60208201526109158383845161171b565b60ff83165f908152600360205260408120546001600160a01b031661168157505f610619565b60ff84165f90815260036020526040908190205490517ff7e83aee0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063f7e83aee906116dc9086908690600401611c00565b602060405180830381865afa1580156116f7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a709190611c7a565b60408051808201909152606081525f6020820152825182111561173c575f80fd5b8351515f61174a8483611bc6565b9050856020015181111561176c5761176c86611767836002611cb8565b6117ec565b85518051838201602001915f9180851115611785578482525b505050602086015b602086106117c557805182526117a4602083611bc6565b91506117b1602082611bc6565b90506117be602087611bd9565b955061178d565b5181515f1960208890036101000a0190811690199190911617905250849150509392505050565b81516117f883836115c7565b50611803838261163b565b50505050565b803560ff81168114611819575f80fd5b919050565b6001600160a01b0381168114611832575f80fd5b50565b5f8060408385031215611846575f80fd5b61184f83611809565b9150602083013561185f8161181e565b809150509250929050565b5f6020828403121561187a575f80fd5b81356109158161181e565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156118bc576118bc611885565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156118eb576118eb611885565b604052919050565b5f82601f830112611902575f80fd5b813567ffffffffffffffff81111561191c5761191c611885565b61192f601f8201601f19166020016118c2565b818152846020838601011115611943575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f83011261196e575f80fd5b8135602067ffffffffffffffff8083111561198b5761198b611885565b8260051b61199a8382016118c2565b93845285810183019383810190888611156119b3575f80fd5b84880192505b85831015611a42578235848111156119cf575f80fd5b88016040818b03601f19018113156119e5575f80fd5b6119ed611899565b87830135878111156119fd575f80fd5b611a0b8d8a838701016118f3565b825250908201359086821115611a1f575f80fd5b611a2d8c89848601016118f3565b818901528452505091840191908401906119b9565b98975050505050505050565b5f8060408385031215611a5f575f80fd5b823567ffffffffffffffff811115611a75575f80fd5b611a818582860161195f565b95602094909401359450505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b604081525f611ad06040830185611a90565b905063ffffffff831660208301529392505050565b5f60208284031215611af5575f80fd5b61091582611809565b602081525f6109156020830184611a90565b5f60208284031215611b20575f80fd5b813567ffffffffffffffff811115611b36575f80fd5b610a708482850161195f565b600181811c90821680611b5657607f821691505b602082108103611b7457634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b604081525f611ba06040830185611a90565b905060ff831660208301529392505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561091857610918611bb2565b8181038181111561091857610918611bb2565b634e487b7160e01b5f52600160045260245ffd5b604081525f611c126040830185611a90565b8281036020840152611c248185611a90565b95945050505050565b5f81611c3b57611c3b611bb2565b505f190190565b606081525f611c546060830186611a90565b8281036020840152611c668186611a90565b90508281036040840152610cf28185611a90565b5f60208284031215611c8a575f80fd5b81518015158114610915575f80fd5b5f82611cb357634e487b7160e01b5f52601260045260245ffd5b500690565b808202811582820484141761091857610918611bb256fea26469706673582212206ef89097f91c6916c60c9b09c43895478c9ae6b7f68d347b9d49feb35a2fb75664736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b506004361061009f575f3560e01c806373cc48a61161007257806398d35f201161005857806398d35f201461015b578063bdf95fef14610170578063c327deef14610183575f80fd5b806373cc48a6146101085780638da5cb5b14610148575f80fd5b8063020ed8d3146100a357806313af4035146100b857806328e7677d146100cb578063440f3d42146100de575b5f80fd5b6100b66100b1366004611835565b6101ab565b005b6100b66100c636600461186a565b610238565b6100b66100d9366004611835565b61027d565b6100f16100ec366004611a4e565b610302565b6040516100ff929190611abe565b60405180910390f35b610130610116366004611ae5565b60036020525f90815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020016100ff565b600154610130906001600160a01b031681565b6101636103e3565b6040516100ff9190611afe565b6100f161017e366004611b10565b61046e565b610130610191366004611ae5565b60026020525f90815260409020546001600160a01b031681565b6001546001600160a01b031633146101c1575f80fd5b60ff82165f81815260026020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527ff73c3c226af96b7f1ba666a21b3ceaf2be3ee6a365e3178fd9cd1eaae0075aa891015b60405180910390a15050565b6001546001600160a01b0316331461024e575f80fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6001546001600160a01b03163314610293575f80fd5b60ff82165f81815260036020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527f2fcc274c3b72dd483ab201bfa87295e3817e8b9b10693219873b722ca1af00c7910161022c565b60605f805f805461031290611b42565b80601f016020809104026020016040519081016040528092919081815260200182805461033e90611b42565b80156103895780601f1061036057610100808354040283529160200191610389565b820191905f5260205f20905b81548152906001019060200180831161036c57829003601f168201915b505050505090505f5b85518110156103d9575f6103c08783815181106103b1576103b1611b7a565b60200260200101518488610484565b61010081015160a0909101519450925050600101610392565b5091509250929050565b5f80546103ef90611b42565b80601f016020809104026020016040519081016040528092919081815260200182805461041b90611b42565b80156104665780601f1061043d57610100808354040283529160200191610466565b820191905f5260205f20905b81548152906001019060200180831161044957829003601f168201915b505050505081565b60605f61047b8342610302565b91509150915091565b60408051610140810182525f8082526020820181905291810182905260608082018390526080820183905260a0820183905260c082019290925260e08101829052610100810182905261012081019190915283516104e190610620565b90505f6104f182835f0151610761565b604083015190915060ff16610506825f6108bb565b1461054e578082604001516040517fe861b2bd000000000000000000000000000000000000000000000000000000008152600401610545929190611b8e565b60405180910390fd5b610120820181905260808201515f9084900360030b12156105b15760808201516040517fa784f87e00000000000000000000000000000000000000000000000000000000815263ffffffff91821660048201529084166024820152604401610545565b60a08201515f90840360030b121561060b5760a08201516040517fbd41036a00000000000000000000000000000000000000000000000000000000815263ffffffff91821660048201529084166024820152604401610545565b6106178183878761091e565b505b9392505050565b60408051610140810182525f8082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820181905261010082018190526101208201529061067a9083906109e7565b61ffff16815261068b826002610a08565b60ff16602082015261069e826003610a08565b60ff1660408201526106b1826004610a3a565b63ffffffff90811660608301526106cd908390600890610a3a16565b63ffffffff90811660808301526106e9908390600c90610a3a16565b63ffffffff90811660a08301526107059083906010906109e716565b61ffff1660c0820152610719826012610a56565b60e082018190525161075690610730906012611bc6565b8260e0015151601285516107449190611bd9565b61074e9190611bd9565b849190610a78565b610100820152919050565b60605f61076d84610acd565b90505b805151602082015110156108b457606081015161ffff166001146107cc5760608101516040517f98a5f31a00000000000000000000000000000000000000000000000000000000815261ffff9091166004820152602401610545565b81515f036107e4576107dd81610b24565b915061084d565b602081015181516107f491610b45565b825114158061081657508051602082015183516108149285925f92610b9c565b155b1561084d576040517fcbceee6f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8261ffff16816040015161ffff16146108a65760408082015190517fa6ff8a8a00000000000000000000000000000000000000000000000000000000815261ffff91821660048201529084166024820152604401610545565b6108af81610bbe565b610770565b5092915050565b5f805b835183106108ce576108ce611bec565b5f6108d98585610a08565b60ff1690506108e9816001611bc6565b6108f39085611bc6565b9350805f036109025750610915565b61090d600183611bc6565b9150506108be565b90505b92915050565b60e083015161092e908590610ca3565b61096b5760e08301516040517feaafc59b000000000000000000000000000000000000000000000000000000008152610545918691600401611c00565b5f6109768282610cfc565b9050602b61ffff16816040015161ffff160361099c57610997848483610d57565b6109e0565b603061ffff16816040015161ffff16036109bb57610997848483610e40565b60408082015190516361529e8760e01b815261ffff9091166004820152602401610545565b5050505050565b5f6109fc836109f7846002611bc6565b610f04565b50016020015160f01c90565b5f610a18836109f7846001611bc6565b828281518110610a2a57610a2a611b7a565b016020015160f81c905092915050565b5f610a4a836109f7846004611bc6565b50016020015160e01c90565b60605f610a638484610b45565b9050610a70848483610a78565b949350505050565b60608167ffffffffffffffff811115610a9357610a93611885565b6040519080825280601f01601f191660200182016040528015610abd576020820181803683370190505b5090506106198484835f86610f50565b610b156040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b6109188261010001515f610cfc565b6020810151815160609161091891610b3c9082610b45565b84519190610a78565b5f815b83518110610b5857610b58611bec565b5f610b638583610a08565b60ff169050610b73816001611bc6565b610b7d9083611bc6565b9150805f03610b8c5750610b92565b50610b48565b610a708382611bd9565b5f610ba8848484610f81565b610bb3878785610f81565b149695505050505050565b60c08101516020820181905281515111610bd55750565b5f610be7825f01518360200151610b45565b8260200151610bf69190611bc6565b8251909150610c0590826109e7565b61ffff166040830152610c19600282611bc6565b8251909150610c2890826109e7565b61ffff166060830152610c3c600282611bc6565b8251909150610c4b9082610a3a565b63ffffffff166080830152610c61600482611bc6565b82519091505f90610c7290836109e7565b61ffff169050610c83600283611bc6565b60a084018190529150610c968183611bc6565b60c0909301929092525050565b5f8080610cb085826108bb565b90505f610cbd855f6108bb565b90505b80821115610ce657610cd28684610f9a565b925081610cde81611c2d565b925050610cc0565b610cf28684875f610fbd565b9695505050505050565b610d446040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b82815260c0810182905261091881610bbe565b60208101515f610d6685610acd565b90505b80515160208201511015610e2057604081015161ffff16603014610dac5760408082015190516361529e8760e01b815261ffff9091166004820152602401610545565b5f610db682610ff8565b90505f610dcf5f8351846110149092919063ffffffff16565b9050610ddd818389896110b0565b15610e1057610df28760e001518683856111e4565b15610e005750505050505050565b60c08501849052610e1085610bbe565b5050610e1b81610bbe565b610d69565b508360e001516040516306cde0f360e01b81526004016105459190611afe565b80515160208201511015610ee5575f610e5882610b24565b9050610e718460e001518261131a90919063ffffffff16565b610e96578360e0015181604051636b80573f60e11b8152600401610545929190611c00565b5f610ea083610ff8565b90505f610eb95f8351846110149092919063ffffffff16565b9050610ec7818388886110b0565b15610ed457505050505050565b505050610ee081610bbe565b610e40565b8260e001516040516306cde0f360e01b81526004016105459190611afe565b8151811115610f4c5781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610545918391600401918252602082015260400190565b5050565b610f5e856109f78387611bc6565b610f6c836109f78385611bc6565b6109e08260208501018560208801018361133e565b5f610f90846109f78486611bc6565b5091016020012090565b5f610fa58383610a08565b60ff16610fb3836001611bc6565b6109159190611bc6565b5f610fc88585610f04565b610fd28383610f04565b610fe0838384865103610f81565b610fee868687895103610f81565b1495945050505050565b60a081015160c082015160609161091891610b3c908290611bd9565b604080516080810182525f808252602082018190529181019190915260608082015261104a6110435f85611bc6565b85906109e7565b61ffff16815261106561105e600285611bc6565b8590610a08565b60ff16602082015261107b61105e600385611bc6565b60ff1660408201526110a4611091600485611bc6565b61109c600485611bd9565b869190610a78565b60608201529392505050565b5f846020015160ff166003146110c757505f610a70565b826020015160ff16856040015160ff16146110e357505f610a70565b5f6110ed85611387565b90508360c0015161ffff168161ffff161461110b575f915050610a70565b8551610100165f03611120575f915050610a70565b60408087015160ff165f908152600260205220546001600160a01b03168061114c575f92505050610a70565b835160208501516040517fde8f50a10000000000000000000000000000000000000000000000000000000081526001600160a01b0384169263de8f50a19261119a928b929190600401611c42565b602060405180830381865afa1580156111b5573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906111d99190611c7a565b979650505050505050565b5f806111ef83611387565b90505b8451516020860151101561130f575f61120a86610b24565b9050611216818861131a565b611237578681604051636b80573f60e11b8152600401610545929190611c00565b60a086015160c08701515f9161125b91611252908290611bd9565b89519190611014565b90508261ffff16815f015161ffff1614611276575050611301565b856040015160ff16816020015160ff1614611292575050611301565b60408051808201909152606081525f60208201526112be86518a516112b79190611bc6565b82906115c7565b506112c9818a61163b565b506112d4818761163b565b506112eb8260400151825f0151846060015161165b565b156112fd576001945050505050610a70565b5050505b61130a85610bbe565b6111f2565b505f95945050505050565b5f815183511480156109155750508051602091820120825192909101919091201490565b5b601f81111561135f578151835260209283019290910190601f190161133f565b801561138257815183516001602084900360031b1b5f1901801990921691161783525b505050565b5f612000825111156113f5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4c6f6e67206b657973206e6f74207065726d69747465640000000000000000006044820152606401610545565b5f805f5b8451601f01811015611467575f816020870101519050855182602001111561142d5785518290036008026101000390811c901b5b7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff600882901c811694909401931691909101906020016113f9565b506010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c827dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff160191506010817fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff1601905080600883901b0191506020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c827bffffffff00000000ffffffff00000000ffffffff00000000ffffffff160191506040827fffffffffffffffff0000000000000000ffffffffffffffff000000000000000016901c8277ffffffffffffffff0000000000000000ffffffffffffffff16019150608082901c826fffffffffffffffffffffffffffffffff16019150601082901c61ffff16820191508192505050919050565b60408051808201909152606081525f60208201526115e6602083611c99565b1561160e576115f6602083611c99565b611601906020611bd9565b61160b9083611bc6565b91505b60208084018390526040518085525f8152908184010181811015611630575f80fd5b604052509192915050565b60408051808201909152606081525f60208201526109158383845161171b565b60ff83165f908152600360205260408120546001600160a01b031661168157505f610619565b60ff84165f90815260036020526040908190205490517ff7e83aee0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063f7e83aee906116dc9086908690600401611c00565b602060405180830381865afa1580156116f7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a709190611c7a565b60408051808201909152606081525f6020820152825182111561173c575f80fd5b8351515f61174a8483611bc6565b9050856020015181111561176c5761176c86611767836002611cb8565b6117ec565b85518051838201602001915f9180851115611785578482525b505050602086015b602086106117c557805182526117a4602083611bc6565b91506117b1602082611bc6565b90506117be602087611bd9565b955061178d565b5181515f1960208890036101000a0190811690199190911617905250849150509392505050565b81516117f883836115c7565b50611803838261163b565b50505050565b803560ff81168114611819575f80fd5b919050565b6001600160a01b0381168114611832575f80fd5b50565b5f8060408385031215611846575f80fd5b61184f83611809565b9150602083013561185f8161181e565b809150509250929050565b5f6020828403121561187a575f80fd5b81356109158161181e565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156118bc576118bc611885565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156118eb576118eb611885565b604052919050565b5f82601f830112611902575f80fd5b813567ffffffffffffffff81111561191c5761191c611885565b61192f601f8201601f19166020016118c2565b818152846020838601011115611943575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f83011261196e575f80fd5b8135602067ffffffffffffffff8083111561198b5761198b611885565b8260051b61199a8382016118c2565b93845285810183019383810190888611156119b3575f80fd5b84880192505b85831015611a42578235848111156119cf575f80fd5b88016040818b03601f19018113156119e5575f80fd5b6119ed611899565b87830135878111156119fd575f80fd5b611a0b8d8a838701016118f3565b825250908201359086821115611a1f575f80fd5b611a2d8c89848601016118f3565b818901528452505091840191908401906119b9565b98975050505050505050565b5f8060408385031215611a5f575f80fd5b823567ffffffffffffffff811115611a75575f80fd5b611a818582860161195f565b95602094909401359450505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b604081525f611ad06040830185611a90565b905063ffffffff831660208301529392505050565b5f60208284031215611af5575f80fd5b61091582611809565b602081525f6109156020830184611a90565b5f60208284031215611b20575f80fd5b813567ffffffffffffffff811115611b36575f80fd5b610a708482850161195f565b600181811c90821680611b5657607f821691505b602082108103611b7457634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b604081525f611ba06040830185611a90565b905060ff831660208301529392505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561091857610918611bb2565b8181038181111561091857610918611bb2565b634e487b7160e01b5f52600160045260245ffd5b604081525f611c126040830185611a90565b8281036020840152611c248185611a90565b95945050505050565b5f81611c3b57611c3b611bb2565b505f190190565b606081525f611c546060830186611a90565b8281036020840152611c668186611a90565b90508281036040840152610cf28185611a90565b5f60208284031215611c8a575f80fd5b81518015158114610915575f80fd5b5f82611cb357634e487b7160e01b5f52601260045260245ffd5b500690565b808202811582820484141761091857610918611bb256fea26469706673582212206ef89097f91c6916c60c9b09c43895478c9ae6b7f68d347b9d49feb35a2fb75664736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {},
  "inputSourceName": "project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol",
  "devdoc": {
    "errors": {
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor.",
        "params": {
          "_anchors": "The binary format RR entries for the root DS records."
        }
      },
      "setAlgorithm(uint8,address)": {
        "details": "Sets the contract address for a signature verification algorithm.      Callable only by the owner.",
        "params": {
          "algo": "The address of the algorithm contract.",
          "id": "The algorithm ID"
        }
      },
      "setDigest(uint8,address)": {
        "details": "Sets the contract address for a digest verification algorithm.      Callable only by the owner.",
        "params": {
          "digest": "The address of the digest contract.",
          "id": "The digest ID"
        }
      },
      "verifyRRSet((bytes,bytes)[])": {
        "details": "Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.",
        "params": {
          "input": "A list of signed RRSets."
        },
        "returns": {
          "inception": "The inception time of the signed record set.",
          "rrs": "The RRData from the last RRSet in the chain."
        }
      },
      "verifyRRSet((bytes,bytes)[],uint256)": {
        "details": "Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.",
        "params": {
          "input": "A list of signed RRSets.",
          "now": "The Unix timestamp to validate the records at."
        },
        "returns": {
          "inception": "The inception time of the signed record set.",
          "rrs": "The RRData from the last RRSet in the chain."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "1485800",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "algorithms(uint8)": "2613",
        "anchors()": "infinite",
        "digests(uint8)": "2570",
        "owner()": "2381",
        "setAlgorithm(uint8,address)": "28197",
        "setDigest(uint8,address)": "28252",
        "setOwner(address)": "26718",
        "verifyRRSet((bytes,bytes)[])": "infinite",
        "verifyRRSet((bytes,bytes)[],uint256)": "infinite"
      },
      "internal": {
        "validateRRs(struct RRUtils.SignedSet memory,uint16)": "infinite",
        "validateSignedSet(struct DNSSEC.RRSetWithSignature memory,bytes memory,uint256)": "infinite",
        "verifyDSHash(uint8,bytes memory,bytes memory)": "infinite",
        "verifyKeyWithDS(bytes memory,struct RRUtils.RRIterator memory,struct RRUtils.DNSKEY memory,bytes memory)": "infinite",
        "verifySignature(bytes memory,struct RRUtils.SignedSet memory,struct DNSSEC.RRSetWithSignature memory,bytes memory)": "infinite",
        "verifySignatureWithKey(struct RRUtils.DNSKEY memory,bytes memory,struct RRUtils.SignedSet memory,struct DNSSEC.RRSetWithSignature memory)": "infinite",
        "verifyWithDS(struct RRUtils.SignedSet memory,struct DNSSEC.RRSetWithSignature memory,struct RRUtils.RRIterator memory)": "infinite",
        "verifyWithKnownKey(struct RRUtils.SignedSet memory,struct DNSSEC.RRSetWithSignature memory,struct RRUtils.RRIterator memory)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_anchors\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"class\",\"type\":\"uint16\"}],\"name\":\"InvalidClass\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"labelsExpected\",\"type\":\"uint256\"}],\"name\":\"InvalidLabelCount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proofType\",\"type\":\"uint16\"}],\"name\":\"InvalidProofType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRRSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rrsetName\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signerName\",\"type\":\"bytes\"}],\"name\":\"InvalidSignerName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signerName\",\"type\":\"bytes\"}],\"name\":\"NoMatchingProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signerName\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofName\",\"type\":\"bytes\"}],\"name\":\"ProofNameMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"expiration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"now\",\"type\":\"uint32\"}],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"now\",\"type\":\"uint32\"}],\"name\":\"SignatureNotValidYet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"rrsetType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sigType\",\"type\":\"uint16\"}],\"name\":\"SignatureTypeMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AlgorithmUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"DigestUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"algorithms\",\"outputs\":[{\"internalType\":\"contract Algorithm\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anchors\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"digests\",\"outputs\":[{\"internalType\":\"contract Digest\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"contract Algorithm\",\"name\":\"algo\",\"type\":\"address\"}],\"name\":\"setAlgorithm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"contract Digest\",\"name\":\"digest\",\"type\":\"address\"}],\"name\":\"setDigest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rrset\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct DNSSEC.RRSetWithSignature[]\",\"name\":\"input\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"now\",\"type\":\"uint256\"}],\"name\":\"verifyRRSet\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"rrs\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rrset\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct DNSSEC.RRSetWithSignature[]\",\"name\":\"input\",\"type\":\"tuple[]\"}],\"name\":\"verifyRRSet\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"rrs\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor.\",\"params\":{\"_anchors\":\"The binary format RR entries for the root DS records.\"}},\"setAlgorithm(uint8,address)\":{\"details\":\"Sets the contract address for a signature verification algorithm.      Callable only by the owner.\",\"params\":{\"algo\":\"The address of the algorithm contract.\",\"id\":\"The algorithm ID\"}},\"setDigest(uint8,address)\":{\"details\":\"Sets the contract address for a digest verification algorithm.      Callable only by the owner.\",\"params\":{\"digest\":\"The address of the digest contract.\",\"id\":\"The digest ID\"}},\"verifyRRSet((bytes,bytes)[])\":{\"details\":\"Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\",\"params\":{\"input\":\"A list of signed RRSets.\"},\"returns\":{\"inception\":\"The inception time of the signed record set.\",\"rrs\":\"The RRData from the last RRSet in the chain.\"}},\"verifyRRSet((bytes,bytes)[],uint256)\":{\"details\":\"Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\",\"params\":{\"input\":\"A list of signed RRSets.\",\"now\":\"The Unix timestamp to validate the records at.\"},\"returns\":{\"inception\":\"The inception time of the signed record set.\",\"rrs\":\"The RRData from the last RRSet in the chain.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol\":\"DNSSECImpl\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@ensdomains/solsha1/contracts/=project/lib/solsha1/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts-v5/=project/lib/openzeppelin-contracts/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/ens-contracts/:@unruggable/gateways/=project/lib/unruggable-gateways/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\",\"project/test/mocks/v1/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd85358722045348893aeedd23539816c9d1b218ab801a3fcd1ec4e38ecc8eb22\",\"license\":\"BSD-2-Clause\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/DNSSEC.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract DNSSEC {\\n    bytes public anchors;\\n\\n    struct RRSetWithSignature {\\n        bytes rrset;\\n        bytes sig;\\n    }\\n\\n    event AlgorithmUpdated(uint8 id, address addr);\\n    event DigestUpdated(uint8 id, address addr);\\n\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input\\n    ) external view virtual returns (bytes memory rrs, uint32 inception);\\n\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input,\\n        uint256 now\\n    ) public view virtual returns (bytes memory rrs, uint32 inception);\\n}\\n\",\"keccak256\":\"0xee6a236a59e5db8418c98ee4640a91987d26533c02d305cc6c7a37a3ac4ee907\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./RRUtils.sol\\\";\\nimport \\\"./DNSSEC.sol\\\";\\nimport \\\"./algorithms/Algorithm.sol\\\";\\nimport \\\"./digests/Digest.sol\\\";\\nimport \\\"../utils/BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/*\\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\\n *       - Proofs involving wildcard names will not validate.\\n *       - TTLs on records are ignored, as data is not stored persistently.\\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\\n */\\ncontract DNSSECImpl is DNSSEC, Owned {\\n    using Buffer for Buffer.buffer;\\n    using BytesUtils for bytes;\\n    using RRUtils for *;\\n\\n    uint16 constant DNSCLASS_IN = 1;\\n\\n    uint16 constant DNSTYPE_DS = 43;\\n    uint16 constant DNSTYPE_DNSKEY = 48;\\n\\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\\n\\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\\n    error SignatureNotValidYet(uint32 inception, uint32 now);\\n    error SignatureExpired(uint32 expiration, uint32 now);\\n    error InvalidClass(uint16 class);\\n    error InvalidRRSet();\\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\\n    error InvalidProofType(uint16 proofType);\\n    error ProofNameMismatch(bytes signerName, bytes proofName);\\n    error NoMatchingProof(bytes signerName);\\n\\n    mapping(uint8 => Algorithm) public algorithms;\\n    mapping(uint8 => Digest) public digests;\\n\\n    /// @dev Constructor.\\n    /// @param _anchors The binary format RR entries for the root DS records.\\n    constructor(bytes memory _anchors) {\\n        // Insert the 'trust anchors' - the key hashes that start the chain\\n        // of trust for all other records.\\n        anchors = _anchors;\\n    }\\n\\n    /// @dev Sets the contract address for a signature verification algorithm.\\n    ///      Callable only by the owner.\\n    /// @param id The algorithm ID\\n    /// @param algo The address of the algorithm contract.\\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\\n        algorithms[id] = algo;\\n        emit AlgorithmUpdated(id, address(algo));\\n    }\\n\\n    /// @dev Sets the contract address for a digest verification algorithm.\\n    ///      Callable only by the owner.\\n    /// @param id The digest ID\\n    /// @param digest The address of the digest contract.\\n    function setDigest(uint8 id, Digest digest) public owner_only {\\n        digests[id] = digest;\\n        emit DigestUpdated(id, address(digest));\\n    }\\n\\n    /// @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\\n    ///      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\\n    /// @param input A list of signed RRSets.\\n    /// @return rrs The RRData from the last RRSet in the chain.\\n    /// @return inception The inception time of the signed record set.\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory rrs, uint32 inception)\\n    {\\n        return verifyRRSet(input, block.timestamp);\\n    }\\n\\n    /// @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\\n    ///      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\\n    /// @param input A list of signed RRSets.\\n    /// @param now The Unix timestamp to validate the records at.\\n    /// @return rrs The RRData from the last RRSet in the chain.\\n    /// @return inception The inception time of the signed record set.\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input,\\n        uint256 now\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bytes memory rrs, uint32 inception)\\n    {\\n        bytes memory proof = anchors;\\n        for (uint256 i = 0; i < input.length; i++) {\\n            RRUtils.SignedSet memory rrset = validateSignedSet(\\n                input[i],\\n                proof,\\n                now\\n            );\\n            proof = rrset.data;\\n            inception = rrset.inception;\\n        }\\n        return (proof, inception);\\n    }\\n\\n    /// @dev Validates an RRSet against the already trusted RR provided in `proof`.\\n    ///\\n    /// @param input The signed RR set. This is in the format described in section\\n    ///        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\\n    ///        data, followed by a series of canonicalised RR records that the signature\\n    ///        applies to.\\n    /// @param proof The DNSKEY or DS to validate the signature against.\\n    /// @param now The current timestamp.\\n    function validateSignedSet(\\n        RRSetWithSignature memory input,\\n        bytes memory proof,\\n        uint256 now\\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\\n        rrset = input.rrset.readSignedSet();\\n\\n        // Do some basic checks on the RRs and extract the name\\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\\n        if (name.labelCount(0) != rrset.labels) {\\n            revert InvalidLabelCount(name, rrset.labels);\\n        }\\n        rrset.name = name;\\n\\n        // All comparisons involving the Signature Expiration and\\n        // Inception fields MUST use \\\"serial number arithmetic\\\", as\\n        // defined in RFC 1982\\n\\n        // o  The validator's notion of the current time MUST be less than or\\n        //    equal to the time listed in the RRSIG RR's Expiration field.\\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\\n            revert SignatureExpired(rrset.expiration, uint32(now));\\n        }\\n\\n        // o  The validator's notion of the current time MUST be greater than or\\n        //    equal to the time listed in the RRSIG RR's Inception field.\\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\\n        }\\n\\n        // Validate the signature\\n        verifySignature(name, rrset, input, proof);\\n\\n        return rrset;\\n    }\\n\\n    /// @dev Validates a set of RRs.\\n    /// @param rrset The RR set.\\n    /// @param typecovered The type covered by the RRSIG record.\\n    function validateRRs(\\n        RRUtils.SignedSet memory rrset,\\n        uint16 typecovered\\n    ) internal pure returns (bytes memory name) {\\n        // Iterate over all the RRs\\n        for (\\n            RRUtils.RRIterator memory iter = rrset.rrs();\\n            !iter.done();\\n            iter.next()\\n        ) {\\n            // We only support class IN (Internet)\\n            if (iter.class != DNSCLASS_IN) {\\n                revert InvalidClass(iter.class);\\n            }\\n\\n            if (name.length == 0) {\\n                name = iter.name();\\n            } else {\\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\\n                // repeatedly.\\n                if (\\n                    name.length != iter.data.nameLength(iter.offset) ||\\n                    !name.equals(0, iter.data, iter.offset, name.length)\\n                ) {\\n                    revert InvalidRRSet();\\n                }\\n            }\\n\\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\\n            if (iter.dnstype != typecovered) {\\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\\n            }\\n        }\\n    }\\n\\n    /// @dev Performs signature verification.\\n    ///\\n    /// Throws or reverts if unable to verify the record.\\n    ///\\n    /// @param name The name of the RRSIG record, in DNS label-sequence format.\\n    /// @param data The original data to verify.\\n    /// @param proof A DS or DNSKEY record that's already verified by the oracle.\\n    function verifySignature(\\n        bytes memory name,\\n        RRUtils.SignedSet memory rrset,\\n        RRSetWithSignature memory data,\\n        bytes memory proof\\n    ) internal view {\\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\\n        //    that contains the RRset.\\n        if (!name.isSubdomainOf(rrset.signerName)) {\\n            revert InvalidSignerName(name, rrset.signerName);\\n        }\\n\\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\\n        // Check the proof\\n        if (proofRR.dnstype == DNSTYPE_DS) {\\n            verifyWithDS(rrset, data, proofRR);\\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\\n            verifyWithKnownKey(rrset, data, proofRR);\\n        } else {\\n            revert InvalidProofType(proofRR.dnstype);\\n        }\\n    }\\n\\n    /// @dev Attempts to verify a signed RRSET against an already known public key.\\n    /// @param rrset The signed set to verify.\\n    /// @param data The original data the signed set was read from.\\n    /// @param proof The serialized DS or DNSKEY record to use as proof.\\n    function verifyWithKnownKey(\\n        RRUtils.SignedSet memory rrset,\\n        RRSetWithSignature memory data,\\n        RRUtils.RRIterator memory proof\\n    ) internal view {\\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\\n        for (; !proof.done(); proof.next()) {\\n            bytes memory proofName = proof.name();\\n            if (!proofName.equals(rrset.signerName)) {\\n                revert ProofNameMismatch(rrset.signerName, proofName);\\n            }\\n\\n            bytes memory keyrdata = proof.rdata();\\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\\n                0,\\n                keyrdata.length\\n            );\\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\\n                return;\\n            }\\n        }\\n        revert NoMatchingProof(rrset.signerName);\\n    }\\n\\n    /// @dev Attempts to verify some data using a provided key and a signature.\\n    /// @param dnskey The dns key record to verify the signature with.\\n    /// @param rrset The signed RRSET being verified.\\n    /// @param data The original data `rrset` was decoded from.\\n    /// @return True iff the key verifies the signature.\\n    function verifySignatureWithKey(\\n        RRUtils.DNSKEY memory dnskey,\\n        bytes memory keyrdata,\\n        RRUtils.SignedSet memory rrset,\\n        RRSetWithSignature memory data\\n    ) internal view returns (bool) {\\n        // TODO: Check key isn't expired, unless updating key itself\\n\\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\\n        if (dnskey.protocol != 3) {\\n            return false;\\n        }\\n\\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\\n        //   the zone's apex DNSKEY RRset.\\n        if (dnskey.algorithm != rrset.algorithm) {\\n            return false;\\n        }\\n        uint16 computedkeytag = keyrdata.computeKeytag();\\n        if (computedkeytag != rrset.keytag) {\\n            return false;\\n        }\\n\\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\\n        //   set.\\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\\n            return false;\\n        }\\n\\n        Algorithm algorithm = algorithms[dnskey.algorithm];\\n        if (address(algorithm) == address(0)) {\\n            return false;\\n        }\\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\\n    }\\n\\n    /// @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\\n    ///      that the record\\n    /// @param rrset The signed set to verify.\\n    /// @param data The original data the signed set was read from.\\n    /// @param proof The serialized DS or DNSKEY record to use as proof.\\n    function verifyWithDS(\\n        RRUtils.SignedSet memory rrset,\\n        RRSetWithSignature memory data,\\n        RRUtils.RRIterator memory proof\\n    ) internal view {\\n        uint256 proofOffset = proof.offset;\\n        for (\\n            RRUtils.RRIterator memory iter = rrset.rrs();\\n            !iter.done();\\n            iter.next()\\n        ) {\\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\\n                revert InvalidProofType(iter.dnstype);\\n            }\\n\\n            bytes memory keyrdata = iter.rdata();\\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\\n                0,\\n                keyrdata.length\\n            );\\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\\n                // It's self-signed - look for a DS record to verify it.\\n                if (\\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\\n                ) {\\n                    return;\\n                }\\n                // Rewind proof iterator to the start for the next loop iteration.\\n                proof.nextOffset = proofOffset;\\n                proof.next();\\n            }\\n        }\\n        revert NoMatchingProof(rrset.signerName);\\n    }\\n\\n    /// @dev Attempts to verify a key using DS records.\\n    /// @param keyname The DNS name of the key, in DNS label-sequence format.\\n    /// @param dsrrs The DS records to use in verification.\\n    /// @param dnskey The dnskey to verify.\\n    /// @param keyrdata The RDATA section of the key.\\n    /// @return True if a DS record verifies this key.\\n    function verifyKeyWithDS(\\n        bytes memory keyname,\\n        RRUtils.RRIterator memory dsrrs,\\n        RRUtils.DNSKEY memory dnskey,\\n        bytes memory keyrdata\\n    ) internal view returns (bool) {\\n        uint16 keytag = keyrdata.computeKeytag();\\n        for (; !dsrrs.done(); dsrrs.next()) {\\n            bytes memory proofName = dsrrs.name();\\n            if (!proofName.equals(keyname)) {\\n                revert ProofNameMismatch(keyname, proofName);\\n            }\\n\\n            RRUtils.DS memory ds = dsrrs.data.readDS(\\n                dsrrs.rdataOffset,\\n                dsrrs.nextOffset - dsrrs.rdataOffset\\n            );\\n            if (ds.keytag != keytag) {\\n                continue;\\n            }\\n            if (ds.algorithm != dnskey.algorithm) {\\n                continue;\\n            }\\n\\n            Buffer.buffer memory buf;\\n            buf.init(keyname.length + keyrdata.length);\\n            buf.append(keyname);\\n            buf.append(keyrdata);\\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Attempts to verify a DS record's hash value against some data.\\n    /// @param digesttype The digest ID from the DS record.\\n    /// @param data The data to digest.\\n    /// @param digest The digest data to check against.\\n    /// @return True if the digest matches.\\n    function verifyDSHash(\\n        uint8 digesttype,\\n        bytes memory data,\\n        bytes memory digest\\n    ) internal view returns (bool) {\\n        if (address(digests[digesttype]) == address(0)) {\\n            return false;\\n        }\\n        return digests[digesttype].verify(data, digest);\\n    }\\n}\\n\",\"keccak256\":\"0x20ad4e72e0936916cd20e219fe0bcc048da5bc68fc1f8bc9f7bbf4e98d67d5d1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/Owned.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/// @dev Contract mixin for 'owned' contracts.\\ncontract Owned {\\n    address public owner;\\n\\n    modifier owner_only() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    function setOwner(address newOwner) public owner_only {\\n        owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x38354db6c6151626791916f56725eb97d4cdb2da0c8a0fa278c7fc128b5f04a9\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/// @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /// @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return The length of the DNS name at 'offset', in bytes.\\n    function nameLength(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint256 labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /// @dev Returns a DNS format name at the specified offset of self.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return ret The name.\\n    function readName(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes memory ret) {\\n        uint256 len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /// @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return The number of labels in the DNS name at 'offset', in bytes.\\n    function labelCount(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint256 labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint256 constant RRSIG_TYPE = 0;\\n    uint256 constant RRSIG_ALGORITHM = 2;\\n    uint256 constant RRSIG_LABELS = 3;\\n    uint256 constant RRSIG_TTL = 4;\\n    uint256 constant RRSIG_EXPIRATION = 8;\\n    uint256 constant RRSIG_INCEPTION = 12;\\n    uint256 constant RRSIG_KEY_TAG = 16;\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(\\n        bytes memory data\\n    ) internal pure returns (SignedSet memory self) {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\n        );\\n    }\\n\\n    function rrs(\\n        SignedSet memory rrset\\n    ) internal pure returns (RRIterator memory) {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /// @dev An iterator over resource records.\\n    struct RRIterator {\\n        bytes data;\\n        uint256 offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint256 rdataOffset;\\n        uint256 nextOffset;\\n    }\\n\\n    /// @dev Begins iterating over resource records.\\n    /// @param self The byte string to read from.\\n    /// @param offset The offset to start reading at.\\n    /// @return ret An iterator object.\\n    function iterateRRs(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (RRIterator memory ret) {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /// @dev Returns true iff there are more RRs to iterate.\\n    /// @param iter The iterator to check.\\n    /// @return True iff the iterator has finished.\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /// @dev Moves the iterator to the next resource record.\\n    /// @param iter The iterator to advance.\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint256 rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /// @dev Returns the name of the current record.\\n    /// @param iter The iterator.\\n    /// @return A new bytes object containing the owner name from the RR.\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.offset,\\n                nameLength(iter.data, iter.offset)\\n            );\\n    }\\n\\n    /// @dev Returns the rdata portion of the current record.\\n    /// @param iter The iterator.\\n    /// @return A new bytes object containing the RR's RDATA.\\n    function rdata(\\n        RRIterator memory iter\\n    ) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.rdataOffset,\\n                iter.nextOffset - iter.rdataOffset\\n            );\\n    }\\n\\n    uint256 constant DNSKEY_FLAGS = 0;\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\n    uint256 constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(\\n            offset + DNSKEY_PUBKEY,\\n            length - DNSKEY_PUBKEY\\n        );\\n    }\\n\\n    uint256 constant DS_KEY_TAG = 0;\\n    uint256 constant DS_ALGORITHM = 2;\\n    uint256 constant DS_DIGEST_TYPE = 3;\\n    uint256 constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    function isSubdomainOf(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        uint256 off = 0;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        while (counts > othercounts) {\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        return self.equals(off, other, 0);\\n    }\\n\\n    function compareNames(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (int256) {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint256 off;\\n        uint256 otheroff;\\n        uint256 prevoff;\\n        uint256 otherprevoff;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if (otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return\\n            self.compare(\\n                prevoff + 1,\\n                self.readUint8(prevoff),\\n                other,\\n                otherprevoff + 1,\\n                other.readUint8(otherprevoff)\\n            );\\n    }\\n\\n    /// @dev Compares two serial numbers using RFC1982 serial number math.\\n    function serialNumberGte(\\n        uint32 i1,\\n        uint32 i2\\n    ) internal pure returns (bool) {\\n        unchecked {\\n            return int32(i1) - int32(i2) >= 0;\\n        }\\n    }\\n\\n    function progress(\\n        bytes memory body,\\n        uint256 off\\n    ) internal pure returns (uint256) {\\n        return off + 1 + body.readUint8(off);\\n    }\\n\\n    /// @dev Computes the keytag for a chunk of data.\\n    /// @param data The data to compute a keytag for.\\n    /// @return The computed key tag.\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n        /* This function probably deserves some explanation.\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\n         *\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n         *         uint ac;\\n         *         for (uint i = 0; i < data.length; i++) {\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\n         *         }\\n         *         return uint16(ac + (ac >> 16));\\n         *     }\\n         *\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\n         * large words work in our favour.\\n         *\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\n         *\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\n         * and the remaining sums can be done just on ac1.\\n         */\\n        unchecked {\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\n            uint256 ac1;\\n            uint256 ac2;\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(add(add(data, 32), i))\\n                }\\n                if (i + 32 > data.length) {\\n                    uint256 unused = 256 - (data.length - i) * 8;\\n                    word = (word >> unused) << unused;\\n                }\\n                ac1 +=\\n                    (word &\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\n                    8;\\n                ac2 += (word &\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\n            }\\n            ac1 =\\n                (ac1 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac1 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac2 =\\n                (ac2 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac2 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac1 = (ac1 << 8) + ac2;\\n            ac1 =\\n                (ac1 &\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\n                    32);\\n            ac1 =\\n                (ac1 &\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\n                    64);\\n            ac1 =\\n                (ac1 &\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\n                (ac1 >> 128);\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\n            return uint16(ac1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdbab10dde632a1a02ee1c706bd4a31f9fb6195bd15a360528f7f6615e8fc895a\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/// @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\ninterface Algorithm {\\n    /// @dev Verifies a signature.\\n    /// @param key The public key to verify with.\\n    /// @param data The signed data to verify.\\n    /// @param signature The signature to verify.\\n    /// @return True iff the signature is valid.\\n    function verify(\\n        bytes calldata key,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xbcbdc06d72b64903e733e7ddfbf59c35c984c3eb0022baacab12c97292cc13df\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/digests/Digest.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/// @dev An interface for contracts implementing a DNSSEC digest.\\ninterface Digest {\\n    /// @dev Verifies a cryptographic hash.\\n    /// @param data The data to hash.\\n    /// @param hash The hash to compare to.\\n    /// @return True iff the hashed data matches the provided hash value.\\n    function verify(\\n        bytes calldata data,\\n        bytes calldata hash\\n    ) external pure virtual returns (bool);\\n}\\n\",\"keccak256\":\"0x5681a22475fbc84fd7f572983b2f7f943f78f856ac3719661fa5d2f0a6911868\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 3746,
        "contract": "project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "anchors",
        "offset": 0,
        "slot": "0",
        "type": "t_bytes_storage"
      },
      {
        "astId": 4741,
        "contract": "project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "owner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3878,
        "contract": "project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "algorithms",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint8,t_contract(Algorithm)5905)"
      },
      {
        "astId": 3883,
        "contract": "project/lib/ens-contracts/contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "digests",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint8,t_contract(Digest)7746)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(Algorithm)5905": {
        "encoding": "inplace",
        "label": "contract Algorithm",
        "numberOfBytes": "20"
      },
      "t_contract(Digest)7746": {
        "encoding": "inplace",
        "label": "contract Digest",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint8,t_contract(Algorithm)5905)": {
        "encoding": "mapping",
        "key": "t_uint8",
        "label": "mapping(uint8 => contract Algorithm)",
        "numberOfBytes": "32",
        "value": "t_contract(Algorithm)5905"
      },
      "t_mapping(t_uint8,t_contract(Digest)7746)": {
        "encoding": "mapping",
        "key": "t_uint8",
        "label": "mapping(uint8 => contract Digest)",
        "numberOfBytes": "32",
        "value": "t_contract(Digest)7746"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000005e00002b000100000e1000244a5c080249aac11d7b6f6446702e54a1607371607a1a41855200fd2ce1cdde32f24e8fb500002b000100000e1000244f660802e06d44b80b8f1d39a95c0b0d7c65d08458e880409bbc683457104237c7f8ec8d0000",
  "transaction": {
    "hash": "0xa4b7980d939e8f14da9a48fc782febed4c3144955cf512034a7c10c3be2ad2a1",
    "nonce": "0x11",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0xffdf8e947031ab00c9511c9f1984f39635a0b400e9c9c5b83938c76d07648c76",
    "blockNumber": "0x12",
    "transactionIndex": "0x0"
  }
}
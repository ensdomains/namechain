{
  "address": "0x922d6956c99e12dfeb3224dea977d0939758a1fe",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_previousRegistrar",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_resolver",
          "type": "address"
        },
        {
          "internalType": "contract DNSSEC",
          "name": "_dnssec",
          "type": "address"
        },
        {
          "internalType": "contract PublicSuffixList",
          "name": "_suffixes",
          "type": "address"
        },
        {
          "internalType": "contract ENS",
          "name": "_ens",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "InvalidPublicSuffix",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoOwnerRecordFound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "PermissionDenied",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PreconditionNotMet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "StaleProof",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "dnsname",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "suffixes",
          "type": "address"
        }
      ],
      "name": "NewPublicSuffixList",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "domain",
          "type": "bytes"
        }
      ],
      "name": "enableNode",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ens",
      "outputs": [
        {
          "internalType": "contract ENS",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "inceptions",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracle",
      "outputs": [
        {
          "internalType": "contract DNSSEC",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousRegistrar",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "rrset",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "sig",
              "type": "bytes"
            }
          ],
          "internalType": "struct DNSSEC.RRSetWithSignature[]",
          "name": "input",
          "type": "tuple[]"
        }
      ],
      "name": "proveAndClaim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "rrset",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "sig",
              "type": "bytes"
            }
          ],
          "internalType": "struct DNSSEC.RRSetWithSignature[]",
          "name": "input",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "proveAndClaimWithResolver",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "resolver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract PublicSuffixList",
          "name": "_suffixes",
          "type": "address"
        }
      ],
      "name": "setPublicSuffixList",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "suffixes",
      "outputs": [
        {
          "internalType": "contract PublicSuffixList",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "contractName": "DNSRegistrar",
  "sourceName": "lib/ens-contracts/contracts/dnsregistrar/DNSRegistrar.sol",
  "bytecode": "0x610100604052348015610010575f80fd5b5060405161215638038061215683398101604081905261002f916100be565b6001600160a01b0385811660c05284811660e05283811660a0525f80546001600160a01b03191691841691821790556040519081527f9176b7f47e4504df5e5516c99d90d82ac7cbd49cc77e7f22ba2ac2f2e3a3eba89060200160405180910390a16001600160a01b03166080525061012f92505050565b6001600160a01b03811681146100bb575f80fd5b50565b5f805f805f60a086880312156100d2575f80fd5b85516100dd816100a7565b60208701519095506100ee816100a7565b60408701519094506100ff816100a7565b6060870151909350610110816100a7565b6080870151909250610121816100a7565b809150509295509295909350565b60805160a05160c05160e051611fa86101ae5f395f818160f501528181610c9a0152610d4c01525f818161022a0152610b2701525f818161020301526107d701525f81816101bb0152818161038b015281816104e00152818161069201528181610aa901528181610b7d01528181610cc20152610d7a0152611fa85ff3fe608060405234801561000f575f80fd5b50600436106100c4575f3560e01c806329d566301161007d5780636f951221116100585780636f951221146101dd5780637dc0d1d0146101fe578063ab14ec5914610225575f80fd5b806329d566301461019157806330349ebe146101a45780633f15457f146101b6575f80fd5b806306963218116100ad578063069632181461012f5780631ecfc4111461014457806325916d4114610157575f80fd5b806301ffc9a7146100c857806304f3bcec146100f0575b5f80fd5b6100db6100d636600461195c565b61024c565b60405190151581526020015b60405180910390f35b6101177f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e7565b61014261013d366004611b88565b6102e4565b005b610142610152366004611c0c565b6104c8565b61017c610165366004611c27565b60016020525f908152604090205463ffffffff1681565b60405163ffffffff90911681526020016100e7565b61014261019f366004611c3e565b610637565b5f54610117906001600160a01b031681565b6101177f000000000000000000000000000000000000000000000000000000000000000081565b6101f06101eb366004611c9e565b610706565b6040519081526020016100e7565b6101177f000000000000000000000000000000000000000000000000000000000000000081565b6101177f000000000000000000000000000000000000000000000000000000000000000081565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a70000000000000000000000000000000000000000000000000000000014806102de57507fffffffff0000000000000000000000000000000000000000000000000000000082167f2f43542800000000000000000000000000000000000000000000000000000000145b92915050565b5f805f6102f187876107d0565b91945092509050336001600160a01b03821614610350576040517fe03f60240000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03821660248201526044015b60405180910390fd5b6040516305ef2c7f60e41b815260048101849052602481018390526001600160a01b03828116604483015286811660648301525f60848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a4015f604051808303815f87803b1580156103cc575f80fd5b505af11580156103de573d5f803e3d5ffd5b505050506001600160a01b038416156104bf576001600160a01b03851661041857604051633c584f1360e21b815260040160405180910390fd5b60408051602081018590529081018390525f9060600160408051808303601f190181529082905280516020909101207fd5fa2b00000000000000000000000000000000000000000000000000000000008252600482018190526001600160a01b03878116602484015290925087169063d5fa2b00906044015f604051808303815f87803b1580156104a7575f80fd5b505af11580156104b9573d5f803e3d5ffd5b50505050505b50505050505050565b6040516302571be360e01b81525f60048201819052907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa15801561052d573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105519190611cd0565b90505f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610590573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105b49190611cd0565b9050336001600160a01b038216146105ca575f80fd5b5f80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0385169081179091556040519081527f9176b7f47e4504df5e5516c99d90d82ac7cbd49cc77e7f22ba2ac2f2e3a3eba89060200160405180910390a1505050565b5f805f61064485856107d0565b6040517f06ab592300000000000000000000000000000000000000000000000000000000815260048101849052602481018390526001600160a01b03828116604483015293965091945092507f0000000000000000000000000000000000000000000000000000000000000000909116906306ab5923906064016020604051808303815f875af11580156106da573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106fe9190611ceb565b505050505050565b5f80546040517f4f89059e0000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690634f89059e9061074f908590600401611d30565b602060405180830381865afa15801561076a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061078e9190611d42565b6107c657816040517f396e24b80000000000000000000000000000000000000000000000000000000081526004016103479190611d30565b6102de825f610a01565b5f805f805f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bdf95fef876040518263ffffffff1660e01b81526004016108219190611d61565b5f60405180830381865afa15801561083b573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526108629190810190611de6565b90925090505f6108728882610e09565b60ff16905061088388600183610e40565b94505f6108b5610894836001611e8c565b6001848c516108a39190611e9f565b6108ad9190611e9f565b8b9190610e59565b90506108c081610706565b96505f87876040516020016108df929190918252602082015260400190565b60408051808303601f1901815291815281516020928301205f81815260019093529082205490925063ffffffff16850360030b121561094a576040517f2dd6a7af00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f818152600160205260408120805463ffffffff191663ffffffff87161790556109748b87610eb5565b9097509050806109b0576040517f6260f6f800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b866001600160a01b0316827f87db02a0e483e2818060eddcbb3488ce44e35aff49a70d92c2aa6c8046cf01e28d886040516109ec929190611eb2565b60405180910390a35050505050509250925092565b5f80610a0d8484610e09565b60ff169050805f03610a2257505f90506102de565b5f610a4185610a318487611e8c565b610a3c906001611e8c565b610a01565b90505f610a5a610a52866001611e8c565b879085610e40565b604080516020810185905290810182905290915060600160408051601f198184030181529082905280516020909101206302571be360e01b82526004820181905294505f906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa158015610aee573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b129190611cd0565b90506001600160a01b0381161580610b5b57507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b0316145b15610dd65782610d21576040516302571be360e01b81525f60048201819052907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa158015610bca573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bee9190611cd0565b6040517f8cb8ecec000000000000000000000000000000000000000000000000000000008152600481018590523060248201529091506001600160a01b03821690638cb8ecec906044015f604051808303815f87803b158015610c4f575f80fd5b505af1158015610c61573d5f803e3d5ffd5b50506040517f1896f70a000000000000000000000000000000000000000000000000000000008152600481018990526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660248301527f0000000000000000000000000000000000000000000000000000000000000000169250631896f70a91506044015f604051808303815f87803b158015610d05575f80fd5b505af1158015610d17573d5f803e3d5ffd5b5050505050610dff565b6040516305ef2c7f60e41b815260048101849052602481018390523060448201526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660648301525f60848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a4015f604051808303815f87803b158015610dbb575f80fd5b505af1158015610dcd573d5f803e3d5ffd5b50505050610dff565b6001600160a01b0381163014610dff57604051633c584f1360e21b815260040160405180910390fd5b5050505092915050565b5f610e1e83610e19846001611e8c565b610fbd565b828281518110610e3057610e30611ed9565b016020015160f81c905092915050565b5f610e4f84610e198486611e8c565b5091016020012090565b60608167ffffffffffffffff811115610e7457610e7461199b565b6040519080825280601f01601f191660200182016040528015610e9e576020820181803683370190505b509050610eae8484835f86611009565b9392505050565b5f80610ed36040518060400160405280606081526020015f81525090565b610eeb85516005610ee49190611e8c565b8290611041565b5060408051808201909152600581527f045f656e730000000000000000000000000000000000000000000000000000006020820152610f2b9082906110b5565b50610f3681866110b5565b505f610f4285826110d5565b90505b80515160208201511015610fad578151610f6890610f6283611130565b90611151565b5f03610f9f575f80610f83878460a001518560c0015161129e565b925090508115610f9c57945060019350610fb692505050565b50505b610fa88161130d565b610f45565b505f8092509250505b9250929050565b81518111156110055781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610347918391600401918252602082015260400190565b5050565b61101785610e198387611e8c565b61102583610e198385611e8c565b61103a826020850101856020880101836113f2565b5050505050565b60408051808201909152606081525f6020820152611060602083611eed565b1561108857611070602083611eed565b61107b906020611e9f565b6110859083611e8c565b91505b60208084018390526040518085525f81529081840101818110156110aa575f80fd5b604052509192915050565b60408051808201909152606081525f6020820152610eae8383845161143b565b61111d6040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b82815260c081018290526102de8161130d565b602081015181516060916102de91611148908261150c565b84519190610e59565b5f61115c838361156b565b1561116857505f6102de565b5f805f805f611177885f61158f565b90505f611184885f61158f565b90505b808211156111b05785935061119c89876115e9565b9550816111a881611f0c565b925050611187565b818111156111d9578492506111c588866115e9565b9450806111d181611f0c565b9150506111b0565b5f821180156111f157506111ef89878a8861160c565b155b156112265785935061120389876115e9565b955084925061121288866115e9565b945061121f600183611e9f565b91506111d9565b855f0361123c575f1996505050505050506102de565b845f0361125257600196505050505050506102de565b611291611260856001611e8c565b61126a8b87610e09565b60ff168a611279876001611e8c565b6112838d89610e09565b8e949392919060ff16611647565b9998505050505050505050565b5f805b828410156112ff575f6112b48686610e09565b60ff1690506112c4600186611e8c565b94505f806112d3888885611721565b9250905081156112eb57935060019250611305915050565b6112f58388611e8c565b96505050506112a1565b505f9050805b935093915050565b60c081015160208201819052815151116113245750565b5f611336825f0151836020015161150c565b82602001516113459190611e8c565b82519091506113549082611773565b61ffff166040830152611368600282611e8c565b82519091506113779082611773565b61ffff16606083015261138b600282611e8c565b825190915061139a908261178f565b63ffffffff1660808301526113b0600482611e8c565b82519091505f906113c19083611773565b61ffff1690506113d2600283611e8c565b60a0840181905291506113e58183611e8c565b60c0909301929092525050565b5b601f811115611413578151835260209283019290910190601f19016113f3565b801561143657815183516001602084900360031b1b5f1901801990921691161783525b505050565b60408051808201909152606081525f6020820152825182111561145c575f80fd5b8351515f61146a8483611e8c565b9050856020015181111561148c5761148c86611487836002611f21565b6117ab565b85518051838201602001915f91808511156114a5578482525b505050602086015b602086106114e557805182526114c4602083611e8c565b91506114d1602082611e8c565b90506114de602087611e9f565b95506114ad565b5181515f1960208890036101000a0190811690199190911617905250849150509392505050565b5f815b8351811061151f5761151f611f38565b5f61152a8583610e09565b60ff16905061153a816001611e8c565b6115449083611e8c565b9150805f036115535750611559565b5061150f565b6115638382611e9f565b949350505050565b5f81518351148015610eae5750508051602091820120825192909101919091201490565b5f805b835183106115a2576115a2611f38565b5f6115ad8585610e09565b60ff1690506115bd816001611e8c565b6115c79085611e8c565b9350805f036115d65750610eae565b6115e1600183611e8c565b915050611592565b5f6115f48383610e09565b60ff16611602836001611e8c565b610eae9190611e8c565b5f6116178585610fbd565b6116218383610fbd565b61162f838384865103610e40565b61163d868687895103610e40565b1495945050505050565b5f61165687610e198789611e8c565b61166484610e198486611e8c565b6020868801810190848601015f84881061167e5784611680565b875b90505f5b81811015611704575f6116978286015190565b90505f6116a48386015190565b90508082146116fa5782840360208110156116c85760200360031b91821c9190811c905b818310156116e0575f19975050505050505050611717565b818311156116f8576001975050505050505050611717565b505b5050602001611684565b5050505081856117149190611f4c565b90505b9695505050505050565b5f8061172d858561178f565b63ffffffff1663613d30781461174757505f905080611305565b611767611755856004611e8c565b61175f8587611e8c565b8791906117c8565b91509150935093915050565b5f61178383610e19846002611e8c565b50016020015160f01c90565b5f61179f83610e19846004611e8c565b50016020015160e01c90565b81516117b78383611041565b506117c283826110b5565b50505050565b5f80826117d6856028611e8c565b146117e557505f905080611305565b5f6117f18686866117fe565b9097909650945050505050565b5f808383101561181257505f905080611305565b5f61181d8585611e9f565b9050604081118061182e5750855184115b1561183f57505f9150819050611305565b858501602001611850815f84611870565b92506001820160011c6020035f518160031b1c9450505050935093915050565b5f6118ce565b811a5f602f8211603a831016156118925750602f1981016102de565b604782106040831116156118ab575060361981016102de565b606782106060831116156118c4575060561981016102de565b5061010092915050565b50600183820182821615611908576118e75f8651611876565b80855360018601955060018501945060ff811115611906575f92508195505b505b8085101561195457845161191d600182611876565b6119275f83611876565b60041b17905060ff81111561193f575f925050611954565b80855350600285019450600184019350611908565b509392505050565b5f6020828403121561196c575f80fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610eae575f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156119d2576119d261199b565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611a0157611a0161199b565b604052919050565b5f67ffffffffffffffff821115611a2257611a2261199b565b50601f01601f191660200190565b5f82601f830112611a3f575f80fd5b8135611a52611a4d82611a09565b6119d8565b818152846020838601011115611a66575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112611a91575f80fd5b8135602067ffffffffffffffff80831115611aae57611aae61199b565b8260051b611abd8382016119d8565b9384528581018301938381019088861115611ad6575f80fd5b84880192505b85831015611b6557823584811115611af2575f80fd5b88016040818b03601f1901811315611b08575f80fd5b611b106119af565b8783013587811115611b20575f80fd5b611b2e8d8a83870101611a30565b825250908201359086821115611b42575f80fd5b611b508c8984860101611a30565b81890152845250509184019190840190611adc565b98975050505050505050565b6001600160a01b0381168114611b85575f80fd5b50565b5f805f8060808587031215611b9b575f80fd5b843567ffffffffffffffff80821115611bb2575f80fd5b611bbe88838901611a30565b95506020870135915080821115611bd3575f80fd5b50611be087828801611a82565b9350506040850135611bf181611b71565b91506060850135611c0181611b71565b939692955090935050565b5f60208284031215611c1c575f80fd5b8135610eae81611b71565b5f60208284031215611c37575f80fd5b5035919050565b5f8060408385031215611c4f575f80fd5b823567ffffffffffffffff80821115611c66575f80fd5b611c7286838701611a30565b93506020850135915080821115611c87575f80fd5b50611c9485828601611a82565b9150509250929050565b5f60208284031215611cae575f80fd5b813567ffffffffffffffff811115611cc4575f80fd5b61156384828501611a30565b5f60208284031215611ce0575f80fd5b8151610eae81611b71565b5f60208284031215611cfb575f80fd5b5051919050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610eae6020830184611d02565b5f60208284031215611d52575f80fd5b81518015158114610eae575f80fd5b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b83811015611dd857888303603f1901855281518051878552611dac88860182611d02565b91890151858303868b0152919050611dc48183611d02565b968901969450505090860190600101611d88565b509098975050505050505050565b5f8060408385031215611df7575f80fd5b825167ffffffffffffffff811115611e0d575f80fd5b8301601f81018513611e1d575f80fd5b8051611e2b611a4d82611a09565b818152866020838501011115611e3f575f80fd5b8160208401602083015e5f60208383010152809450505050602083015163ffffffff81168114611e6d575f80fd5b809150509250929050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156102de576102de611e78565b818103818111156102de576102de611e78565b604081525f611ec46040830185611d02565b905063ffffffff831660208301529392505050565b634e487b7160e01b5f52603260045260245ffd5b5f82611f0757634e487b7160e01b5f52601260045260245ffd5b500690565b5f81611f1a57611f1a611e78565b505f190190565b80820281158282048414176102de576102de611e78565b634e487b7160e01b5f52600160045260245ffd5b8181035f831280158383131683831282161715611f6b57611f6b611e78565b509291505056fea2646970667358221220d1bb167004eae895651b8b0524f66ac0c2fc5f3749b6dc087baf017c84d7233d64736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b50600436106100c4575f3560e01c806329d566301161007d5780636f951221116100585780636f951221146101dd5780637dc0d1d0146101fe578063ab14ec5914610225575f80fd5b806329d566301461019157806330349ebe146101a45780633f15457f146101b6575f80fd5b806306963218116100ad578063069632181461012f5780631ecfc4111461014457806325916d4114610157575f80fd5b806301ffc9a7146100c857806304f3bcec146100f0575b5f80fd5b6100db6100d636600461195c565b61024c565b60405190151581526020015b60405180910390f35b6101177f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e7565b61014261013d366004611b88565b6102e4565b005b610142610152366004611c0c565b6104c8565b61017c610165366004611c27565b60016020525f908152604090205463ffffffff1681565b60405163ffffffff90911681526020016100e7565b61014261019f366004611c3e565b610637565b5f54610117906001600160a01b031681565b6101177f000000000000000000000000000000000000000000000000000000000000000081565b6101f06101eb366004611c9e565b610706565b6040519081526020016100e7565b6101177f000000000000000000000000000000000000000000000000000000000000000081565b6101177f000000000000000000000000000000000000000000000000000000000000000081565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a70000000000000000000000000000000000000000000000000000000014806102de57507fffffffff0000000000000000000000000000000000000000000000000000000082167f2f43542800000000000000000000000000000000000000000000000000000000145b92915050565b5f805f6102f187876107d0565b91945092509050336001600160a01b03821614610350576040517fe03f60240000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03821660248201526044015b60405180910390fd5b6040516305ef2c7f60e41b815260048101849052602481018390526001600160a01b03828116604483015286811660648301525f60848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a4015f604051808303815f87803b1580156103cc575f80fd5b505af11580156103de573d5f803e3d5ffd5b505050506001600160a01b038416156104bf576001600160a01b03851661041857604051633c584f1360e21b815260040160405180910390fd5b60408051602081018590529081018390525f9060600160408051808303601f190181529082905280516020909101207fd5fa2b00000000000000000000000000000000000000000000000000000000008252600482018190526001600160a01b03878116602484015290925087169063d5fa2b00906044015f604051808303815f87803b1580156104a7575f80fd5b505af11580156104b9573d5f803e3d5ffd5b50505050505b50505050505050565b6040516302571be360e01b81525f60048201819052907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa15801561052d573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105519190611cd0565b90505f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610590573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105b49190611cd0565b9050336001600160a01b038216146105ca575f80fd5b5f80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0385169081179091556040519081527f9176b7f47e4504df5e5516c99d90d82ac7cbd49cc77e7f22ba2ac2f2e3a3eba89060200160405180910390a1505050565b5f805f61064485856107d0565b6040517f06ab592300000000000000000000000000000000000000000000000000000000815260048101849052602481018390526001600160a01b03828116604483015293965091945092507f0000000000000000000000000000000000000000000000000000000000000000909116906306ab5923906064016020604051808303815f875af11580156106da573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106fe9190611ceb565b505050505050565b5f80546040517f4f89059e0000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690634f89059e9061074f908590600401611d30565b602060405180830381865afa15801561076a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061078e9190611d42565b6107c657816040517f396e24b80000000000000000000000000000000000000000000000000000000081526004016103479190611d30565b6102de825f610a01565b5f805f805f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bdf95fef876040518263ffffffff1660e01b81526004016108219190611d61565b5f60405180830381865afa15801561083b573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526108629190810190611de6565b90925090505f6108728882610e09565b60ff16905061088388600183610e40565b94505f6108b5610894836001611e8c565b6001848c516108a39190611e9f565b6108ad9190611e9f565b8b9190610e59565b90506108c081610706565b96505f87876040516020016108df929190918252602082015260400190565b60408051808303601f1901815291815281516020928301205f81815260019093529082205490925063ffffffff16850360030b121561094a576040517f2dd6a7af00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f818152600160205260408120805463ffffffff191663ffffffff87161790556109748b87610eb5565b9097509050806109b0576040517f6260f6f800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b866001600160a01b0316827f87db02a0e483e2818060eddcbb3488ce44e35aff49a70d92c2aa6c8046cf01e28d886040516109ec929190611eb2565b60405180910390a35050505050509250925092565b5f80610a0d8484610e09565b60ff169050805f03610a2257505f90506102de565b5f610a4185610a318487611e8c565b610a3c906001611e8c565b610a01565b90505f610a5a610a52866001611e8c565b879085610e40565b604080516020810185905290810182905290915060600160408051601f198184030181529082905280516020909101206302571be360e01b82526004820181905294505f906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa158015610aee573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b129190611cd0565b90506001600160a01b0381161580610b5b57507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b0316145b15610dd65782610d21576040516302571be360e01b81525f60048201819052907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa158015610bca573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bee9190611cd0565b6040517f8cb8ecec000000000000000000000000000000000000000000000000000000008152600481018590523060248201529091506001600160a01b03821690638cb8ecec906044015f604051808303815f87803b158015610c4f575f80fd5b505af1158015610c61573d5f803e3d5ffd5b50506040517f1896f70a000000000000000000000000000000000000000000000000000000008152600481018990526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660248301527f0000000000000000000000000000000000000000000000000000000000000000169250631896f70a91506044015f604051808303815f87803b158015610d05575f80fd5b505af1158015610d17573d5f803e3d5ffd5b5050505050610dff565b6040516305ef2c7f60e41b815260048101849052602481018390523060448201526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660648301525f60848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a4015f604051808303815f87803b158015610dbb575f80fd5b505af1158015610dcd573d5f803e3d5ffd5b50505050610dff565b6001600160a01b0381163014610dff57604051633c584f1360e21b815260040160405180910390fd5b5050505092915050565b5f610e1e83610e19846001611e8c565b610fbd565b828281518110610e3057610e30611ed9565b016020015160f81c905092915050565b5f610e4f84610e198486611e8c565b5091016020012090565b60608167ffffffffffffffff811115610e7457610e7461199b565b6040519080825280601f01601f191660200182016040528015610e9e576020820181803683370190505b509050610eae8484835f86611009565b9392505050565b5f80610ed36040518060400160405280606081526020015f81525090565b610eeb85516005610ee49190611e8c565b8290611041565b5060408051808201909152600581527f045f656e730000000000000000000000000000000000000000000000000000006020820152610f2b9082906110b5565b50610f3681866110b5565b505f610f4285826110d5565b90505b80515160208201511015610fad578151610f6890610f6283611130565b90611151565b5f03610f9f575f80610f83878460a001518560c0015161129e565b925090508115610f9c57945060019350610fb692505050565b50505b610fa88161130d565b610f45565b505f8092509250505b9250929050565b81518111156110055781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610347918391600401918252602082015260400190565b5050565b61101785610e198387611e8c565b61102583610e198385611e8c565b61103a826020850101856020880101836113f2565b5050505050565b60408051808201909152606081525f6020820152611060602083611eed565b1561108857611070602083611eed565b61107b906020611e9f565b6110859083611e8c565b91505b60208084018390526040518085525f81529081840101818110156110aa575f80fd5b604052509192915050565b60408051808201909152606081525f6020820152610eae8383845161143b565b61111d6040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b82815260c081018290526102de8161130d565b602081015181516060916102de91611148908261150c565b84519190610e59565b5f61115c838361156b565b1561116857505f6102de565b5f805f805f611177885f61158f565b90505f611184885f61158f565b90505b808211156111b05785935061119c89876115e9565b9550816111a881611f0c565b925050611187565b818111156111d9578492506111c588866115e9565b9450806111d181611f0c565b9150506111b0565b5f821180156111f157506111ef89878a8861160c565b155b156112265785935061120389876115e9565b955084925061121288866115e9565b945061121f600183611e9f565b91506111d9565b855f0361123c575f1996505050505050506102de565b845f0361125257600196505050505050506102de565b611291611260856001611e8c565b61126a8b87610e09565b60ff168a611279876001611e8c565b6112838d89610e09565b8e949392919060ff16611647565b9998505050505050505050565b5f805b828410156112ff575f6112b48686610e09565b60ff1690506112c4600186611e8c565b94505f806112d3888885611721565b9250905081156112eb57935060019250611305915050565b6112f58388611e8c565b96505050506112a1565b505f9050805b935093915050565b60c081015160208201819052815151116113245750565b5f611336825f0151836020015161150c565b82602001516113459190611e8c565b82519091506113549082611773565b61ffff166040830152611368600282611e8c565b82519091506113779082611773565b61ffff16606083015261138b600282611e8c565b825190915061139a908261178f565b63ffffffff1660808301526113b0600482611e8c565b82519091505f906113c19083611773565b61ffff1690506113d2600283611e8c565b60a0840181905291506113e58183611e8c565b60c0909301929092525050565b5b601f811115611413578151835260209283019290910190601f19016113f3565b801561143657815183516001602084900360031b1b5f1901801990921691161783525b505050565b60408051808201909152606081525f6020820152825182111561145c575f80fd5b8351515f61146a8483611e8c565b9050856020015181111561148c5761148c86611487836002611f21565b6117ab565b85518051838201602001915f91808511156114a5578482525b505050602086015b602086106114e557805182526114c4602083611e8c565b91506114d1602082611e8c565b90506114de602087611e9f565b95506114ad565b5181515f1960208890036101000a0190811690199190911617905250849150509392505050565b5f815b8351811061151f5761151f611f38565b5f61152a8583610e09565b60ff16905061153a816001611e8c565b6115449083611e8c565b9150805f036115535750611559565b5061150f565b6115638382611e9f565b949350505050565b5f81518351148015610eae5750508051602091820120825192909101919091201490565b5f805b835183106115a2576115a2611f38565b5f6115ad8585610e09565b60ff1690506115bd816001611e8c565b6115c79085611e8c565b9350805f036115d65750610eae565b6115e1600183611e8c565b915050611592565b5f6115f48383610e09565b60ff16611602836001611e8c565b610eae9190611e8c565b5f6116178585610fbd565b6116218383610fbd565b61162f838384865103610e40565b61163d868687895103610e40565b1495945050505050565b5f61165687610e198789611e8c565b61166484610e198486611e8c565b6020868801810190848601015f84881061167e5784611680565b875b90505f5b81811015611704575f6116978286015190565b90505f6116a48386015190565b90508082146116fa5782840360208110156116c85760200360031b91821c9190811c905b818310156116e0575f19975050505050505050611717565b818311156116f8576001975050505050505050611717565b505b5050602001611684565b5050505081856117149190611f4c565b90505b9695505050505050565b5f8061172d858561178f565b63ffffffff1663613d30781461174757505f905080611305565b611767611755856004611e8c565b61175f8587611e8c565b8791906117c8565b91509150935093915050565b5f61178383610e19846002611e8c565b50016020015160f01c90565b5f61179f83610e19846004611e8c565b50016020015160e01c90565b81516117b78383611041565b506117c283826110b5565b50505050565b5f80826117d6856028611e8c565b146117e557505f905080611305565b5f6117f18686866117fe565b9097909650945050505050565b5f808383101561181257505f905080611305565b5f61181d8585611e9f565b9050604081118061182e5750855184115b1561183f57505f9150819050611305565b858501602001611850815f84611870565b92506001820160011c6020035f518160031b1c9450505050935093915050565b5f6118ce565b811a5f602f8211603a831016156118925750602f1981016102de565b604782106040831116156118ab575060361981016102de565b606782106060831116156118c4575060561981016102de565b5061010092915050565b50600183820182821615611908576118e75f8651611876565b80855360018601955060018501945060ff811115611906575f92508195505b505b8085101561195457845161191d600182611876565b6119275f83611876565b60041b17905060ff81111561193f575f925050611954565b80855350600285019450600184019350611908565b509392505050565b5f6020828403121561196c575f80fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610eae575f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156119d2576119d261199b565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611a0157611a0161199b565b604052919050565b5f67ffffffffffffffff821115611a2257611a2261199b565b50601f01601f191660200190565b5f82601f830112611a3f575f80fd5b8135611a52611a4d82611a09565b6119d8565b818152846020838601011115611a66575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112611a91575f80fd5b8135602067ffffffffffffffff80831115611aae57611aae61199b565b8260051b611abd8382016119d8565b9384528581018301938381019088861115611ad6575f80fd5b84880192505b85831015611b6557823584811115611af2575f80fd5b88016040818b03601f1901811315611b08575f80fd5b611b106119af565b8783013587811115611b20575f80fd5b611b2e8d8a83870101611a30565b825250908201359086821115611b42575f80fd5b611b508c8984860101611a30565b81890152845250509184019190840190611adc565b98975050505050505050565b6001600160a01b0381168114611b85575f80fd5b50565b5f805f8060808587031215611b9b575f80fd5b843567ffffffffffffffff80821115611bb2575f80fd5b611bbe88838901611a30565b95506020870135915080821115611bd3575f80fd5b50611be087828801611a82565b9350506040850135611bf181611b71565b91506060850135611c0181611b71565b939692955090935050565b5f60208284031215611c1c575f80fd5b8135610eae81611b71565b5f60208284031215611c37575f80fd5b5035919050565b5f8060408385031215611c4f575f80fd5b823567ffffffffffffffff80821115611c66575f80fd5b611c7286838701611a30565b93506020850135915080821115611c87575f80fd5b50611c9485828601611a82565b9150509250929050565b5f60208284031215611cae575f80fd5b813567ffffffffffffffff811115611cc4575f80fd5b61156384828501611a30565b5f60208284031215611ce0575f80fd5b8151610eae81611b71565b5f60208284031215611cfb575f80fd5b5051919050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610eae6020830184611d02565b5f60208284031215611d52575f80fd5b81518015158114610eae575f80fd5b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b83811015611dd857888303603f1901855281518051878552611dac88860182611d02565b91890151858303868b0152919050611dc48183611d02565b968901969450505090860190600101611d88565b509098975050505050505050565b5f8060408385031215611df7575f80fd5b825167ffffffffffffffff811115611e0d575f80fd5b8301601f81018513611e1d575f80fd5b8051611e2b611a4d82611a09565b818152866020838501011115611e3f575f80fd5b8160208401602083015e5f60208383010152809450505050602083015163ffffffff81168114611e6d575f80fd5b809150509250929050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156102de576102de611e78565b818103818111156102de576102de611e78565b604081525f611ec46040830185611d02565b905063ffffffff831660208301529392505050565b634e487b7160e01b5f52603260045260245ffd5b5f82611f0757634e487b7160e01b5f52601260045260245ffd5b500690565b5f81611f1a57611f1a611e78565b505f190190565b80820281158282048414176102de576102de611e78565b634e487b7160e01b5f52600160045260245ffd5b8181035f831280158383131683831282161715611f6b57611f6b611e78565b509291505056fea2646970667358221220d1bb167004eae895651b8b0524f66ac0c2fc5f3749b6dc087baf017c84d7233d64736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "1899": [
      {
        "length": 32,
        "start": 443
      },
      {
        "length": 32,
        "start": 907
      },
      {
        "length": 32,
        "start": 1248
      },
      {
        "length": 32,
        "start": 1682
      },
      {
        "length": 32,
        "start": 2729
      },
      {
        "length": 32,
        "start": 2941
      },
      {
        "length": 32,
        "start": 3266
      },
      {
        "length": 32,
        "start": 3450
      }
    ],
    "1902": [
      {
        "length": 32,
        "start": 515
      },
      {
        "length": 32,
        "start": 2007
      }
    ],
    "1907": [
      {
        "length": 32,
        "start": 554
      },
      {
        "length": 32,
        "start": 2855
      }
    ],
    "1909": [
      {
        "length": 32,
        "start": 245
      },
      {
        "length": 32,
        "start": 3226
      },
      {
        "length": 32,
        "start": 3404
      }
    ]
  },
  "inputSourceName": "project/lib/ens-contracts/contracts/dnsregistrar/DNSRegistrar.sol",
  "devdoc": {
    "details": "An ENS registrar that allows the owner of a DNS name to claim the      corresponding name in ENS.",
    "errors": {
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "proveAndClaim(bytes,(bytes,bytes)[])": {
        "details": "Submits proofs to the DNSSEC oracle, then claims a name using those proofs.",
        "params": {
          "input": "A chain of signed DNS RRSETs ending with a text record.",
          "name": "The name to claim, in DNS wire format."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "1620800",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "enableNode(bytes)": "infinite",
        "ens()": "infinite",
        "inceptions(bytes32)": "2517",
        "oracle()": "infinite",
        "previousRegistrar()": "infinite",
        "proveAndClaim(bytes,(bytes,bytes)[])": "infinite",
        "proveAndClaimWithResolver(bytes,(bytes,bytes)[],address,address)": "infinite",
        "resolver()": "infinite",
        "setPublicSuffixList(address)": "infinite",
        "suffixes()": "2380",
        "supportsInterface(bytes4)": "390"
      },
      "internal": {
        "_claim(bytes memory,struct DNSSEC.RRSetWithSignature memory[] memory)": "infinite",
        "_enableNode(bytes memory,uint256)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_previousRegistrar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"contract DNSSEC\",\"name\":\"_dnssec\",\"type\":\"address\"},{\"internalType\":\"contract PublicSuffixList\",\"name\":\"_suffixes\",\"type\":\"address\"},{\"internalType\":\"contract ENS\",\"name\":\"_ens\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"InvalidPublicSuffix\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOwnerRecordFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PermissionDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PreconditionNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StaleProof\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dnsname\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"suffixes\",\"type\":\"address\"}],\"name\":\"NewPublicSuffixList\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"domain\",\"type\":\"bytes\"}],\"name\":\"enableNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"inceptions\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract DNSSEC\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rrset\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct DNSSEC.RRSetWithSignature[]\",\"name\":\"input\",\"type\":\"tuple[]\"}],\"name\":\"proveAndClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rrset\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct DNSSEC.RRSetWithSignature[]\",\"name\":\"input\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"proveAndClaimWithResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PublicSuffixList\",\"name\":\"_suffixes\",\"type\":\"address\"}],\"name\":\"setPublicSuffixList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"suffixes\",\"outputs\":[{\"internalType\":\"contract PublicSuffixList\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"An ENS registrar that allows the owner of a DNS name to claim the      corresponding name in ENS.\",\"errors\":{\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}]},\"kind\":\"dev\",\"methods\":{\"proveAndClaim(bytes,(bytes,bytes)[])\":{\"details\":\"Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\",\"params\":{\"input\":\"A chain of signed DNS RRSETs ending with a text record.\",\"name\":\"The name to claim, in DNS wire format.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/lib/ens-contracts/contracts/dnsregistrar/DNSRegistrar.sol\":\"DNSRegistrar\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@ensdomains/solsha1/contracts/=project/lib/solsha1/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts-v5/=project/lib/openzeppelin-contracts/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/ens-contracts/:@unruggable/gateways/=project/lib/unruggable-gateways/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\",\"project/test/mocks/v1/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd85358722045348893aeedd23539816c9d1b218ab801a3fcd1ec4e38ecc8eb22\",\"license\":\"BSD-2-Clause\"},\"project/lib/ens-contracts/contracts/dnsregistrar/DNSClaimChecker.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../dnssec-oracle/DNSSEC.sol\\\";\\nimport \\\"../dnssec-oracle/RRUtils.sol\\\";\\nimport \\\"../utils/BytesUtils.sol\\\";\\nimport \\\"../utils/HexUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\nlibrary DNSClaimChecker {\\n    using BytesUtils for bytes;\\n    using HexUtils for bytes;\\n    using RRUtils for *;\\n    using Buffer for Buffer.buffer;\\n\\n    uint16 constant CLASS_INET = 1;\\n    uint16 constant TYPE_TXT = 16;\\n\\n    function getOwnerAddress(\\n        bytes memory name,\\n        bytes memory data\\n    ) internal pure returns (address, bool) {\\n        // Add \\\"_ens.\\\" to the front of the name.\\n        Buffer.buffer memory buf;\\n        buf.init(name.length + 5);\\n        buf.append(\\\"\\\\x04_ens\\\");\\n        buf.append(name);\\n\\n        for (\\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\\n            !iter.done();\\n            iter.next()\\n        ) {\\n            if (iter.name().compareNames(buf.buf) != 0) continue;\\n            bool found;\\n            address addr;\\n            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\\n            if (found) {\\n                return (addr, true);\\n            }\\n        }\\n\\n        return (address(0x0), false);\\n    }\\n\\n    function parseRR(\\n        bytes memory rdata,\\n        uint256 idx,\\n        uint256 endIdx\\n    ) internal pure returns (address, bool) {\\n        while (idx < endIdx) {\\n            uint256 len = rdata.readUint8(idx);\\n            idx += 1;\\n\\n            bool found;\\n            address addr;\\n            (addr, found) = parseString(rdata, idx, len);\\n\\n            if (found) return (addr, true);\\n            idx += len;\\n        }\\n\\n        return (address(0x0), false);\\n    }\\n\\n    function parseString(\\n        bytes memory str,\\n        uint256 idx,\\n        uint256 len\\n    ) internal pure returns (address, bool) {\\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\\n        return str.hexToAddress(idx + 4, idx + len);\\n    }\\n}\\n\",\"keccak256\":\"0x30a310c72ea18f320976ca5dbcf308e33d1e7184173add71d547c3881d4113e8\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnsregistrar/DNSRegistrar.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\nimport \\\"../dnssec-oracle/DNSSEC.sol\\\";\\nimport \\\"../dnssec-oracle/RRUtils.sol\\\";\\nimport \\\"../registry/ENSRegistry.sol\\\";\\nimport \\\"../root/Root.sol\\\";\\nimport \\\"../resolvers/profiles/AddrResolver.sol\\\";\\nimport \\\"../utils/BytesUtils.sol\\\";\\nimport \\\"./DNSClaimChecker.sol\\\";\\nimport \\\"./PublicSuffixList.sol\\\";\\nimport \\\"./IDNSRegistrar.sol\\\";\\n\\n/// @dev An ENS registrar that allows the owner of a DNS name to claim the\\n///      corresponding name in ENS.\\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\\n    using BytesUtils for bytes;\\n    using Buffer for Buffer.buffer;\\n    using RRUtils for *;\\n\\n    ENS public immutable ens;\\n    DNSSEC public immutable oracle;\\n    PublicSuffixList public suffixes;\\n    address public immutable previousRegistrar;\\n    address public immutable resolver;\\n    // A mapping of the most recent signatures seen for each claimed domain.\\n    mapping(bytes32 => uint32) public inceptions;\\n\\n    error NoOwnerRecordFound();\\n    error PermissionDenied(address caller, address owner);\\n    error PreconditionNotMet();\\n    error StaleProof();\\n    error InvalidPublicSuffix(bytes name);\\n\\n    struct OwnerRecord {\\n        bytes name;\\n        address owner;\\n        address resolver;\\n        uint64 ttl;\\n    }\\n\\n    event Claim(\\n        bytes32 indexed node,\\n        address indexed owner,\\n        bytes dnsname,\\n        uint32 inception\\n    );\\n    event NewPublicSuffixList(address suffixes);\\n\\n    constructor(\\n        address _previousRegistrar,\\n        address _resolver,\\n        DNSSEC _dnssec,\\n        PublicSuffixList _suffixes,\\n        ENS _ens\\n    ) {\\n        previousRegistrar = _previousRegistrar;\\n        resolver = _resolver;\\n        oracle = _dnssec;\\n        suffixes = _suffixes;\\n        emit NewPublicSuffixList(address(suffixes));\\n        ens = _ens;\\n    }\\n\\n    /// @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\\n    modifier onlyOwner() {\\n        Root root = Root(ens.owner(bytes32(0)));\\n        address owner = root.owner();\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\\n        suffixes = _suffixes;\\n        emit NewPublicSuffixList(address(suffixes));\\n    }\\n\\n    /// @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\\n    /// @param name The name to claim, in DNS wire format.\\n    /// @param input A chain of signed DNS RRSETs ending with a text record.\\n    function proveAndClaim(\\n        bytes memory name,\\n        DNSSEC.RRSetWithSignature[] memory input\\n    ) public override {\\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\\n            name,\\n            input\\n        );\\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\\n    }\\n\\n    function proveAndClaimWithResolver(\\n        bytes memory name,\\n        DNSSEC.RRSetWithSignature[] memory input,\\n        address resolver,\\n        address addr\\n    ) public override {\\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\\n            name,\\n            input\\n        );\\n        if (msg.sender != owner) {\\n            revert PermissionDenied(msg.sender, owner);\\n        }\\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\\n        if (addr != address(0)) {\\n            if (resolver == address(0)) {\\n                revert PreconditionNotMet();\\n            }\\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\\n            // Set the resolver record\\n            AddrResolver(resolver).setAddr(node, addr);\\n        }\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceID\\n    ) external pure override returns (bool) {\\n        return\\n            interfaceID == type(IERC165).interfaceId ||\\n            interfaceID == type(IDNSRegistrar).interfaceId;\\n    }\\n\\n    function _claim(\\n        bytes memory name,\\n        DNSSEC.RRSetWithSignature[] memory input\\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\\n\\n        // Get the first label\\n        uint256 labelLen = name.readUint8(0);\\n        labelHash = name.keccak(1, labelLen);\\n\\n        bytes memory parentName = name.substring(\\n            labelLen + 1,\\n            name.length - labelLen - 1\\n        );\\n\\n        // Make sure the parent name is enabled\\n        parentNode = enableNode(parentName);\\n\\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\\n            revert StaleProof();\\n        }\\n        inceptions[node] = inception;\\n\\n        bool found;\\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\\n        if (!found) {\\n            revert NoOwnerRecordFound();\\n        }\\n\\n        emit Claim(node, addr, name, inception);\\n    }\\n\\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\\n        // Name must be in the public suffix list.\\n        if (!suffixes.isPublicSuffix(domain)) {\\n            revert InvalidPublicSuffix(domain);\\n        }\\n        return _enableNode(domain, 0);\\n    }\\n\\n    function _enableNode(\\n        bytes memory domain,\\n        uint256 offset\\n    ) internal returns (bytes32 node) {\\n        uint256 len = domain.readUint8(offset);\\n        if (len == 0) {\\n            return bytes32(0);\\n        }\\n\\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\\n        bytes32 label = domain.keccak(offset + 1, len);\\n        node = keccak256(abi.encodePacked(parentNode, label));\\n        address owner = ens.owner(node);\\n        if (owner == address(0) || owner == previousRegistrar) {\\n            if (parentNode == bytes32(0)) {\\n                Root root = Root(ens.owner(bytes32(0)));\\n                root.setSubnodeOwner(label, address(this));\\n                ens.setResolver(node, resolver);\\n            } else {\\n                ens.setSubnodeRecord(\\n                    parentNode,\\n                    label,\\n                    address(this),\\n                    resolver,\\n                    0\\n                );\\n            }\\n        } else if (owner != address(this)) {\\n            revert PreconditionNotMet();\\n        }\\n        return node;\\n    }\\n}\\n\",\"keccak256\":\"0x4a2a221522e29079a34d3769aea0900c057db228e7f3ee298f88f1d836888ef2\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnsregistrar/IDNSRegistrar.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../dnssec-oracle/DNSSEC.sol\\\";\\n\\ninterface IDNSRegistrar {\\n    function proveAndClaim(\\n        bytes memory name,\\n        DNSSEC.RRSetWithSignature[] memory input\\n    ) external;\\n\\n    function proveAndClaimWithResolver(\\n        bytes memory name,\\n        DNSSEC.RRSetWithSignature[] memory input,\\n        address resolver,\\n        address addr\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcf6607fe4918cabb1c4c2130597dd9cc0f63492564b05de60496eb46873a73b7\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnsregistrar/PublicSuffixList.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\ninterface PublicSuffixList {\\n    function isPublicSuffix(bytes calldata name) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x12158ba8838ee2b1ebb0178a52d2f4d54dcc68282d569226e62afc2b0dccbbac\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/DNSSEC.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract DNSSEC {\\n    bytes public anchors;\\n\\n    struct RRSetWithSignature {\\n        bytes rrset;\\n        bytes sig;\\n    }\\n\\n    event AlgorithmUpdated(uint8 id, address addr);\\n    event DigestUpdated(uint8 id, address addr);\\n\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input\\n    ) external view virtual returns (bytes memory rrs, uint32 inception);\\n\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input,\\n        uint256 now\\n    ) public view virtual returns (bytes memory rrs, uint32 inception);\\n}\\n\",\"keccak256\":\"0xee6a236a59e5db8418c98ee4640a91987d26533c02d305cc6c7a37a3ac4ee907\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/// @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /// @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return The length of the DNS name at 'offset', in bytes.\\n    function nameLength(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint256 labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /// @dev Returns a DNS format name at the specified offset of self.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return ret The name.\\n    function readName(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes memory ret) {\\n        uint256 len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /// @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return The number of labels in the DNS name at 'offset', in bytes.\\n    function labelCount(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint256 labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint256 constant RRSIG_TYPE = 0;\\n    uint256 constant RRSIG_ALGORITHM = 2;\\n    uint256 constant RRSIG_LABELS = 3;\\n    uint256 constant RRSIG_TTL = 4;\\n    uint256 constant RRSIG_EXPIRATION = 8;\\n    uint256 constant RRSIG_INCEPTION = 12;\\n    uint256 constant RRSIG_KEY_TAG = 16;\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(\\n        bytes memory data\\n    ) internal pure returns (SignedSet memory self) {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\n        );\\n    }\\n\\n    function rrs(\\n        SignedSet memory rrset\\n    ) internal pure returns (RRIterator memory) {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /// @dev An iterator over resource records.\\n    struct RRIterator {\\n        bytes data;\\n        uint256 offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint256 rdataOffset;\\n        uint256 nextOffset;\\n    }\\n\\n    /// @dev Begins iterating over resource records.\\n    /// @param self The byte string to read from.\\n    /// @param offset The offset to start reading at.\\n    /// @return ret An iterator object.\\n    function iterateRRs(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (RRIterator memory ret) {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /// @dev Returns true iff there are more RRs to iterate.\\n    /// @param iter The iterator to check.\\n    /// @return True iff the iterator has finished.\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /// @dev Moves the iterator to the next resource record.\\n    /// @param iter The iterator to advance.\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint256 rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /// @dev Returns the name of the current record.\\n    /// @param iter The iterator.\\n    /// @return A new bytes object containing the owner name from the RR.\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.offset,\\n                nameLength(iter.data, iter.offset)\\n            );\\n    }\\n\\n    /// @dev Returns the rdata portion of the current record.\\n    /// @param iter The iterator.\\n    /// @return A new bytes object containing the RR's RDATA.\\n    function rdata(\\n        RRIterator memory iter\\n    ) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.rdataOffset,\\n                iter.nextOffset - iter.rdataOffset\\n            );\\n    }\\n\\n    uint256 constant DNSKEY_FLAGS = 0;\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\n    uint256 constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(\\n            offset + DNSKEY_PUBKEY,\\n            length - DNSKEY_PUBKEY\\n        );\\n    }\\n\\n    uint256 constant DS_KEY_TAG = 0;\\n    uint256 constant DS_ALGORITHM = 2;\\n    uint256 constant DS_DIGEST_TYPE = 3;\\n    uint256 constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    function isSubdomainOf(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        uint256 off = 0;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        while (counts > othercounts) {\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        return self.equals(off, other, 0);\\n    }\\n\\n    function compareNames(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (int256) {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint256 off;\\n        uint256 otheroff;\\n        uint256 prevoff;\\n        uint256 otherprevoff;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if (otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return\\n            self.compare(\\n                prevoff + 1,\\n                self.readUint8(prevoff),\\n                other,\\n                otherprevoff + 1,\\n                other.readUint8(otherprevoff)\\n            );\\n    }\\n\\n    /// @dev Compares two serial numbers using RFC1982 serial number math.\\n    function serialNumberGte(\\n        uint32 i1,\\n        uint32 i2\\n    ) internal pure returns (bool) {\\n        unchecked {\\n            return int32(i1) - int32(i2) >= 0;\\n        }\\n    }\\n\\n    function progress(\\n        bytes memory body,\\n        uint256 off\\n    ) internal pure returns (uint256) {\\n        return off + 1 + body.readUint8(off);\\n    }\\n\\n    /// @dev Computes the keytag for a chunk of data.\\n    /// @param data The data to compute a keytag for.\\n    /// @return The computed key tag.\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n        /* This function probably deserves some explanation.\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\n         *\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n         *         uint ac;\\n         *         for (uint i = 0; i < data.length; i++) {\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\n         *         }\\n         *         return uint16(ac + (ac >> 16));\\n         *     }\\n         *\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\n         * large words work in our favour.\\n         *\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\n         *\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\n         * and the remaining sums can be done just on ac1.\\n         */\\n        unchecked {\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\n            uint256 ac1;\\n            uint256 ac2;\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(add(add(data, 32), i))\\n                }\\n                if (i + 32 > data.length) {\\n                    uint256 unused = 256 - (data.length - i) * 8;\\n                    word = (word >> unused) << unused;\\n                }\\n                ac1 +=\\n                    (word &\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\n                    8;\\n                ac2 += (word &\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\n            }\\n            ac1 =\\n                (ac1 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac1 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac2 =\\n                (ac2 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac2 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac1 = (ac1 << 8) + ac2;\\n            ac1 =\\n                (ac1 &\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\n                    32);\\n            ac1 =\\n                (ac1 &\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\n                    64);\\n            ac1 =\\n                (ac1 &\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\n                (ac1 >> 128);\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\n            return uint16(ac1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdbab10dde632a1a02ee1c706bd4a31f9fb6195bd15a360528f7f6615e8fc895a\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8e208b44d5dbf22552fe72d79b45c640855b84fbc9ee21f4c3bb4bfe81cbe8db\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/registry/ENSRegistry.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\nimport \\\"./ENS.sol\\\";\\n\\n/// The ENS registry contract.\\ncontract ENSRegistry is ENS {\\n    struct Record {\\n        address owner;\\n        address resolver;\\n        uint64 ttl;\\n    }\\n\\n    mapping(bytes32 => Record) records;\\n    mapping(address => mapping(address => bool)) operators;\\n\\n    // Permits modifications only by the owner of the specified node.\\n    modifier authorised(bytes32 node) {\\n        address owner = records[node].owner;\\n        require(owner == msg.sender || operators[owner][msg.sender]);\\n        _;\\n    }\\n\\n    /// @dev Constructs a new ENS registry.\\n    constructor() public {\\n        records[0x0].owner = msg.sender;\\n    }\\n\\n    /// @dev Sets the record for a node.\\n    /// @param node The node to update.\\n    /// @param owner The address of the new owner.\\n    /// @param resolver The address of the resolver.\\n    /// @param ttl The TTL in seconds.\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external virtual override {\\n        setOwner(node, owner);\\n        _setResolverAndTTL(node, resolver, ttl);\\n    }\\n\\n    /// @dev Sets the record for a subnode.\\n    /// @param node The parent node.\\n    /// @param label The hash of the label specifying the subnode.\\n    /// @param owner The address of the new owner.\\n    /// @param resolver The address of the resolver.\\n    /// @param ttl The TTL in seconds.\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external virtual override {\\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\\n        _setResolverAndTTL(subnode, resolver, ttl);\\n    }\\n\\n    /// @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\n    /// @param node The node to transfer ownership of.\\n    /// @param owner The address of the new owner.\\n    function setOwner(\\n        bytes32 node,\\n        address owner\\n    ) public virtual override authorised(node) {\\n        _setOwner(node, owner);\\n        emit Transfer(node, owner);\\n    }\\n\\n    /// @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\n    /// @param node The parent node.\\n    /// @param label The hash of the label specifying the subnode.\\n    /// @param owner The address of the new owner.\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) public virtual override authorised(node) returns (bytes32) {\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n        _setOwner(subnode, owner);\\n        emit NewOwner(node, label, owner);\\n        return subnode;\\n    }\\n\\n    /// @dev Sets the resolver address for the specified node.\\n    /// @param node The node to update.\\n    /// @param resolver The address of the resolver.\\n    function setResolver(\\n        bytes32 node,\\n        address resolver\\n    ) public virtual override authorised(node) {\\n        emit NewResolver(node, resolver);\\n        records[node].resolver = resolver;\\n    }\\n\\n    /// @dev Sets the TTL for the specified node.\\n    /// @param node The node to update.\\n    /// @param ttl The TTL in seconds.\\n    function setTTL(\\n        bytes32 node,\\n        uint64 ttl\\n    ) public virtual override authorised(node) {\\n        emit NewTTL(node, ttl);\\n        records[node].ttl = ttl;\\n    }\\n\\n    /// @dev Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///      all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\\n    /// @param operator Address to add to the set of authorized operators.\\n    /// @param approved True if the operator is approved, false to revoke approval.\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) external virtual override {\\n        operators[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @dev Returns the address that owns the specified node.\\n    /// @param node The specified node.\\n    /// @return address of the owner.\\n    function owner(\\n        bytes32 node\\n    ) public view virtual override returns (address) {\\n        address addr = records[node].owner;\\n        if (addr == address(this)) {\\n            return address(0x0);\\n        }\\n\\n        return addr;\\n    }\\n\\n    /// @dev Returns the address of the resolver for the specified node.\\n    /// @param node The specified node.\\n    /// @return address of the resolver.\\n    function resolver(\\n        bytes32 node\\n    ) public view virtual override returns (address) {\\n        return records[node].resolver;\\n    }\\n\\n    /// @dev Returns the TTL of a node, and any records associated with it.\\n    /// @param node The specified node.\\n    /// @return ttl of the node.\\n    function ttl(bytes32 node) public view virtual override returns (uint64) {\\n        return records[node].ttl;\\n    }\\n\\n    /// @dev Returns whether a record has been imported to the registry.\\n    /// @param node The specified node.\\n    /// @return Bool if record exists\\n    function recordExists(\\n        bytes32 node\\n    ) public view virtual override returns (bool) {\\n        return records[node].owner != address(0x0);\\n    }\\n\\n    /// @dev Query if an address is an authorized operator for another address.\\n    /// @param owner The address that owns the records.\\n    /// @param operator The address that acts on behalf of the owner.\\n    /// @return True if `operator` is an approved operator for `owner`, false otherwise.\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view virtual override returns (bool) {\\n        return operators[owner][operator];\\n    }\\n\\n    function _setOwner(bytes32 node, address owner) internal virtual {\\n        records[node].owner = owner;\\n    }\\n\\n    function _setResolverAndTTL(\\n        bytes32 node,\\n        address resolver,\\n        uint64 ttl\\n    ) internal {\\n        if (resolver != records[node].resolver) {\\n            records[node].resolver = resolver;\\n            emit NewResolver(node, resolver);\\n        }\\n\\n        if (ttl != records[node].ttl) {\\n            records[node].ttl = ttl;\\n            emit NewTTL(node, ttl);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x56d1ed397dcb9b91a596cb839bae16e65ebdc11adbc35759c31b9e00d13da7d8\"},\"project/lib/ens-contracts/contracts/resolvers/ResolverBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"./profiles/IVersionableResolver.sol\\\";\\n\\nabstract contract ResolverBase is ERC165, IVersionableResolver {\\n    mapping(bytes32 => uint64) public recordVersions;\\n\\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n\\n    /// Increments the record version associated with an ENS node.\\n    /// May only be called by the owner of that node in the ENS registry.\\n    /// @param node The node to update.\\n    function clearRecords(bytes32 node) public virtual authorised(node) {\\n        recordVersions[node]++;\\n        emit VersionChanged(node, recordVersions[node]);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceID\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceID == type(IVersionableResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0xb063f86c1e75508779fd23762f20ebfbb2f3ef6d84328038e3de01cf59d18e4b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport {ResolverBase, IERC165} from \\\"../ResolverBase.sol\\\";\\nimport {IAddrResolver} from \\\"./IAddrResolver.sol\\\";\\nimport {IAddressResolver} from \\\"./IAddressResolver.sol\\\";\\nimport {IHasAddressResolver} from \\\"./IHasAddressResolver.sol\\\";\\nimport {ENSIP19, COIN_TYPE_ETH, COIN_TYPE_DEFAULT} from \\\"../../utils/ENSIP19.sol\\\";\\n\\nabstract contract AddrResolver is\\n    IAddrResolver,\\n    IAddressResolver,\\n    IHasAddressResolver,\\n    ResolverBase\\n{\\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\\n\\n    /// @notice The supplied address could not be converted to `address`.\\n    /// @dev Error selector: `0x8d666f60`\\n    error InvalidEVMAddress(bytes addressBytes);\\n\\n    /// @notice Set `addr(60)` of the associated ENS node.\\n    ///         `address(0)` is stored as `new bytes(20)`.\\n    /// @param node The node to update.\\n    /// @param _addr The address to set.\\n    function setAddr(\\n        bytes32 node,\\n        address _addr\\n    ) external virtual authorised(node) {\\n        setAddr(node, COIN_TYPE_ETH, abi.encodePacked(_addr));\\n    }\\n\\n    /// @notice Get `addr(60)` as `address` of the associated ENS node.\\n    /// @param node The node to query.\\n    /// @return The associated address.\\n    function addr(\\n        bytes32 node\\n    ) public view virtual override returns (address payable) {\\n        return payable(address(bytes20(addr(node, COIN_TYPE_ETH))));\\n    }\\n\\n    /// @notice Set the address for coin type of the associated ENS node.\\n    ///         Reverts `InvalidEVMAddress` if coin type is EVM and not 0 or 20 bytes.\\n    /// @param node The node to update.\\n    /// @param coinType The coin type.\\n    /// @param addressBytes The address to set.\\n    function setAddr(\\n        bytes32 node,\\n        uint256 coinType,\\n        bytes memory addressBytes\\n    ) public virtual authorised(node) {\\n        if (\\n            addressBytes.length != 0 &&\\n            addressBytes.length != 20 &&\\n            ENSIP19.isEVMCoinType(coinType)\\n        ) {\\n            revert InvalidEVMAddress(addressBytes);\\n        }\\n        emit AddressChanged(node, coinType, addressBytes);\\n        if (coinType == COIN_TYPE_ETH) {\\n            emit AddrChanged(node, address(bytes20(addressBytes)));\\n        }\\n        versionable_addresses[recordVersions[node]][node][\\n            coinType\\n        ] = addressBytes;\\n    }\\n\\n    /// @notice Get the address for coin type of the associated ENS node.\\n    ///         If coin type is EVM and empty, defaults to `addr(COIN_TYPE_DEFAULT)`.\\n    /// @param node The node to query.\\n    /// @param coinType The coin type.\\n    /// @return addressBytes The assocated address.\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) public view virtual override returns (bytes memory addressBytes) {\\n        mapping(uint256 => bytes) storage addrs = versionable_addresses[\\n            recordVersions[node]\\n        ][node];\\n        addressBytes = addrs[coinType];\\n        if (\\n            addressBytes.length == 0 && ENSIP19.chainFromCoinType(coinType) > 0\\n        ) {\\n            addressBytes = addrs[COIN_TYPE_DEFAULT];\\n        }\\n    }\\n\\n    /// @inheritdoc IHasAddressResolver\\n    function hasAddr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bool) {\\n        return\\n            versionable_addresses[recordVersions[node]][node][coinType].length >\\n            0;\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return\\n            type(IAddrResolver).interfaceId == interfaceId ||\\n            type(IAddressResolver).interfaceId == interfaceId ||\\n            type(IHasAddressResolver).interfaceId == interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0x2d214ea1213dbd8cc02d32355edf044a6551296df56e8a4931d3447092e8abcc\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the legacy (ETH-only) addr function.\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /// Returns the address associated with an ENS node.\\n    /// @param node The ENS node to query.\\n    /// @return The associated address.\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the new (multicoin) addr function.\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x8da5dd0fc1c5ab4f47e03c23126976a86d4b2dbeac161e70e3af9e2a13330cf0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IHasAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IHasAddressResolver {\\n    /// @notice Determine if an addresss is stored for the coin type of the associated ENS node.\\n    /// @param node The node to query.\\n    /// @param coinType The coin type.\\n    /// @return True if the associated address is not empty.\\n    function hasAddr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbe13530b8cc027517c235e422326abd36bb1152dac8546713471be2a7335cf2b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IVersionableResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IVersionableResolver {\\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\\n\\n    function recordVersions(bytes32 node) external view returns (uint64);\\n}\\n\",\"keccak256\":\"0xd0d09596f20c57bafb2ffa8521a8c57120e9af6c6b194f9c689d4da56f91a57c\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/root/Controllable.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Controllable is Ownable {\\n    mapping(address => bool) public controllers;\\n\\n    event ControllerChanged(address indexed controller, bool enabled);\\n\\n    modifier onlyController() {\\n        require(\\n            controllers[msg.sender],\\n            \\\"Controllable: Caller is not a controller\\\"\\n        );\\n        _;\\n    }\\n\\n    function setController(address controller, bool enabled) public onlyOwner {\\n        controllers[controller] = enabled;\\n        emit ControllerChanged(controller, enabled);\\n    }\\n}\\n\",\"keccak256\":\"0xb19b8c0fafe9ca2b4bf8aaafee486fa31437672e1e1977bdf84bfe03464969db\"},\"project/lib/ens-contracts/contracts/root/Root.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Controllable.sol\\\";\\n\\ncontract Root is Ownable, Controllable {\\n    bytes32 private constant ROOT_NODE = bytes32(0);\\n\\n    bytes4 private constant INTERFACE_META_ID =\\n        bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n\\n    event TLDLocked(bytes32 indexed label);\\n\\n    ENS public ens;\\n    mapping(bytes32 => bool) public locked;\\n\\n    constructor(ENS _ens) public {\\n        ens = _ens;\\n    }\\n\\n    function setSubnodeOwner(\\n        bytes32 label,\\n        address owner\\n    ) external onlyController {\\n        require(!locked[label]);\\n        ens.setSubnodeOwner(ROOT_NODE, label, owner);\\n    }\\n\\n    function setResolver(address resolver) external onlyOwner {\\n        ens.setResolver(ROOT_NODE, resolver);\\n    }\\n\\n    function lock(bytes32 label) external onlyOwner {\\n        emit TLDLocked(label);\\n        locked[label] = true;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceID\\n    ) external pure returns (bool) {\\n        return interfaceID == INTERFACE_META_ID;\\n    }\\n}\\n\",\"keccak256\":\"0x469b281e1a9e1c3dad9c860a4ab3a7299a48355b0b0243713e0829193c39f50c\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/ENSIP19.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nuint32 constant CHAIN_ID_ETH = 1;\\n\\nuint256 constant COIN_TYPE_ETH = 60;\\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\\n\\nstring constant SLUG_ETH = \\\"addr\\\"; // <=> COIN_TYPE_ETH\\nstring constant SLUG_DEFAULT = \\\"default\\\"; // <=> COIN_TYPE_DEFAULT\\nstring constant TLD_REVERSE = \\\"reverse\\\";\\n\\n/// @dev Library for generating reverse names according to ENSIP-19.\\n/// https://docs.ens.domains/ensip/19\\nlibrary ENSIP19 {\\n    /// @dev The supplied address was `0x`.\\n    ///      Error selector: `0x7138356f`\\n    error EmptyAddress();\\n\\n    /// @dev Extract Chain ID from `coinType`.\\n    /// @param coinType The coin type.\\n    /// @return The Chain ID or 0 if non-EVM Chain.\\n    function chainFromCoinType(\\n        uint256 coinType\\n    ) internal pure returns (uint32) {\\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\\n        coinType ^= COIN_TYPE_DEFAULT;\\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\\n    }\\n\\n    /// @dev Determine if Coin Type is for an EVM address.\\n    /// @param coinType The coin type.\\n    /// @return True if coin type represents an EVM address.\\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\\n    }\\n\\n    /// @dev Generate Reverse Name from Address + Coin Type.\\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\\n    /// @param addressBytes The input address.\\n    /// @param coinType The coin type.\\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\\n    function reverseName(\\n        bytes memory addressBytes,\\n        uint256 coinType\\n    ) internal pure returns (string memory) {\\n        if (addressBytes.length == 0) {\\n            revert EmptyAddress();\\n        }\\n        return\\n            string(\\n                abi.encodePacked(\\n                    HexUtils.bytesToHex(addressBytes),\\n                    bytes1(\\\".\\\"),\\n                    coinType == COIN_TYPE_ETH\\n                        ? SLUG_ETH\\n                        : coinType == COIN_TYPE_DEFAULT\\n                            ? SLUG_DEFAULT\\n                            : HexUtils.unpaddedUintToHex(coinType, true),\\n                    bytes1(\\\".\\\"),\\n                    TLD_REVERSE\\n                )\\n            );\\n    }\\n\\n    /// @dev Parse Reverse Name into Address + Coin Type.\\n    ///      Matches: `/^[0-9a-fA-F]+\\\\.([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @return addressBytes The address or empty if invalid.\\n    /// @return coinType The coin type.\\n    function parse(\\n        bytes memory name\\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\\n        bool valid;\\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\\n        if (!valid || addressBytes.length == 0) return (\\\"\\\", 0); // addressBytes not 1+ hex\\n        (valid, coinType) = parseNamespace(name, offset);\\n        if (!valid) return (\\\"\\\", 0); // invalid namespace\\n    }\\n\\n    /// @dev Parse Reverse Namespace into Coin Type.\\n    ///      Matches: `/^([0-9a-f]{1,64}|addr|default)\\\\.reverse$/`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset to begin parsing.\\n    /// @return valid True if a valid reverse namespace.\\n    /// @return coinType The coin type.\\n    function parseNamespace(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bool valid, uint256 coinType) {\\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\\n            name,\\n            offset\\n        );\\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\\n            coinType = COIN_TYPE_ETH;\\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\\n            coinType = COIN_TYPE_DEFAULT;\\n        } else if (labelHash == bytes32(0)) {\\n            return (false, 0); // no slug\\n        } else {\\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\\n                name,\\n                1 + offset,\\n                offsetTLD\\n            );\\n            if (!validHex) return (false, 0); // invalid coinType or too long\\n            coinType = uint256(word);\\n        }\\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\\n        (labelHash, ) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\\n        valid = true;\\n    }\\n}\\n\",\"keccak256\":\"0xd1af09b014028de4c50489bd58ae424273180bb96d95353d8eefd14845f31824\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary HexUtils {\\n    /// @dev Convert `hexString[off:end]` to `bytes32`.\\n    ///      Accepts 0-64 hex-chars.\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return word The parsed bytes32.\\n    /// @return valid True if the parse was successful.\\n    function hexStringToBytes32(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes32 word, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        if (nibbles > 64 || end > hexString.length) {\\n            return (bytes32(0), false); // too large or out of bounds\\n        }\\n        uint256 src;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n        }\\n        valid = unsafeBytes(src, 0, nibbles);\\n        assembly {\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\n            word := shr(shl(3, pad), mload(0)) // right align\\n        }\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `address`.\\n    ///      Accepts exactly 40 hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return addr The parsed address.\\n    /// @return valid True if the parse was successful.\\n    function hexToAddress(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (address addr, bool valid) {\\n        if (off + 40 != end) return (address(0), false); // wrong length\\n        bytes32 word;\\n        (word, valid) = hexStringToBytes32(hexString, off, end);\\n        addr = address(uint160(uint256(word)));\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `bytes`.\\n    ///      Accepts 0+ hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return v The parsed bytes.\\n    /// @return valid True if the parse was successful.\\n    function hexToBytes(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes memory v, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        v = new bytes((1 + nibbles) >> 1); // round up\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n            dst := add(v, 32)\\n        }\\n        valid = unsafeBytes(src, dst, nibbles);\\n    }\\n\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\n    ///      Matches: `/^[0-9a-f]*$/i`.\\n    /// @param src The memory offset of first hex-char of input.\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\n    /// @param nibbles The number of hex-chars to convert.\\n    /// @return valid True if all characters were hex.\\n    function unsafeBytes(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure returns (bool valid) {\\n        assembly {\\n            function getHex(c, i) -> ascii {\\n                c := byte(i, c)\\n                // chars 48-57: 0-9\\n                if and(gt(c, 47), lt(c, 58)) {\\n                    ascii := sub(c, 48)\\n                    leave\\n                }\\n                // chars 65-70: A-F\\n                if and(gt(c, 64), lt(c, 71)) {\\n                    ascii := add(sub(c, 65), 10)\\n                    leave\\n                }\\n                // chars 97-102: a-f\\n                if and(gt(c, 96), lt(c, 103)) {\\n                    ascii := add(sub(c, 97), 10)\\n                    leave\\n                }\\n                // invalid char\\n                ascii := 0x100\\n            }\\n            valid := true\\n            let end := add(src, nibbles)\\n            if and(nibbles, 1) {\\n                let b := getHex(mload(src), 0) // \\\"f\\\" -> 15\\n                mstore8(dst, b) // write ascii byte\\n                src := add(src, 1) // update pointers\\n                dst := add(dst, 1)\\n                if gt(b, 255) {\\n                    valid := false\\n                    src := end // terminate loop\\n                }\\n            }\\n            // prettier-ignore\\n            for {} lt(src, end) {\\n                src := add(src, 2) // 2 nibbles\\n                dst := add(dst, 1) // per byte\\n            } {\\n                let word := mload(src) // read word (left aligned)\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\"ff\\\" -> 255\\n                if gt(b, 255) {\\n                    valid := false\\n                    break\\n                }\\n                mstore8(dst, b) // write ascii byte\\n            }\\n        }\\n    }\\n\\n    /// @dev Format `address` as a hex string.\\n    /// @param addr The address to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function addressToHex(\\n        address addr\\n    ) internal pure returns (string memory hexString) {\\n        // return bytesToHex(abi.encodePacked(addr));\\n        hexString = new string(40);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, addr)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(12, dst, 40);\\n    }\\n\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\n    /// * unpaddedUintToHex(0, true)  = \\\"0\\\"\\n    /// * unpaddedUintToHex(1, true)  = \\\"1\\\"\\n    /// * unpaddedUintToHex(0, false) = \\\"00\\\"\\n    /// * unpaddedUintToHex(1, false) = \\\"01\\\"\\n    /// @param value The number to format.\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\n    function unpaddedUintToHex(\\n        uint256 value,\\n        bool dropZeroNibble\\n    ) internal pure returns (string memory hexString) {\\n        uint256 temp = value;\\n        uint256 shift;\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\n            if (temp < (1 << b)) {\\n                shift += b; // number of zero upper bits\\n            } else {\\n                temp >>= b; // shift away lower half\\n            }\\n        }\\n        if (dropZeroNibble && temp < 16) shift += 4;\\n        uint256 nibbles = 64 - (shift >> 2);\\n        hexString = new string(nibbles);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, shl(shift, value)) // left-align\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(0, dst, nibbles);\\n    }\\n\\n    /// @dev Format `bytes` as a hex string.\\n    /// @param v The bytes to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function bytesToHex(\\n        bytes memory v\\n    ) internal pure returns (string memory hexString) {\\n        uint256 nibbles = v.length << 1;\\n        hexString = new string(nibbles);\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(v, 32)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(src, dst, nibbles);\\n    }\\n\\n    /// @dev Converts arbitrary memory to a hex string.\\n    /// @param src The memory offset of first nibble of input.\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\n    function unsafeHex(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure {\\n        unchecked {\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(src)\\n                }\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\"a\\\" - 10) => 0x57\\n                    assembly {\\n                        mstore8(dst, b)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab784cab15b7a06154be3555edf0d25bcdad8e6bf116aa2016119a233875b02b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 1905,
        "contract": "project/lib/ens-contracts/contracts/dnsregistrar/DNSRegistrar.sol:DNSRegistrar",
        "label": "suffixes",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(PublicSuffixList)3375"
      },
      {
        "astId": 1913,
        "contract": "project/lib/ens-contracts/contracts/dnsregistrar/DNSRegistrar.sol:DNSRegistrar",
        "label": "inceptions",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_uint32)"
      }
    ],
    "types": {
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(PublicSuffixList)3375": {
        "encoding": "inplace",
        "label": "contract PublicSuffixList",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_uint32)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint32)",
        "numberOfBytes": "32",
        "value": "t_uint32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a85233c63b9ee964add6f2cffe00fd84eb32338f0000000000000000000000009a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae0000000000000000000000004a679253410272dd5232b3ff7cf5dbb88f295319000000000000000000000000cf7ed3acca5a467e9e704c703e8d87f634fb0fc9",
  "transaction": {
    "hash": "0xb16aa7ba1915b5c65d9d60f877300e0674d3016305328c7d1563102554e4abb2",
    "nonce": "0x40",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x8c376ee58b7e73232ca47f7c95902e0f254e4602cdf49e29db3a35d25a56422f",
    "blockNumber": "0x4b",
    "transactionIndex": "0x0"
  }
}
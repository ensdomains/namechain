{
  "address": "0x9a676e781a523b5d0c0e43731313a708cb607508",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "key",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "P256SHA256Algorithm",
  "sourceName": "lib/ens-contracts/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol",
  "bytecode": "0x6080604052348015600e575f80fd5b50610f3f8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063de8f50a11461002d575b5f80fd5b61004061003b366004610de3565b610054565b604051901515815260200160405180910390f35b5f6101296002868660405161006a929190610e76565b602060405180830381855afa158015610085573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906100a89190610e85565b6100e685858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061013492505050565b6101248a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506101c292505050565b610241565b979650505050505050565b61013c610d69565b81516040146101925760405162461bcd60e51b815260206004820152601d60248201527f496e76616c69642070323536207369676e6174757265206c656e67746800000060448201526064015b60405180910390fd5b60408051808201909152806101a7845f610434565b81526020908101906101ba908590610434565b905292915050565b6101ca610d69565b815160441461021b5760405162461bcd60e51b815260206004820152601760248201527f496e76616c69642070323536206b6579206c656e6774680000000000000000006044820152606401610189565b6040805180820190915280610231846004610434565b81526020016101ba846024610434565b81515f901580610272575082517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255111155b8061027f57506020830151155b1561028b57505f61042d565b8151602083015161029c9190610452565b6102a757505f61042d565b5f808080806102dd88600160200201517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255161054a565b905061034d7f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2967f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f57fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551848d096105e0565b885160208a01518b5193985091955061038d929091907fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551908590096105e0565b90945091505f61039f868587866106ab565b60408101519091505f036103bb575f965050505050505061042d565b5f6103db8260026020020151600160601b63ffffffff60c01b031961054a565b9050600160601b63ffffffff60c01b0319808283098351098a519091506104227fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255183610eb0565b149750505050505050505b9392505050565b5f61044983610444846020610ee3565b6106d0565b50016020015190565b5f82158061046d5750600160601b63ffffffff60c01b031983145b80610476575081155b8061048e5750600160601b63ffffffff60c01b031982145b1561049a57505f610544565b5f600160601b63ffffffff60c01b031983840990505f600160601b63ffffffff60c01b031985600160601b63ffffffff60c01b0319878809099050600160601b63ffffffff60c01b0319807fffffffff00000001000000000000000000000000fffffffffffffffffffffffc870982089050600160601b63ffffffff60c01b03197f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b820890501490505b92915050565b5f82158061055757508183145b80610560575081155b1561056c57505f610544565b818311156105875781838161058357610583610e9c565b0692505b5f60018385835b81156105bd578183816105a3576105a3610e9c565b94959404858102909403939192838302900391905061058e565b5f8512156105d45750505090830191506105449050565b50929695505050505050565b5f80825f036105f5575f805b915091506106a3565b826001036106075750839050826106a3565b82600203610619576105ec858561071c565b5083905082818160018061062e600288610eb0565b5f0361063b575f94508495505b600187901c96505b861561068f5761065484848461074a565b91955093509150610666600288610eb0565b6001036106835761067b8484848989866109a3565b919750955090505b600187901c9650610643565b61069a868683610aa3565b95509550505050505b935093915050565b6106b3610d87565b5f806106c187878787610af1565b90925090506101298282610b24565b81518111156107185781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610189918391600401918252602082015260400190565b5050565b5f805f61072b8585600161074a565b9196509450905061073d858583610aa3565b92509250505b9250929050565b5f805f805f805f61075b8a8a610b7c565b15610773575f6001819650965096505050505061099a565b600160601b63ffffffff60c01b0319888a099250600160601b63ffffffff60c01b0319600284099250600160601b63ffffffff60c01b03198a84099150600160601b63ffffffff60c01b03198983099150600160601b63ffffffff60c01b0319600283099150600160601b63ffffffff60c01b03198a8b099950600160601b63ffffffff60c01b031960038b099350600160601b63ffffffff60c01b03198889099750600160601b63ffffffff60c01b03197fffffffff00000001000000000000000000000000fffffffffffffffffffffffc89099750600160601b63ffffffff60c01b03198885089350600160601b63ffffffff60c01b03198485099050600160601b63ffffffff60c01b0319826002099950600160601b63ffffffff60c01b03196108ae8b600160601b63ffffffff60c01b0319610ef6565b82089050600160601b63ffffffff60c01b03196108d982600160601b63ffffffff60c01b0319610ef6565b83089950600160601b63ffffffff60c01b03198a85099950600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319898a099850600160601b63ffffffff60c01b0319896002099850600160601b63ffffffff60c01b03196109558a600160601b63ffffffff60c01b0319610ef6565b8b089550600160601b63ffffffff60c01b03198184099650600160601b63ffffffff60c01b03198384099450600160601b63ffffffff60c01b03198386099450505050505b93509350939050565b5f805f805f805f6109b48d8d610b7c565b156109cb5789898996509650965050505050610a97565b6109d58a8a610b7c565b156109ec578c8c8c96509650965050505050610a97565b600160601b63ffffffff60c01b0319888d099350600160601b63ffffffff60c01b03198b8a099250600160601b63ffffffff60c01b0319888e099150600160601b63ffffffff60c01b03198b8b099050808203610a6d57828403610a6457610a558d8d8d61074a565b96509650965050505050610a97565b5f600181610a55565b610a8b600160601b63ffffffff60c01b0319898d0983838688610b9e565b91985096509450505050505b96509650969350505050565b5f805f610abe84600160601b63ffffffff60c01b031961054a565b9050600160601b63ffffffff60c01b03198187099250600160601b63ffffffff60c01b0319818609915050935093915050565b5f805f610b0487876001888860016109a3565b91985096509050610b16878783610aa3565b925092505094509492505050565b610b2c610d87565b600160601b63ffffffff60c01b031960015f0860408201819052600160601b63ffffffff60c01b031990840981526040810151600160601b63ffffffff60c01b0319908309602082015292915050565b5f82158015610b89575081155b15610b9657506001610544565b505f92915050565b5f80808080808080600160601b63ffffffff60c01b0319610bcd8b600160601b63ffffffff60c01b0319610ef6565b8a089050600160601b63ffffffff60c01b0319610bf88c600160601b63ffffffff60c01b0319610ef6565b8d089450600160601b63ffffffff60c01b03198586099350600160601b63ffffffff60c01b03198182099150600160601b63ffffffff60c01b03198d83099150600160601b63ffffffff60c01b03198c8c089a50600160601b63ffffffff60c01b0319848c099a50600160601b63ffffffff60c01b0319610c878c600160601b63ffffffff60c01b0319610ef6565b83089150600160601b63ffffffff60c01b03198286099750600160601b63ffffffff60c01b03198585099250600160601b63ffffffff60c01b0319848d099b50600160601b63ffffffff60c01b0319610cee83600160601b63ffffffff60c01b0319610ef6565b8d089b50600160601b63ffffffff60c01b03198c82099050600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319610d418a600160601b63ffffffff60c01b0319610ef6565b82089650600160601b63ffffffff60c01b03198d840995505050505050955095509592505050565b60405180604001604052806002906020820280368337509192915050565b60405180606001604052806003906020820280368337509192915050565b5f8083601f840112610db5575f80fd5b50813567ffffffffffffffff811115610dcc575f80fd5b602083019150836020828501011115610743575f80fd5b5f805f805f8060608789031215610df8575f80fd5b863567ffffffffffffffff80821115610e0f575f80fd5b610e1b8a838b01610da5565b90985096506020890135915080821115610e33575f80fd5b610e3f8a838b01610da5565b90965094506040890135915080821115610e57575f80fd5b50610e6489828a01610da5565b979a9699509497509295939492505050565b818382375f9101908152919050565b5f60208284031215610e95575f80fd5b5051919050565b634e487b7160e01b5f52601260045260245ffd5b5f82610eca57634e487b7160e01b5f52601260045260245ffd5b500690565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561054457610544610ecf565b8181038181111561054457610544610ecf56fea264697066735822122074ba30a86bdd10269afc17318bebbe9eaeda925a8b40b37bafb5ef1afcac447164736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063de8f50a11461002d575b5f80fd5b61004061003b366004610de3565b610054565b604051901515815260200160405180910390f35b5f6101296002868660405161006a929190610e76565b602060405180830381855afa158015610085573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906100a89190610e85565b6100e685858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061013492505050565b6101248a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506101c292505050565b610241565b979650505050505050565b61013c610d69565b81516040146101925760405162461bcd60e51b815260206004820152601d60248201527f496e76616c69642070323536207369676e6174757265206c656e67746800000060448201526064015b60405180910390fd5b60408051808201909152806101a7845f610434565b81526020908101906101ba908590610434565b905292915050565b6101ca610d69565b815160441461021b5760405162461bcd60e51b815260206004820152601760248201527f496e76616c69642070323536206b6579206c656e6774680000000000000000006044820152606401610189565b6040805180820190915280610231846004610434565b81526020016101ba846024610434565b81515f901580610272575082517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255111155b8061027f57506020830151155b1561028b57505f61042d565b8151602083015161029c9190610452565b6102a757505f61042d565b5f808080806102dd88600160200201517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255161054a565b905061034d7f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2967f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f57fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551848d096105e0565b885160208a01518b5193985091955061038d929091907fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551908590096105e0565b90945091505f61039f868587866106ab565b60408101519091505f036103bb575f965050505050505061042d565b5f6103db8260026020020151600160601b63ffffffff60c01b031961054a565b9050600160601b63ffffffff60c01b0319808283098351098a519091506104227fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255183610eb0565b149750505050505050505b9392505050565b5f61044983610444846020610ee3565b6106d0565b50016020015190565b5f82158061046d5750600160601b63ffffffff60c01b031983145b80610476575081155b8061048e5750600160601b63ffffffff60c01b031982145b1561049a57505f610544565b5f600160601b63ffffffff60c01b031983840990505f600160601b63ffffffff60c01b031985600160601b63ffffffff60c01b0319878809099050600160601b63ffffffff60c01b0319807fffffffff00000001000000000000000000000000fffffffffffffffffffffffc870982089050600160601b63ffffffff60c01b03197f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b820890501490505b92915050565b5f82158061055757508183145b80610560575081155b1561056c57505f610544565b818311156105875781838161058357610583610e9c565b0692505b5f60018385835b81156105bd578183816105a3576105a3610e9c565b94959404858102909403939192838302900391905061058e565b5f8512156105d45750505090830191506105449050565b50929695505050505050565b5f80825f036105f5575f805b915091506106a3565b826001036106075750839050826106a3565b82600203610619576105ec858561071c565b5083905082818160018061062e600288610eb0565b5f0361063b575f94508495505b600187901c96505b861561068f5761065484848461074a565b91955093509150610666600288610eb0565b6001036106835761067b8484848989866109a3565b919750955090505b600187901c9650610643565b61069a868683610aa3565b95509550505050505b935093915050565b6106b3610d87565b5f806106c187878787610af1565b90925090506101298282610b24565b81518111156107185781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610189918391600401918252602082015260400190565b5050565b5f805f61072b8585600161074a565b9196509450905061073d858583610aa3565b92509250505b9250929050565b5f805f805f805f61075b8a8a610b7c565b15610773575f6001819650965096505050505061099a565b600160601b63ffffffff60c01b0319888a099250600160601b63ffffffff60c01b0319600284099250600160601b63ffffffff60c01b03198a84099150600160601b63ffffffff60c01b03198983099150600160601b63ffffffff60c01b0319600283099150600160601b63ffffffff60c01b03198a8b099950600160601b63ffffffff60c01b031960038b099350600160601b63ffffffff60c01b03198889099750600160601b63ffffffff60c01b03197fffffffff00000001000000000000000000000000fffffffffffffffffffffffc89099750600160601b63ffffffff60c01b03198885089350600160601b63ffffffff60c01b03198485099050600160601b63ffffffff60c01b0319826002099950600160601b63ffffffff60c01b03196108ae8b600160601b63ffffffff60c01b0319610ef6565b82089050600160601b63ffffffff60c01b03196108d982600160601b63ffffffff60c01b0319610ef6565b83089950600160601b63ffffffff60c01b03198a85099950600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319898a099850600160601b63ffffffff60c01b0319896002099850600160601b63ffffffff60c01b03196109558a600160601b63ffffffff60c01b0319610ef6565b8b089550600160601b63ffffffff60c01b03198184099650600160601b63ffffffff60c01b03198384099450600160601b63ffffffff60c01b03198386099450505050505b93509350939050565b5f805f805f805f6109b48d8d610b7c565b156109cb5789898996509650965050505050610a97565b6109d58a8a610b7c565b156109ec578c8c8c96509650965050505050610a97565b600160601b63ffffffff60c01b0319888d099350600160601b63ffffffff60c01b03198b8a099250600160601b63ffffffff60c01b0319888e099150600160601b63ffffffff60c01b03198b8b099050808203610a6d57828403610a6457610a558d8d8d61074a565b96509650965050505050610a97565b5f600181610a55565b610a8b600160601b63ffffffff60c01b0319898d0983838688610b9e565b91985096509450505050505b96509650969350505050565b5f805f610abe84600160601b63ffffffff60c01b031961054a565b9050600160601b63ffffffff60c01b03198187099250600160601b63ffffffff60c01b0319818609915050935093915050565b5f805f610b0487876001888860016109a3565b91985096509050610b16878783610aa3565b925092505094509492505050565b610b2c610d87565b600160601b63ffffffff60c01b031960015f0860408201819052600160601b63ffffffff60c01b031990840981526040810151600160601b63ffffffff60c01b0319908309602082015292915050565b5f82158015610b89575081155b15610b9657506001610544565b505f92915050565b5f80808080808080600160601b63ffffffff60c01b0319610bcd8b600160601b63ffffffff60c01b0319610ef6565b8a089050600160601b63ffffffff60c01b0319610bf88c600160601b63ffffffff60c01b0319610ef6565b8d089450600160601b63ffffffff60c01b03198586099350600160601b63ffffffff60c01b03198182099150600160601b63ffffffff60c01b03198d83099150600160601b63ffffffff60c01b03198c8c089a50600160601b63ffffffff60c01b0319848c099a50600160601b63ffffffff60c01b0319610c878c600160601b63ffffffff60c01b0319610ef6565b83089150600160601b63ffffffff60c01b03198286099750600160601b63ffffffff60c01b03198585099250600160601b63ffffffff60c01b0319848d099b50600160601b63ffffffff60c01b0319610cee83600160601b63ffffffff60c01b0319610ef6565b8d089b50600160601b63ffffffff60c01b03198c82099050600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319610d418a600160601b63ffffffff60c01b0319610ef6565b82089650600160601b63ffffffff60c01b03198d840995505050505050955095509592505050565b60405180604001604052806002906020820280368337509192915050565b60405180606001604052806003906020820280368337509192915050565b5f8083601f840112610db5575f80fd5b50813567ffffffffffffffff811115610dcc575f80fd5b602083019150836020828501011115610743575f80fd5b5f805f805f8060608789031215610df8575f80fd5b863567ffffffffffffffff80821115610e0f575f80fd5b610e1b8a838b01610da5565b90985096506020890135915080821115610e33575f80fd5b610e3f8a838b01610da5565b90965094506040890135915080821115610e57575f80fd5b50610e6489828a01610da5565b979a9699509497509295939492505050565b818382375f9101908152919050565b5f60208284031215610e95575f80fd5b5051919050565b634e487b7160e01b5f52601260045260245ffd5b5f82610eca57634e487b7160e01b5f52601260045260245ffd5b500690565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561054457610544610ecf565b8181038181111561054457610544610ecf56fea264697066735822122074ba30a86bdd10269afc17318bebbe9eaeda925a8b40b37bafb5ef1afcac447164736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {},
  "inputSourceName": "project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol",
  "devdoc": {
    "errors": {
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "verify(bytes,bytes,bytes)": {
        "details": "Verifies a signature.",
        "params": {
          "data": "The signed data to verify.",
          "key": "The public key to verify with.",
          "signature": "The signature to verify."
        },
        "returns": {
          "_0": "True iff the signature is valid."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "780600",
        "executionCost": "810",
        "totalCost": "781410"
      },
      "external": {
        "verify(bytes,bytes,bytes)": "infinite"
      },
      "internal": {
        "parseKey(bytes memory)": "infinite",
        "parseSignature(bytes memory)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}]},\"kind\":\"dev\",\"methods\":{\"verify(bytes,bytes,bytes)\":{\"details\":\"Verifies a signature.\",\"params\":{\"data\":\"The signed data to verify.\",\"key\":\"The public key to verify with.\",\"signature\":\"The signature to verify.\"},\"returns\":{\"_0\":\"True iff the signature is valid.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol\":\"P256SHA256Algorithm\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@ensdomains/solsha1/contracts/=project/lib/solsha1/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts-v5/=project/lib/openzeppelin-contracts/contracts/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/ens-contracts/:@unruggable/gateways/=project/lib/unruggable-gateways/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\",\"project/test/mocks/v1/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/// @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\ninterface Algorithm {\\n    /// @dev Verifies a signature.\\n    /// @param key The public key to verify with.\\n    /// @param data The signed data to verify.\\n    /// @param signature The signature to verify.\\n    /// @return True iff the signature is valid.\\n    function verify(\\n        bytes calldata key,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xbcbdc06d72b64903e733e7ddfbf59c35c984c3eb0022baacab12c97292cc13df\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/// @title   EllipticCurve\\n/// @author  Tilman Drerup;\\n/// @notice  Implements elliptic curve math; Parametrized for SECP256R1.\\n///          Includes components of code by Andreas Olofsson, Alexander Vlasov\\n///          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\\n///          (https://github.com/orbs-network/elliptic-curve-solidity)\\n///          Source: https://github.com/tdrerup/elliptic-curve-solidity\\n/// @dev     NOTE: To disambiguate public keys when verifying signatures, activate\\n///          condition 'rs[1] > lowSmax' in validateSignature().\\ncontract EllipticCurve {\\n    // Set parameters for curve.\\n    uint256 constant a =\\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\\n    uint256 constant b =\\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\\n    uint256 constant gx =\\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\\n    uint256 constant gy =\\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\\n    uint256 constant p =\\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 constant n =\\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\\n\\n    uint256 constant lowSmax =\\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\\n\\n    /// @dev Inverse of u in the field of modulo m.\\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\\n        unchecked {\\n            if (u == 0 || u == m || m == 0) return 0;\\n            if (u > m) u = u % m;\\n\\n            int256 t1;\\n            int256 t2 = 1;\\n            uint256 r1 = m;\\n            uint256 r2 = u;\\n            uint256 q;\\n\\n            while (r2 != 0) {\\n                q = r1 / r2;\\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\\n            }\\n\\n            if (t1 < 0) return (m - uint256(-t1));\\n\\n            return uint256(t1);\\n        }\\n    }\\n\\n    /// @dev Transform affine coordinates into projective coordinates.\\n    function toProjectivePoint(\\n        uint256 x0,\\n        uint256 y0\\n    ) internal pure returns (uint256[3] memory P) {\\n        P[2] = addmod(0, 1, p);\\n        P[0] = mulmod(x0, P[2], p);\\n        P[1] = mulmod(y0, P[2], p);\\n    }\\n\\n    /// @dev Add two points in affine coordinates and return projective point.\\n    function addAndReturnProjectivePoint(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 x2,\\n        uint256 y2\\n    ) internal pure returns (uint256[3] memory P) {\\n        uint256 x;\\n        uint256 y;\\n        (x, y) = add(x1, y1, x2, y2);\\n        P = toProjectivePoint(x, y);\\n    }\\n\\n    /// @dev Transform from projective to affine coordinates.\\n    function toAffinePoint(\\n        uint256 x0,\\n        uint256 y0,\\n        uint256 z0\\n    ) internal pure returns (uint256 x1, uint256 y1) {\\n        uint256 z0Inv;\\n        z0Inv = inverseMod(z0, p);\\n        x1 = mulmod(x0, z0Inv, p);\\n        y1 = mulmod(y0, z0Inv, p);\\n    }\\n\\n    /// @dev Return the zero curve in projective coordinates.\\n    function zeroProj()\\n        internal\\n        pure\\n        returns (uint256 x, uint256 y, uint256 z)\\n    {\\n        return (0, 1, 0);\\n    }\\n\\n    /// @dev Return the zero curve in affine coordinates.\\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\\n        return (0, 0);\\n    }\\n\\n    /// @dev Check if the curve is the zero curve.\\n    function isZeroCurve(\\n        uint256 x0,\\n        uint256 y0\\n    ) internal pure returns (bool isZero) {\\n        if (x0 == 0 && y0 == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Check if a point in affine coordinates is on the curve.\\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\\n        if (0 == x || x == p || 0 == y || y == p) {\\n            return false;\\n        }\\n\\n        uint256 LHS = mulmod(y, y, p); // y^2\\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\\n\\n        if (a != 0) {\\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\\n        }\\n        if (b != 0) {\\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\\n        }\\n\\n        return LHS == RHS;\\n    }\\n\\n    /// @dev Double an elliptic curve point in projective coordinates. See\\n    /// https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\\n    function twiceProj(\\n        uint256 x0,\\n        uint256 y0,\\n        uint256 z0\\n    ) internal pure returns (uint256 x1, uint256 y1, uint256 z1) {\\n        uint256 t;\\n        uint256 u;\\n        uint256 v;\\n        uint256 w;\\n\\n        if (isZeroCurve(x0, y0)) {\\n            return zeroProj();\\n        }\\n\\n        u = mulmod(y0, z0, p);\\n        u = mulmod(u, 2, p);\\n\\n        v = mulmod(u, x0, p);\\n        v = mulmod(v, y0, p);\\n        v = mulmod(v, 2, p);\\n\\n        x0 = mulmod(x0, x0, p);\\n        t = mulmod(x0, 3, p);\\n\\n        z0 = mulmod(z0, z0, p);\\n        z0 = mulmod(z0, a, p);\\n        t = addmod(t, z0, p);\\n\\n        w = mulmod(t, t, p);\\n        x0 = mulmod(2, v, p);\\n        w = addmod(w, p - x0, p);\\n\\n        x0 = addmod(v, p - w, p);\\n        x0 = mulmod(t, x0, p);\\n        y0 = mulmod(y0, u, p);\\n        y0 = mulmod(y0, y0, p);\\n        y0 = mulmod(2, y0, p);\\n        y1 = addmod(x0, p - y0, p);\\n\\n        x1 = mulmod(u, w, p);\\n\\n        z1 = mulmod(u, u, p);\\n        z1 = mulmod(z1, u, p);\\n    }\\n\\n    /// @dev Add two elliptic curve points in projective coordinates. See\\n    /// https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\\n    function addProj(\\n        uint256 x0,\\n        uint256 y0,\\n        uint256 z0,\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    ) internal pure returns (uint256 x2, uint256 y2, uint256 z2) {\\n        uint256 t0;\\n        uint256 t1;\\n        uint256 u0;\\n        uint256 u1;\\n\\n        if (isZeroCurve(x0, y0)) {\\n            return (x1, y1, z1);\\n        } else if (isZeroCurve(x1, y1)) {\\n            return (x0, y0, z0);\\n        }\\n\\n        t0 = mulmod(y0, z1, p);\\n        t1 = mulmod(y1, z0, p);\\n\\n        u0 = mulmod(x0, z1, p);\\n        u1 = mulmod(x1, z0, p);\\n\\n        if (u0 == u1) {\\n            if (t0 == t1) {\\n                return twiceProj(x0, y0, z0);\\n            } else {\\n                return zeroProj();\\n            }\\n        }\\n\\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\\n    }\\n\\n    /// @dev Helper function that splits addProj to avoid too many local variables.\\n    function addProj2(\\n        uint256 v,\\n        uint256 u0,\\n        uint256 u1,\\n        uint256 t1,\\n        uint256 t0\\n    ) private pure returns (uint256 x2, uint256 y2, uint256 z2) {\\n        uint256 u;\\n        uint256 u2;\\n        uint256 u3;\\n        uint256 w;\\n        uint256 t;\\n\\n        t = addmod(t0, p - t1, p);\\n        u = addmod(u0, p - u1, p);\\n        u2 = mulmod(u, u, p);\\n\\n        w = mulmod(t, t, p);\\n        w = mulmod(w, v, p);\\n        u1 = addmod(u1, u0, p);\\n        u1 = mulmod(u1, u2, p);\\n        w = addmod(w, p - u1, p);\\n\\n        x2 = mulmod(u, w, p);\\n\\n        u3 = mulmod(u2, u, p);\\n        u0 = mulmod(u0, u2, p);\\n        u0 = addmod(u0, p - w, p);\\n        t = mulmod(t, u0, p);\\n        t0 = mulmod(t0, u3, p);\\n\\n        y2 = addmod(t, p - t0, p);\\n\\n        z2 = mulmod(u3, v, p);\\n    }\\n\\n    /// @dev Add two elliptic curve points in affine coordinates.\\n    function add(\\n        uint256 x0,\\n        uint256 y0,\\n        uint256 x1,\\n        uint256 y1\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 z0;\\n\\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\\n\\n        return toAffinePoint(x0, y0, z0);\\n    }\\n\\n    /// @dev Double an elliptic curve point in affine coordinates.\\n    function twice(\\n        uint256 x0,\\n        uint256 y0\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 z0;\\n\\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\\n\\n        return toAffinePoint(x0, y0, z0);\\n    }\\n\\n    /// @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\\n    function multiplyPowerBase2(\\n        uint256 x0,\\n        uint256 y0,\\n        uint256 exp\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 base2X = x0;\\n        uint256 base2Y = y0;\\n        uint256 base2Z = 1;\\n\\n        for (uint256 i = 0; i < exp; i++) {\\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\\n        }\\n\\n        return toAffinePoint(base2X, base2Y, base2Z);\\n    }\\n\\n    /// @dev Multiply an elliptic curve point by a scalar.\\n    function multiplyScalar(\\n        uint256 x0,\\n        uint256 y0,\\n        uint256 scalar\\n    ) internal pure returns (uint256 x1, uint256 y1) {\\n        if (scalar == 0) {\\n            return zeroAffine();\\n        } else if (scalar == 1) {\\n            return (x0, y0);\\n        } else if (scalar == 2) {\\n            return twice(x0, y0);\\n        }\\n\\n        uint256 base2X = x0;\\n        uint256 base2Y = y0;\\n        uint256 base2Z = 1;\\n        uint256 z1 = 1;\\n        x1 = x0;\\n        y1 = y0;\\n\\n        if (scalar % 2 == 0) {\\n            x1 = y1 = 0;\\n        }\\n\\n        scalar = scalar >> 1;\\n\\n        while (scalar > 0) {\\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\\n\\n            if (scalar % 2 == 1) {\\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\\n            }\\n\\n            scalar = scalar >> 1;\\n        }\\n\\n        return toAffinePoint(x1, y1, z1);\\n    }\\n\\n    /// @dev Multiply the curve's generator point by a scalar.\\n    function multipleGeneratorByScalar(\\n        uint256 scalar\\n    ) internal pure returns (uint256, uint256) {\\n        return multiplyScalar(gx, gy, scalar);\\n    }\\n\\n    /// @dev Validate combination of message, signature, and public key.\\n    function validateSignature(\\n        bytes32 message,\\n        uint256[2] memory rs,\\n        uint256[2] memory Q\\n    ) internal pure returns (bool) {\\n        // To disambiguate between public key solutions, include comment below.\\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\\n            // || rs[1] > lowSmax)\\n            return false;\\n        }\\n        if (!isOnCurve(Q[0], Q[1])) {\\n            return false;\\n        }\\n\\n        uint256 x1;\\n        uint256 x2;\\n        uint256 y1;\\n        uint256 y2;\\n\\n        uint256 sInv = inverseMod(rs[1], n);\\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\\n\\n        if (P[2] == 0) {\\n            return false;\\n        }\\n\\n        uint256 Px = inverseMod(P[2], p);\\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\\n\\n        return Px % n == rs[0];\\n    }\\n}\\n\",\"keccak256\":\"0x7e3b01a4fcdbb4b339ae5f559f9b3ff6a713683a20a94d71265c6151863f3bff\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./Algorithm.sol\\\";\\nimport \\\"./EllipticCurve.sol\\\";\\nimport \\\"../../utils/BytesUtils.sol\\\";\\n\\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\\n    using BytesUtils for *;\\n\\n    /// @dev Verifies a signature.\\n    /// @param key The public key to verify with.\\n    /// @param data The signed data to verify.\\n    /// @param signature The signature to verify.\\n    /// @return True iff the signature is valid.\\n    function verify(\\n        bytes calldata key,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external view override returns (bool) {\\n        return\\n            validateSignature(\\n                sha256(data),\\n                parseSignature(signature),\\n                parseKey(key)\\n            );\\n    }\\n\\n    function parseSignature(\\n        bytes memory data\\n    ) internal pure returns (uint256[2] memory) {\\n        require(data.length == 64, \\\"Invalid p256 signature length\\\");\\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\\n    }\\n\\n    function parseKey(\\n        bytes memory data\\n    ) internal pure returns (uint256[2] memory) {\\n        require(data.length == 68, \\\"Invalid p256 key length\\\");\\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\\n    }\\n}\\n\",\"keccak256\":\"0xe61ddfe4b15f5474c4130c1b970356897487c398c3c4faff3ab144b8ea5a9db1\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x",
  "transaction": {
    "hash": "0xec8384006e9ea2ba0dd98efbd18ed5d3a1c8542732f45ed4164e6d331e4ff7a0",
    "nonce": "0xe",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x25f52cedced5927f2a65e971d8670eb6ea208c0089c959a6794ae4b09194e0cb",
    "blockNumber": "0xf",
    "transactionIndex": "0x0"
  }
}
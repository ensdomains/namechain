{
  "address": "0x5fc8d32690cc91d4c39d9d3abcbd16989f875707",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ENS",
          "name": "registryV1",
          "type": "address"
        },
        {
          "internalType": "contract IGatewayProvider",
          "name": "batchGatewayProvider",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBatchGatewayResponse",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "string[]",
          "name": "urls",
          "type": "string[]"
        },
        {
          "internalType": "bytes",
          "name": "callData",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "callbackFunction",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "OffchainLookup",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "UnreachableName",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BATCH_GATEWAY_PROVIDER",
      "outputs": [
        {
          "internalType": "contract IGatewayProvider",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REGISTRY_V1",
      "outputs": [
        {
          "internalType": "contract ENS",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "hasContext",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "string[]",
          "name": "batchGateways",
          "type": "string[]"
        }
      ],
      "name": "callResolver",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "name": "ccipBatch",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipBatchCallback",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipReadCallback",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveBatchCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "resolveDirectImmediateCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "feature",
          "type": "bytes4"
        }
      ],
      "name": "supportsFeature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "ENSV1Resolver",
  "sourceName": "src/resolver/ENSV1Resolver.sol",
  "bytecode": "0x60e060405234801561000f575f80fd5b506040516127f13803806127f183398101604081905261002e91610062565b61c3506080526001600160a01b0391821660a0521660c05261009a565b6001600160a01b038116811461005f575f80fd5b50565b5f8060408385031215610073575f80fd5b825161007e8161004b565b602084015190925061008f8161004b565b809150509250929050565b60805160a05160c05161271f6100d25f395f8181610139015261052c01525f81816101e2015261042301525f610eb4015261271f5ff3fe608060405234801561000f575f80fd5b50600436106100c4575f3560e01c80639061b9231161007d578063e370ecbe11610058578063e370ecbe146101dd578063ef46c0b814610204578063f394443a14610219575f80fd5b80639061b923146101975780639f28e99d146101aa578063b536af76146101ca575f80fd5b8063582de3e7116100ad578063582de3e7146101105780636ccb8660146101345780636d6dd54014610173575f80fd5b806301ffc9a7146100c8578063491fc4f9146100f0575b5f80fd5b6100db6100d63660046117d5565b61022c565b60405190151581526020015b60405180910390f35b6101036100fe36600461182e565b61027d565b6040516100e791906118c3565b6100db61011e3660046117d5565b6001600160e01b0319166312d6c5b760e31b1490565b61015b7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e7565b61018961018136600461182e565b509192909150565b6040516100e79291906118d5565b6101036101a536600461182e565b61041b565b6101bd6101b8366004611b17565b6105a6565b6040516100e79190611cd7565b6101bd6101d836600461182e565b610767565b61015b7f000000000000000000000000000000000000000000000000000000000000000081565b610217610212366004611da0565b6109b6565b005b610103610227366004611e18565b610a3b565b5f639061b92360e01b6001600160e01b03198316148061025c575063582de3e760e01b6001600160e01b03198316145b8061027757506301ffc9a760e01b6001600160e01b03198316145b92915050565b60605f61028c85870187611b17565b5190505f8061029d85870187611edd565b9150915081156103aa575f835167ffffffffffffffff8111156102c2576102c2611903565b6040519080825280602002602001820160405280156102f557816020015b60608152602001906001900390816102e05790505b5090505f5b845181101561037e575f85828151811061031657610316611f14565b602002602001015190505f8160400151905084801561033a57506060820151600e16155b1561035657808060200190518101906103539190611f7c565b90505b8084848151811061036957610369611f14565b602090810291909101015250506001016102fa565b50806040516020016103909190611fae565b604051602081830303815290604052945050505050610413565b5f835f815181106103bd576103bd611f14565b60209081029190910101516040810151606082015191925090600e16156103e657805160208201fd5b821561040357808060200190518101906104009190611f7c565b90505b94506104139350505050565b5050505b949350505050565b60605f61047d7f000000000000000000000000000000000000000000000000000000000000000087878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610d72915050565b5050905061059c8187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516020601f8b0181900481028201810190925289815292508991508890819084018382808284375f9201829052506040805160208101825282815281517f093a86d3000000000000000000000000000000000000000000000000000000008152915192955093506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063093a86d391600480830192879291908290030181865afa158015610575573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610227919081019061209e565b5050949350505050565b60408051808201909152606080825260208201525f5b825151811015610759575f835f015182815181106105dc576105dc611f14565b6020026020010151905060408160600151165f146105fa5750610751565b60608101516030165f036106a4575f610615825f0151610e6e565b610620576010610623565b60205b9050825b8551518110156106a157825f01516001600160a01b0316865f0151828151811061065357610653611f14565b60200260200101515f01516001600160a01b0316036106995781865f0151828151811061068257610682611f14565b602002602001015160600181815117915081815250505b600101610627565b50505b5f60208260600151165f1490505f806106c68315855f01518660200151610ea0565b91509150811580156106f05750630556f18360e41b6106e4826120d0565b6001600160e01b031916145b15610705576060840180516001179052610745565b606084018051604017905282801561071c57508051155b61073157816107315760608401805160021790525b80515f036107455760608401805160081790525b60409093019290925250505b6001016105bc565b5061076382610f33565b5090565b60408051808201909152606080825260208201525f8061078986880188612182565b9150915080518251146107af5760405163252e18f560e11b815260040160405180910390fd5b6107bb84860186611b17565b92505f805b84515181101561098b575f855f015182815181106107e0576107e0611f14565b6020026020010151905060408160600151165f03610982578351831015610976575f84848151811061081457610814611f14565b6020026020010151905085848151811061083057610830611f14565b60200260200101511561084d576060820180516044179052610970565b5f61085b836040015161111e565b90505f815f01516001600160a01b03168260600151848460800151604051602401610887929190612234565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516108c59190612258565b5f60405180830381855afa9150503d805f81146108fd576040519150601f19603f3d011682016040523d82523d5f602084013e610902565b606091505b5093509050808061092c5750630556f18360e41b61091f846120d0565b6001600160e01b03191614155b1561096d57606084018051604017905280158061094857508251155b156109595760608401805160021790525b82515f0361096d5760608401805160081790525b50505b60408201525b61097f83612282565b92505b506001016107c0565b50815181146109ad5760405163252e18f560e11b815260040160405180910390fd5b61040f84610f33565b5f818060200190518101906109cb91906122b0565b9050610a36815f015182602001518584604001516040516024016109f0929190612234565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a0860151611162565b505050565b6060866001600160a01b03163b5f03610a8b57856040517f5fe9a5df000000000000000000000000000000000000000000000000000000008152600401610a8291906118c3565b60405180910390fd5b5f7fac9650d800000000000000000000000000000000000000000000000000000000610ab6876120d0565b6001600160e01b0319161490505f858015610add5750610add8963477cc53f60e11b611325565b90505f8180610af85750610af88a639061b92360e01b611325565b9050610b0b8a63582de3e760e01b611325565b8015610b8f5750821580610b8f5750808015610b8f575060405163582de3e760e01b81526312d6c5b760e31b60048201526001600160a01b038b169063582de3e790602401602060405180830381865afa158015610b6b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b8f919061237f565b15610bd9578015610bb457610baf8a610baa848c8c8b6113ab565b61143d565b610bd9565b610bd98a89636d6dd54060e01b5f60e01b60405180602001604052805f815250611162565b60608315610c1357610bf9896004808c51610bf4919061239a565b611462565b806020019051810190610c0c91906123ad565b9050610c5e565b60408051600180825281830190925290816020015b6060815260200190600190039081610c2857905050905088815f81518110610c5257610c52611f14565b60200260200101819052505b8115610cbb575f5b8151811015610cb957610c94848c848481518110610c8657610c86611f14565b60200260200101518b6113ab565b828281518110610ca657610ca6611f14565b6020908102919091010152600101610c66565b505b610d643080639f28e99d610cd08f868c6114be565b604051602401610ce09190611cd7565b60408051601f19818403018152918152602080830180516001600160e01b031660e09590951b94909417909352519092507f491fc4f900000000000000000000000000000000000000000000000000000000915f91610d50918b918a910191151582521515602082015260400190565b604051602081830303815290604052611162565b505050509695505050505050565b5f805f805f610d8187876115d3565b90925090508115610e62575f805f610d9a8b8b86610d72565b925092509250610db382865f9182526020526040902090565b6040517f0178b8bf000000000000000000000000000000000000000000000000000000008152600481018290529097506001600160a01b038c1690630178b8bf90602401602060405180830381865afa158015610e12573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e369190612457565b97506001600160a01b038816610e4e57828782610e52565b87878a5b9750975097505050505050610e65565b50505b93509350939050565b5f306001600160a01b03831603610e8757506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685610ed8577f0000000000000000000000000000000000000000000000000000000000000000610eda565b5a5b84604051610ee89190612258565b5f604051808303818686fa925050503d805f8114610f21576040519150601f19603f3d011682016040523d82523d5f602084013e610f26565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff811115610f5057610f50611903565b604051908082528060200260200182016040528015610fad57816020015b610f9a60405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b815260200190600190039081610f6e5790505b5090505f805b83515181101561105e575f845f01518281518110610fd357610fd3611f14565b6020026020010151905060408160600151165f03611055575f610ff9826040015161111e565b90506040518060600160405280825f01516001600160a01b0316815260200182602001518152602001826040015181525085858061103690612282565b96508151811061104857611048611f14565b6020026020010181905250505b50600101610fb3565b508015610a36578082523083602001518360405160240161107f9190612472565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af7600000000000000000000000000000000000000000000000000000000916110f391899101611cd7565b60408051601f1981840301815290829052630556f18360e41b8252610a82959493929160040161250c565b6040805160a0810182525f80825260606020830181905292820183905282820152608081019190915261027761115d836004808651610bf4919061239a565b611600565b5f8061117761117088610e6e565b8888610ea0565b91509150811580156111a15750630556f18360e41b611195826120d0565b6001600160e01b031916145b1561124f575f6111b08261111e565b9050876001600160a01b0316815f01516001600160a01b03160361124d57308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b0319168152602001898152506040516020016110f3919061256f565b505b5f8261125b578461125d565b855b90506001600160e01b031981161561130f57306001600160a01b031681838660405160240161128d929190612234565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516112cb9190612258565b5f60405180830381855afa9150503d805f8114611303576040519150601f19603f3d011682016040523d82523d5f602084013e611308565b606091505b5090935091505b821561131d57815160208301f35b815160208301fd5b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f519050828015611395575060208210155b80156113a057505f81115b979650505050505050565b6060846113f45783836040516024016113c5929190612234565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b179052611434565b838383604051602401611409939291906125eb565b60408051601f198184030181529190526020810180516001600160e01b031663477cc53f60e11b1790525b95945050505050565b61145e82825f60e01b5f60e01b60405180602001604052805f815250611162565b5050565b60608167ffffffffffffffff81111561147d5761147d611903565b6040519080825280601f01601f1916602001820160405280156114a7576020820181803683370190505b5090506114b78484835f8661166b565b9392505050565b60408051808201909152606080825260208201525f835167ffffffffffffffff8111156114ed576114ed611903565b60405190808252806020026020018201604052801561155057816020015b61153d60405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b81526020019060019003908161150b5790505b5090505f5b84518110156115b6575f82828151811061157157611571611f14565b60209081029190910101516001600160a01b0388168152865190915086908390811061159f5761159f611f14565b602090810291909101810151910152600101611555565b506040805180820190915290815260208101929092525092915050565b5f805f6115e085856116a8565b9250905060ff8116156115f857806021858701012092505b509250929050565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091528180602001905181019061163d919061262d565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b61167e8561167983876126d6565b61172c565b61168c8361167983856126d6565b6116a182602085010185602088010183611774565b5050505050565b5f80835183106116cd578360405163ba4adc2360e01b8152600401610a8291906118c3565b8383815181106116df576116df611f14565b016020015160f81c915050818101600101816116ff578351811415611705565b83518110155b15611725578360405163ba4adc2360e01b8152600401610a8291906118c3565b9250929050565b815181111561145e5781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610a82918391600401918252602082015260400190565b5b601f811115611795578151835260209283019290910190601f1901611775565b8015610a365790518251600160209390930360031b9290921b5f190180199091169116179052565b6001600160e01b0319811681146117d2575f80fd5b50565b5f602082840312156117e5575f80fd5b81356114b7816117bd565b5f8083601f840112611800575f80fd5b50813567ffffffffffffffff811115611817575f80fd5b602083019150836020828501011115611725575f80fd5b5f805f8060408587031215611841575f80fd5b843567ffffffffffffffff80821115611858575f80fd5b611864888389016117f0565b9096509450602087013591508082111561187c575f80fd5b50611889878288016117f0565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6114b76020830184611895565b60208152816020820152818360408301375f818301604090810191909152601f909201601f19160101919050565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff8111828210171561193a5761193a611903565b60405290565b6040516080810167ffffffffffffffff8111828210171561193a5761193a611903565b60405160c0810167ffffffffffffffff8111828210171561193a5761193a611903565b604051601f8201601f1916810167ffffffffffffffff811182821017156119af576119af611903565b604052919050565b5f67ffffffffffffffff8211156119d0576119d0611903565b5060051b60200190565b6001600160a01b03811681146117d2575f80fd5b80356119f9816119da565b919050565b5f67ffffffffffffffff821115611a1757611a17611903565b50601f01601f191660200190565b5f611a37611a32846119fe565b611986565b9050828152838383011115611a4a575f80fd5b828260208301375f602084830101529392505050565b5f82601f830112611a6f575f80fd5b6114b783833560208501611a25565b5f82601f830112611a8d575f80fd5b81356020611a9d611a32836119b7565b82815260059290921b84018101918181019086841115611abb575f80fd5b8286015b84811015611b0c57803567ffffffffffffffff811115611add575f80fd5b8701603f81018913611aed575f80fd5b611afe898683013560408401611a25565b845250918301918301611abf565b509695505050505050565b5f6020808385031215611b28575f80fd5b823567ffffffffffffffff80821115611b3f575f80fd5b9084019060408287031215611b52575f80fd5b611b5a611917565b823582811115611b68575f80fd5b8301601f81018813611b78575f80fd5b8035611b86611a32826119b7565b81815260059190911b8201860190868101908a831115611ba4575f80fd5b8784015b83811015611c4c57803587811115611bbe575f80fd5b85016080818e03601f19011215611bd3575f80fd5b611bdb611940565b8a820135611be8816119da565b8152604082013589811115611bfb575f80fd5b611c098f8d83860101611a60565b8c83015250606082013589811115611c1f575f80fd5b611c2d8f8d83860101611a60565b6040830152506080919091013560608201528352918801918801611ba8565b5084525050508284013582811115611c62575f80fd5b611c6e88828601611a7e565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b84811015611cca57601f19868403018952611cb8838351611895565b98840198925090830190600101611c9c565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b82811015611d7557607f198b830301845285516001600160a01b03815116835289810151888b850152611d4089850182611895565b90508682015184820388860152611d578282611895565b928b0151948b01949094525095890195938901939150600101611d0b565b50968a0151898803601f190160408b015296611d918189611c7f565b9b9a5050505050505050505050565b5f8060408385031215611db1575f80fd5b823567ffffffffffffffff80821115611dc8575f80fd5b611dd486838701611a60565b93506020850135915080821115611de9575f80fd5b50611df685828601611a60565b9150509250929050565b80151581146117d2575f80fd5b80356119f981611e00565b5f805f805f8060c08789031215611e2d575f80fd5b611e36876119ee565b9550602087013567ffffffffffffffff80821115611e52575f80fd5b611e5e8a838b01611a60565b96506040890135915080821115611e73575f80fd5b611e7f8a838b01611a60565b9550611e8d60608a01611e0d565b94506080890135915080821115611ea2575f80fd5b611eae8a838b01611a60565b935060a0890135915080821115611ec3575f80fd5b50611ed089828a01611a7e565b9150509295509295509295565b5f8060408385031215611eee575f80fd5b8235611ef981611e00565b91506020830135611f0981611e00565b809150509250929050565b634e487b7160e01b5f52603260045260245ffd5b5f611f35611a32846119fe565b9050828152838383011115611f48575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f830112611f6d575f80fd5b6114b783835160208501611f28565b5f60208284031215611f8c575f80fd5b815167ffffffffffffffff811115611fa2575f80fd5b61041384828501611f5e565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561200357603f19888603018452611ff1858351611895565b94509285019290850190600101611fd5565b5092979650505050505050565b5f82601f83011261201f575f80fd5b8151602061202f611a32836119b7565b82815260059290921b8401810191818101908684111561204d575f80fd5b8286015b84811015611b0c57805167ffffffffffffffff81111561206f575f80fd5b8701603f8101891361207f575f80fd5b612090898683015160408401611f28565b845250918301918301612051565b5f602082840312156120ae575f80fd5b815167ffffffffffffffff8111156120c4575f80fd5b61041384828501612010565b5f815160208301516001600160e01b0319808216935060048310156120ff5780818460040360031b1b83161693505b505050919050565b5f82601f830112612116575f80fd5b81356020612126611a32836119b7565b82815260059290921b84018101918181019086841115612144575f80fd5b8286015b84811015611b0c57803567ffffffffffffffff811115612166575f80fd5b6121748986838b0101611a60565b845250918301918301612148565b5f8060408385031215612193575f80fd5b823567ffffffffffffffff808211156121aa575f80fd5b818501915085601f8301126121bd575f80fd5b813560206121cd611a32836119b7565b82815260059290921b840181019181810190898411156121eb575f80fd5b948201945b8386101561221257853561220381611e00565b825294820194908201906121f0565b96505086013592505080821115612227575f80fd5b50611df685828601612107565b604081525f6122466040830185611895565b82810360208401526114348185611895565b5f82518060208501845e5f920191825250919050565b634e487b7160e01b5f52601160045260245ffd5b5f600182016122935761229361226e565b5060010190565b80516119f9816119da565b80516119f9816117bd565b5f602082840312156122c0575f80fd5b815167ffffffffffffffff808211156122d7575f80fd5b9083019060c082860312156122ea575f80fd5b6122f2611963565b6122fb8361229a565b8152612309602084016122a5565b602082015260408301518281111561231f575f80fd5b61232b87828601611f5e565b60408301525061233d606084016122a5565b606082015261234e608084016122a5565b608082015260a083015182811115612364575f80fd5b61237087828601611f5e565b60a08301525095945050505050565b5f6020828403121561238f575f80fd5b81516114b781611e00565b818103818111156102775761027761226e565b5f60208083850312156123be575f80fd5b825167ffffffffffffffff808211156123d5575f80fd5b818501915085601f8301126123e8575f80fd5b81516123f6611a32826119b7565b81815260059190911b83018401908481019088831115612414575f80fd5b8585015b8381101561244a5780518581111561242e575f80fd5b61243c8b89838a0101611f5e565b845250918601918601612418565b5098975050505050505050565b5f60208284031215612467575f80fd5b81516114b7816119da565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156124fe57603f19898403018552815160606001600160a01b03825116855288820151818a8701526124d082870182611c7f565b915050878201519150848103888601526124ea8183611895565b968901969450505090860190600101612499565b509098975050505050505050565b6001600160a01b038616815260a060208201525f61252d60a0830187611c7f565b828103604084015261253f8187611895565b90506001600160e01b03198516606084015282810360808401526125638185611895565b98975050505050505050565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c060608501526125b560e0850183611895565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c08501526114348282611895565b606081525f6125fd6060830186611895565b828103602084015261260f8186611895565b905082810360408401526126238185611895565b9695505050505050565b5f805f805f60a08688031215612641575f80fd5b855161264c816119da565b602087015190955067ffffffffffffffff80821115612669575f80fd5b61267589838a01612010565b9550604088015191508082111561268a575f80fd5b61269689838a01611f5e565b9450606088015191506126a8826117bd565b6080880151919350808211156126bc575f80fd5b506126c988828901611f5e565b9150509295509295909350565b808201808211156102775761027761226e56fea2646970667358221220ec3f062e1bc91465118a78e0bb24e79b41f62c12e0cb9be937f97691eb5eec9f64736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b50600436106100c4575f3560e01c80639061b9231161007d578063e370ecbe11610058578063e370ecbe146101dd578063ef46c0b814610204578063f394443a14610219575f80fd5b80639061b923146101975780639f28e99d146101aa578063b536af76146101ca575f80fd5b8063582de3e7116100ad578063582de3e7146101105780636ccb8660146101345780636d6dd54014610173575f80fd5b806301ffc9a7146100c8578063491fc4f9146100f0575b5f80fd5b6100db6100d63660046117d5565b61022c565b60405190151581526020015b60405180910390f35b6101036100fe36600461182e565b61027d565b6040516100e791906118c3565b6100db61011e3660046117d5565b6001600160e01b0319166312d6c5b760e31b1490565b61015b7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e7565b61018961018136600461182e565b509192909150565b6040516100e79291906118d5565b6101036101a536600461182e565b61041b565b6101bd6101b8366004611b17565b6105a6565b6040516100e79190611cd7565b6101bd6101d836600461182e565b610767565b61015b7f000000000000000000000000000000000000000000000000000000000000000081565b610217610212366004611da0565b6109b6565b005b610103610227366004611e18565b610a3b565b5f639061b92360e01b6001600160e01b03198316148061025c575063582de3e760e01b6001600160e01b03198316145b8061027757506301ffc9a760e01b6001600160e01b03198316145b92915050565b60605f61028c85870187611b17565b5190505f8061029d85870187611edd565b9150915081156103aa575f835167ffffffffffffffff8111156102c2576102c2611903565b6040519080825280602002602001820160405280156102f557816020015b60608152602001906001900390816102e05790505b5090505f5b845181101561037e575f85828151811061031657610316611f14565b602002602001015190505f8160400151905084801561033a57506060820151600e16155b1561035657808060200190518101906103539190611f7c565b90505b8084848151811061036957610369611f14565b602090810291909101015250506001016102fa565b50806040516020016103909190611fae565b604051602081830303815290604052945050505050610413565b5f835f815181106103bd576103bd611f14565b60209081029190910101516040810151606082015191925090600e16156103e657805160208201fd5b821561040357808060200190518101906104009190611f7c565b90505b94506104139350505050565b5050505b949350505050565b60605f61047d7f000000000000000000000000000000000000000000000000000000000000000087878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610d72915050565b5050905061059c8187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516020601f8b0181900481028201810190925289815292508991508890819084018382808284375f9201829052506040805160208101825282815281517f093a86d3000000000000000000000000000000000000000000000000000000008152915192955093506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063093a86d391600480830192879291908290030181865afa158015610575573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610227919081019061209e565b5050949350505050565b60408051808201909152606080825260208201525f5b825151811015610759575f835f015182815181106105dc576105dc611f14565b6020026020010151905060408160600151165f146105fa5750610751565b60608101516030165f036106a4575f610615825f0151610e6e565b610620576010610623565b60205b9050825b8551518110156106a157825f01516001600160a01b0316865f0151828151811061065357610653611f14565b60200260200101515f01516001600160a01b0316036106995781865f0151828151811061068257610682611f14565b602002602001015160600181815117915081815250505b600101610627565b50505b5f60208260600151165f1490505f806106c68315855f01518660200151610ea0565b91509150811580156106f05750630556f18360e41b6106e4826120d0565b6001600160e01b031916145b15610705576060840180516001179052610745565b606084018051604017905282801561071c57508051155b61073157816107315760608401805160021790525b80515f036107455760608401805160081790525b60409093019290925250505b6001016105bc565b5061076382610f33565b5090565b60408051808201909152606080825260208201525f8061078986880188612182565b9150915080518251146107af5760405163252e18f560e11b815260040160405180910390fd5b6107bb84860186611b17565b92505f805b84515181101561098b575f855f015182815181106107e0576107e0611f14565b6020026020010151905060408160600151165f03610982578351831015610976575f84848151811061081457610814611f14565b6020026020010151905085848151811061083057610830611f14565b60200260200101511561084d576060820180516044179052610970565b5f61085b836040015161111e565b90505f815f01516001600160a01b03168260600151848460800151604051602401610887929190612234565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516108c59190612258565b5f60405180830381855afa9150503d805f81146108fd576040519150601f19603f3d011682016040523d82523d5f602084013e610902565b606091505b5093509050808061092c5750630556f18360e41b61091f846120d0565b6001600160e01b03191614155b1561096d57606084018051604017905280158061094857508251155b156109595760608401805160021790525b82515f0361096d5760608401805160081790525b50505b60408201525b61097f83612282565b92505b506001016107c0565b50815181146109ad5760405163252e18f560e11b815260040160405180910390fd5b61040f84610f33565b5f818060200190518101906109cb91906122b0565b9050610a36815f015182602001518584604001516040516024016109f0929190612234565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a0860151611162565b505050565b6060866001600160a01b03163b5f03610a8b57856040517f5fe9a5df000000000000000000000000000000000000000000000000000000008152600401610a8291906118c3565b60405180910390fd5b5f7fac9650d800000000000000000000000000000000000000000000000000000000610ab6876120d0565b6001600160e01b0319161490505f858015610add5750610add8963477cc53f60e11b611325565b90505f8180610af85750610af88a639061b92360e01b611325565b9050610b0b8a63582de3e760e01b611325565b8015610b8f5750821580610b8f5750808015610b8f575060405163582de3e760e01b81526312d6c5b760e31b60048201526001600160a01b038b169063582de3e790602401602060405180830381865afa158015610b6b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b8f919061237f565b15610bd9578015610bb457610baf8a610baa848c8c8b6113ab565b61143d565b610bd9565b610bd98a89636d6dd54060e01b5f60e01b60405180602001604052805f815250611162565b60608315610c1357610bf9896004808c51610bf4919061239a565b611462565b806020019051810190610c0c91906123ad565b9050610c5e565b60408051600180825281830190925290816020015b6060815260200190600190039081610c2857905050905088815f81518110610c5257610c52611f14565b60200260200101819052505b8115610cbb575f5b8151811015610cb957610c94848c848481518110610c8657610c86611f14565b60200260200101518b6113ab565b828281518110610ca657610ca6611f14565b6020908102919091010152600101610c66565b505b610d643080639f28e99d610cd08f868c6114be565b604051602401610ce09190611cd7565b60408051601f19818403018152918152602080830180516001600160e01b031660e09590951b94909417909352519092507f491fc4f900000000000000000000000000000000000000000000000000000000915f91610d50918b918a910191151582521515602082015260400190565b604051602081830303815290604052611162565b505050509695505050505050565b5f805f805f610d8187876115d3565b90925090508115610e62575f805f610d9a8b8b86610d72565b925092509250610db382865f9182526020526040902090565b6040517f0178b8bf000000000000000000000000000000000000000000000000000000008152600481018290529097506001600160a01b038c1690630178b8bf90602401602060405180830381865afa158015610e12573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e369190612457565b97506001600160a01b038816610e4e57828782610e52565b87878a5b9750975097505050505050610e65565b50505b93509350939050565b5f306001600160a01b03831603610e8757506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685610ed8577f0000000000000000000000000000000000000000000000000000000000000000610eda565b5a5b84604051610ee89190612258565b5f604051808303818686fa925050503d805f8114610f21576040519150601f19603f3d011682016040523d82523d5f602084013e610f26565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff811115610f5057610f50611903565b604051908082528060200260200182016040528015610fad57816020015b610f9a60405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b815260200190600190039081610f6e5790505b5090505f805b83515181101561105e575f845f01518281518110610fd357610fd3611f14565b6020026020010151905060408160600151165f03611055575f610ff9826040015161111e565b90506040518060600160405280825f01516001600160a01b0316815260200182602001518152602001826040015181525085858061103690612282565b96508151811061104857611048611f14565b6020026020010181905250505b50600101610fb3565b508015610a36578082523083602001518360405160240161107f9190612472565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af7600000000000000000000000000000000000000000000000000000000916110f391899101611cd7565b60408051601f1981840301815290829052630556f18360e41b8252610a82959493929160040161250c565b6040805160a0810182525f80825260606020830181905292820183905282820152608081019190915261027761115d836004808651610bf4919061239a565b611600565b5f8061117761117088610e6e565b8888610ea0565b91509150811580156111a15750630556f18360e41b611195826120d0565b6001600160e01b031916145b1561124f575f6111b08261111e565b9050876001600160a01b0316815f01516001600160a01b03160361124d57308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b0319168152602001898152506040516020016110f3919061256f565b505b5f8261125b578461125d565b855b90506001600160e01b031981161561130f57306001600160a01b031681838660405160240161128d929190612234565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516112cb9190612258565b5f60405180830381855afa9150503d805f8114611303576040519150601f19603f3d011682016040523d82523d5f602084013e611308565b606091505b5090935091505b821561131d57815160208301f35b815160208301fd5b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f519050828015611395575060208210155b80156113a057505f81115b979650505050505050565b6060846113f45783836040516024016113c5929190612234565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b179052611434565b838383604051602401611409939291906125eb565b60408051601f198184030181529190526020810180516001600160e01b031663477cc53f60e11b1790525b95945050505050565b61145e82825f60e01b5f60e01b60405180602001604052805f815250611162565b5050565b60608167ffffffffffffffff81111561147d5761147d611903565b6040519080825280601f01601f1916602001820160405280156114a7576020820181803683370190505b5090506114b78484835f8661166b565b9392505050565b60408051808201909152606080825260208201525f835167ffffffffffffffff8111156114ed576114ed611903565b60405190808252806020026020018201604052801561155057816020015b61153d60405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b81526020019060019003908161150b5790505b5090505f5b84518110156115b6575f82828151811061157157611571611f14565b60209081029190910101516001600160a01b0388168152865190915086908390811061159f5761159f611f14565b602090810291909101810151910152600101611555565b506040805180820190915290815260208101929092525092915050565b5f805f6115e085856116a8565b9250905060ff8116156115f857806021858701012092505b509250929050565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091528180602001905181019061163d919061262d565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b61167e8561167983876126d6565b61172c565b61168c8361167983856126d6565b6116a182602085010185602088010183611774565b5050505050565b5f80835183106116cd578360405163ba4adc2360e01b8152600401610a8291906118c3565b8383815181106116df576116df611f14565b016020015160f81c915050818101600101816116ff578351811415611705565b83518110155b15611725578360405163ba4adc2360e01b8152600401610a8291906118c3565b9250929050565b815181111561145e5781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610a82918391600401918252602082015260400190565b5b601f811115611795578151835260209283019290910190601f1901611775565b8015610a365790518251600160209390930360031b9290921b5f190180199091169116179052565b6001600160e01b0319811681146117d2575f80fd5b50565b5f602082840312156117e5575f80fd5b81356114b7816117bd565b5f8083601f840112611800575f80fd5b50813567ffffffffffffffff811115611817575f80fd5b602083019150836020828501011115611725575f80fd5b5f805f8060408587031215611841575f80fd5b843567ffffffffffffffff80821115611858575f80fd5b611864888389016117f0565b9096509450602087013591508082111561187c575f80fd5b50611889878288016117f0565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6114b76020830184611895565b60208152816020820152818360408301375f818301604090810191909152601f909201601f19160101919050565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff8111828210171561193a5761193a611903565b60405290565b6040516080810167ffffffffffffffff8111828210171561193a5761193a611903565b60405160c0810167ffffffffffffffff8111828210171561193a5761193a611903565b604051601f8201601f1916810167ffffffffffffffff811182821017156119af576119af611903565b604052919050565b5f67ffffffffffffffff8211156119d0576119d0611903565b5060051b60200190565b6001600160a01b03811681146117d2575f80fd5b80356119f9816119da565b919050565b5f67ffffffffffffffff821115611a1757611a17611903565b50601f01601f191660200190565b5f611a37611a32846119fe565b611986565b9050828152838383011115611a4a575f80fd5b828260208301375f602084830101529392505050565b5f82601f830112611a6f575f80fd5b6114b783833560208501611a25565b5f82601f830112611a8d575f80fd5b81356020611a9d611a32836119b7565b82815260059290921b84018101918181019086841115611abb575f80fd5b8286015b84811015611b0c57803567ffffffffffffffff811115611add575f80fd5b8701603f81018913611aed575f80fd5b611afe898683013560408401611a25565b845250918301918301611abf565b509695505050505050565b5f6020808385031215611b28575f80fd5b823567ffffffffffffffff80821115611b3f575f80fd5b9084019060408287031215611b52575f80fd5b611b5a611917565b823582811115611b68575f80fd5b8301601f81018813611b78575f80fd5b8035611b86611a32826119b7565b81815260059190911b8201860190868101908a831115611ba4575f80fd5b8784015b83811015611c4c57803587811115611bbe575f80fd5b85016080818e03601f19011215611bd3575f80fd5b611bdb611940565b8a820135611be8816119da565b8152604082013589811115611bfb575f80fd5b611c098f8d83860101611a60565b8c83015250606082013589811115611c1f575f80fd5b611c2d8f8d83860101611a60565b6040830152506080919091013560608201528352918801918801611ba8565b5084525050508284013582811115611c62575f80fd5b611c6e88828601611a7e565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b84811015611cca57601f19868403018952611cb8838351611895565b98840198925090830190600101611c9c565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b82811015611d7557607f198b830301845285516001600160a01b03815116835289810151888b850152611d4089850182611895565b90508682015184820388860152611d578282611895565b928b0151948b01949094525095890195938901939150600101611d0b565b50968a0151898803601f190160408b015296611d918189611c7f565b9b9a5050505050505050505050565b5f8060408385031215611db1575f80fd5b823567ffffffffffffffff80821115611dc8575f80fd5b611dd486838701611a60565b93506020850135915080821115611de9575f80fd5b50611df685828601611a60565b9150509250929050565b80151581146117d2575f80fd5b80356119f981611e00565b5f805f805f8060c08789031215611e2d575f80fd5b611e36876119ee565b9550602087013567ffffffffffffffff80821115611e52575f80fd5b611e5e8a838b01611a60565b96506040890135915080821115611e73575f80fd5b611e7f8a838b01611a60565b9550611e8d60608a01611e0d565b94506080890135915080821115611ea2575f80fd5b611eae8a838b01611a60565b935060a0890135915080821115611ec3575f80fd5b50611ed089828a01611a7e565b9150509295509295509295565b5f8060408385031215611eee575f80fd5b8235611ef981611e00565b91506020830135611f0981611e00565b809150509250929050565b634e487b7160e01b5f52603260045260245ffd5b5f611f35611a32846119fe565b9050828152838383011115611f48575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f830112611f6d575f80fd5b6114b783835160208501611f28565b5f60208284031215611f8c575f80fd5b815167ffffffffffffffff811115611fa2575f80fd5b61041384828501611f5e565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561200357603f19888603018452611ff1858351611895565b94509285019290850190600101611fd5565b5092979650505050505050565b5f82601f83011261201f575f80fd5b8151602061202f611a32836119b7565b82815260059290921b8401810191818101908684111561204d575f80fd5b8286015b84811015611b0c57805167ffffffffffffffff81111561206f575f80fd5b8701603f8101891361207f575f80fd5b612090898683015160408401611f28565b845250918301918301612051565b5f602082840312156120ae575f80fd5b815167ffffffffffffffff8111156120c4575f80fd5b61041384828501612010565b5f815160208301516001600160e01b0319808216935060048310156120ff5780818460040360031b1b83161693505b505050919050565b5f82601f830112612116575f80fd5b81356020612126611a32836119b7565b82815260059290921b84018101918181019086841115612144575f80fd5b8286015b84811015611b0c57803567ffffffffffffffff811115612166575f80fd5b6121748986838b0101611a60565b845250918301918301612148565b5f8060408385031215612193575f80fd5b823567ffffffffffffffff808211156121aa575f80fd5b818501915085601f8301126121bd575f80fd5b813560206121cd611a32836119b7565b82815260059290921b840181019181810190898411156121eb575f80fd5b948201945b8386101561221257853561220381611e00565b825294820194908201906121f0565b96505086013592505080821115612227575f80fd5b50611df685828601612107565b604081525f6122466040830185611895565b82810360208401526114348185611895565b5f82518060208501845e5f920191825250919050565b634e487b7160e01b5f52601160045260245ffd5b5f600182016122935761229361226e565b5060010190565b80516119f9816119da565b80516119f9816117bd565b5f602082840312156122c0575f80fd5b815167ffffffffffffffff808211156122d7575f80fd5b9083019060c082860312156122ea575f80fd5b6122f2611963565b6122fb8361229a565b8152612309602084016122a5565b602082015260408301518281111561231f575f80fd5b61232b87828601611f5e565b60408301525061233d606084016122a5565b606082015261234e608084016122a5565b608082015260a083015182811115612364575f80fd5b61237087828601611f5e565b60a08301525095945050505050565b5f6020828403121561238f575f80fd5b81516114b781611e00565b818103818111156102775761027761226e565b5f60208083850312156123be575f80fd5b825167ffffffffffffffff808211156123d5575f80fd5b818501915085601f8301126123e8575f80fd5b81516123f6611a32826119b7565b81815260059190911b83018401908481019088831115612414575f80fd5b8585015b8381101561244a5780518581111561242e575f80fd5b61243c8b89838a0101611f5e565b845250918601918601612418565b5098975050505050505050565b5f60208284031215612467575f80fd5b81516114b7816119da565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156124fe57603f19898403018552815160606001600160a01b03825116855288820151818a8701526124d082870182611c7f565b915050878201519150848103888601526124ea8183611895565b968901969450505090860190600101612499565b509098975050505050505050565b6001600160a01b038616815260a060208201525f61252d60a0830187611c7f565b828103604084015261253f8187611895565b90506001600160e01b03198516606084015282810360808401526125638185611895565b98975050505050505050565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c060608501526125b560e0850183611895565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c08501526114348282611895565b606081525f6125fd6060830186611895565b828103602084015261260f8186611895565b905082810360408401526126238185611895565b9695505050505050565b5f805f805f60a08688031215612641575f80fd5b855161264c816119da565b602087015190955067ffffffffffffffff80821115612669575f80fd5b61267589838a01612010565b9550604088015191508082111561268a575f80fd5b61269689838a01611f5e565b9450606088015191506126a8826117bd565b6080880151919350808211156126bc575f80fd5b506126c988828901611f5e565b9150509295509295909350565b808201808211156102775761027761226e56fea2646970667358221220ec3f062e1bc91465118a78e0bb24e79b41f62c12e0cb9be937f97691eb5eec9f64736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "1090": [
      {
        "length": 32,
        "start": 3764
      }
    ],
    "38645": [
      {
        "length": 32,
        "start": 482
      },
      {
        "length": 32,
        "start": 1059
      }
    ],
    "38649": [
      {
        "length": 32,
        "start": 313
      },
      {
        "length": 32,
        "start": 1324
      }
    ]
  },
  "inputSourceName": "project/src/resolver/ENSV1Resolver.sol",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "InvalidBatchGatewayResponse()": [
        {
          "details": "Error selector: `0x4a5c31ea`"
        }
      ],
      "OffchainLookup(address,string[],bytes,bytes4,bytes)": [
        {
          "details": "https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`"
        }
      ],
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ],
      "UnreachableName(bytes)": [
        {
          "details": "`name` cannot be resolved.      Error selector: `0x5fe9a5df`",
          "params": {
            "name": "The DNS-encoded ENS name."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "callResolver(address,bytes,bytes,bool,bytes,string[])": {
        "details": "Reverts `UnreachableName` if resolver is not a contract.      This function never returns normally.      The return type is necessary to define the result of the callback.      Call this function externally or with `ccipRead()` to intercept the response.",
        "params": {
          "batchGateways": "The batch gateway URLs.",
          "context": "The context for `IExtendedDNSResolver`.",
          "data": "The calldata for the resolution.",
          "hasContext": "True if `IExtendedDNSResolver` should be considered.",
          "name": "The DNS-encoded ENS name.",
          "resolver": "The resolver to call."
        }
      },
      "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": {
        "details": "Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`."
      },
      "ccipBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \"done\".",
        "params": {
          "extraData": "The contextual data passed from `ccipBatch()`.",
          "response": "The response from the batch gateway."
        },
        "returns": {
          "batch": "The batch where every lookup is \"done\"."
        }
      },
      "ccipReadCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.",
        "params": {
          "extraData": "The contextual data passed from `ccipRead()`.",
          "response": "The response from offchain."
        }
      },
      "resolveBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `callResolver()` from batch calling a resolver.",
        "params": {
          "extraData": "The abi-encoded properties of the call.",
          "response": "The response data from the batch gateway."
        },
        "returns": {
          "_0": "result The response from the resolver."
        }
      },
      "resolveDirectImmediateCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `callResolver()` from direct calling an immediate resolver."
      },
      "supportsFeature(bytes4)": {
        "params": {
          "featureId": "The feature identifier."
        },
        "returns": {
          "_0": "`true` if the feature is supported by the contract."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "stateVariables": {
      "BATCH_GATEWAY_PROVIDER": {
        "details": "Shared batch gateway provider."
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "2003000",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "BATCH_GATEWAY_PROVIDER()": "infinite",
        "REGISTRY_V1()": "infinite",
        "callResolver(address,bytes,bytes,bool,bytes,string[])": "infinite",
        "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": "infinite",
        "ccipBatchCallback(bytes,bytes)": "infinite",
        "ccipReadCallback(bytes,bytes)": "infinite",
        "resolve(bytes,bytes)": "infinite",
        "resolveBatchCallback(bytes,bytes)": "infinite",
        "resolveDirectImmediateCallback(bytes,bytes)": "infinite",
        "supportsFeature(bytes4)": "396",
        "supportsInterface(bytes4)": "531"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"registryV1\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayProvider\",\"name\":\"batchGatewayProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchGatewayResponse\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"UnreachableName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BATCH_GATEWAY_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IGatewayProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REGISTRY_V1\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasContext\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"string[]\",\"name\":\"batchGateways\",\"type\":\"string[]\"}],\"name\":\"callResolver\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"ccipBatch\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipBatchCallback\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipReadCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveBatchCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"resolveDirectImmediateCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"feature\",\"type\":\"bytes4\"}],\"name\":\"supportsFeature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"InvalidBatchGatewayResponse()\":[{\"details\":\"Error selector: `0x4a5c31ea`\"}],\"OffchainLookup(address,string[],bytes,bytes4,bytes)\":[{\"details\":\"https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`\"}],\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}],\"UnreachableName(bytes)\":[{\"details\":\"`name` cannot be resolved.      Error selector: `0x5fe9a5df`\",\"params\":{\"name\":\"The DNS-encoded ENS name.\"}}]},\"kind\":\"dev\",\"methods\":{\"callResolver(address,bytes,bytes,bool,bytes,string[])\":{\"details\":\"Reverts `UnreachableName` if resolver is not a contract.      This function never returns normally.      The return type is necessary to define the result of the callback.      Call this function externally or with `ccipRead()` to intercept the response.\",\"params\":{\"batchGateways\":\"The batch gateway URLs.\",\"context\":\"The context for `IExtendedDNSResolver`.\",\"data\":\"The calldata for the resolution.\",\"hasContext\":\"True if `IExtendedDNSResolver` should be considered.\",\"name\":\"The DNS-encoded ENS name.\",\"resolver\":\"The resolver to call.\"}},\"ccipBatch(((address,bytes,bytes,uint256)[],string[]))\":{\"details\":\"Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`.\"},\"ccipBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\",\"params\":{\"extraData\":\"The contextual data passed from `ccipBatch()`.\",\"response\":\"The response from the batch gateway.\"},\"returns\":{\"batch\":\"The batch where every lookup is \\\"done\\\".\"}},\"ccipReadCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.\",\"params\":{\"extraData\":\"The contextual data passed from `ccipRead()`.\",\"response\":\"The response from offchain.\"}},\"resolveBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `callResolver()` from batch calling a resolver.\",\"params\":{\"extraData\":\"The abi-encoded properties of the call.\",\"response\":\"The response data from the batch gateway.\"},\"returns\":{\"_0\":\"result The response from the resolver.\"}},\"resolveDirectImmediateCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `callResolver()` from direct calling an immediate resolver.\"},\"supportsFeature(bytes4)\":{\"params\":{\"featureId\":\"The feature identifier.\"},\"returns\":{\"_0\":\"`true` if the feature is supported by the contract.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"stateVariables\":{\"BATCH_GATEWAY_PROVIDER\":{\"details\":\"Shared batch gateway provider.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidBatchGatewayResponse()\":[{\"notice\":\"The batch gateway supplied an incorrect number of responses.\"}]},\"kind\":\"user\",\"methods\":{\"callResolver(address,bytes,bytes,bool,bytes,string[])\":{\"notice\":\"Perform forward resolution. Call this function with `ccipRead()` to intercept the response. Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers. - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,   the call is performed directly without the batch gateway. - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,   the call is performed directly without the batch gateway. - Otherwise, the call is performed with the batch gateway.   The batch gateway is only invoked if any call reverts `OffchainLookup`.   If the calldata is `multicall()` it is disassembled, called separately, and reassembled.\"},\"supportsFeature(bytes4)\":{\"notice\":\"Check if a feature is supported.\"}},\"notice\":\"Resolver that performs resolutions using ENSv1. Basically an UniversalResolverV1 (ResolverCaller + RegistryUtils) that implements IExtendedResolver.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/resolver/ENSV1Resolver.sol\":\"ENSV1Resolver\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/ccipRead/CCIPBatcher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IBatchGateway} from \\\"./IBatchGateway.sol\\\";\\nimport {CCIPReader, EIP3668, OffchainLookup} from \\\"./CCIPReader.sol\\\";\\n\\nabstract contract CCIPBatcher is CCIPReader {\\n    /// @notice The batch gateway supplied an incorrect number of responses.\\n    /// @dev Error selector: `0x4a5c31ea`\\n    error InvalidBatchGatewayResponse();\\n\\n    uint256 constant FLAG_OFFCHAIN = 1 << 0; // the lookup reverted `OffchainLookup`\\n    uint256 constant FLAG_CALL_ERROR = 1 << 1; // the initial call or callback reverted\\n    uint256 constant FLAG_BATCH_ERROR = 1 << 2; // `OffchainLookup` failed on the batch gateway\\n    uint256 constant FLAG_EMPTY_RESPONSE = 1 << 3; // the initial call or callback returned `0x`\\n    uint256 constant FLAG_EIP140_BEFORE = 1 << 4; // does not have revert op code\\n    uint256 constant FLAG_EIP140_AFTER = 1 << 5; // has revert op code\\n    uint256 constant FLAG_DONE = 1 << 6; // the lookup has finished processing (private)\\n\\n    uint256 constant FLAGS_ANY_ERROR =\\n        FLAG_CALL_ERROR | FLAG_BATCH_ERROR | FLAG_EMPTY_RESPONSE;\\n    uint256 constant FLAGS_ANY_EIP140 = FLAG_EIP140_BEFORE | FLAG_EIP140_AFTER;\\n\\n    /// @dev An independent `OffchainLookup` session.\\n    struct Lookup {\\n        address target; // contract to call\\n        bytes call; // initial calldata\\n        bytes data; // response or error\\n        uint256 flags; // see: FLAG_*\\n    }\\n\\n    /// @dev A batch gateway session.\\n    struct Batch {\\n        Lookup[] lookups;\\n        string[] gateways;\\n    }\\n\\n    /// @dev Create a batch for a single target with multiple calls.\\n    /// @param target The target contract.\\n    /// @param calls The list of calldata.\\n    /// @param gateways The batch gateway URLs.\\n    function createBatch(\\n        address target,\\n        bytes[] memory calls,\\n        string[] memory gateways\\n    ) internal pure returns (Batch memory) {\\n        Lookup[] memory lookups = new Lookup[](calls.length);\\n        for (uint256 i; i < calls.length; ++i) {\\n            Lookup memory lu = lookups[i];\\n            lu.target = target;\\n            lu.call = calls[i];\\n        }\\n        return Batch(lookups, gateways);\\n    }\\n\\n    /// @dev Use `ccipRead()` to call this function with a batch.\\n    ///      The callback response will be `abi.encode(batch)`.\\n    function ccipBatch(\\n        Batch memory batch\\n    ) external view returns (Batch memory) {\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) != 0) {\\n                continue; // don't call a lookup that's already done\\n            }\\n            if ((lu.flags & FLAGS_ANY_EIP140) == 0) {\\n                uint256 flags = detectEIP140(lu.target)\\n                    ? FLAG_EIP140_AFTER\\n                    : FLAG_EIP140_BEFORE;\\n                for (uint256 j = i; j < batch.lookups.length; ++j) {\\n                    if (batch.lookups[j].target == lu.target) {\\n                        batch.lookups[j].flags |= flags;\\n                    }\\n                }\\n            }\\n            bool unsafe = (lu.flags & FLAG_EIP140_AFTER) == 0;\\n            (bool ok, bytes memory v) = safeCall(!unsafe, lu.target, lu.call);\\n            if (!ok && bytes4(v) == OffchainLookup.selector) {\\n                lu.flags |= FLAG_OFFCHAIN;\\n            } else {\\n                lu.flags |= FLAG_DONE;\\n                if (unsafe && v.length == 0) {\\n                    // unsafe contracts appear the same for throw and unimplemented fallback\\n                    // decision: interpret like an unimplemented function selector response\\n                } else if (!ok) {\\n                    lu.flags |= FLAG_CALL_ERROR;\\n                }\\n                if (v.length == 0) {\\n                    lu.flags |= FLAG_EMPTY_RESPONSE;\\n                }\\n            }\\n            lu.data = v;\\n        }\\n        _revertBatchGateway(batch); // reverts if any offchain\\n        return batch;\\n    }\\n\\n    /// @dev Check if the batch is \\\"done\\\".  If not, revert `OffchainLookup` for batch gateway.\\n    function _revertBatchGateway(Batch memory batch) internal view {\\n        IBatchGateway.Request[] memory requests = new IBatchGateway.Request[](\\n            batch.lookups.length\\n        );\\n        uint256 count;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                requests[count++] = IBatchGateway.Request(\\n                    p.sender,\\n                    p.urls,\\n                    p.callData\\n                );\\n            }\\n        }\\n        if (count > 0) {\\n            assembly {\\n                mstore(requests, count) // truncate to number of offchain requests\\n            }\\n            revert OffchainLookup(\\n                address(this),\\n                batch.gateways,\\n                abi.encodeCall(IBatchGateway.query, (requests)),\\n                this.ccipBatchCallback.selector,\\n                abi.encode(batch)\\n            );\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipBatch()`.\\n    ///      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\\n    /// @param response The response from the batch gateway.\\n    /// @param extraData The contextual data passed from `ccipBatch()`.\\n    /// @return batch The batch where every lookup is \\\"done\\\".\\n    function ccipBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (Batch memory batch) {\\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\\n            response,\\n            (bool[], bytes[])\\n        );\\n        if (failures.length != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        batch = abi.decode(extraData, (Batch));\\n        uint256 expected;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                if (expected < responses.length) {\\n                    bytes memory v = responses[expected];\\n                    if (failures[expected]) {\\n                        lu.flags |= FLAG_DONE | FLAG_BATCH_ERROR;\\n                    } else {\\n                        EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                        bool ok;\\n                        // assumption: unsafe contracts don't revert OffchainLookup()\\n                        (ok, v) = p.sender.staticcall(\\n                            abi.encodeWithSelector(\\n                                p.callbackFunction,\\n                                v,\\n                                p.extraData\\n                            )\\n                        );\\n                        if (ok || bytes4(v) != OffchainLookup.selector) {\\n                            lu.flags |= FLAG_DONE;\\n                            // decision: promote empty response from the callback => call error\\n                            // ie. the initial function was implemented but the callback was not\\n                            // this can be detected via FLAG_OFFCHAIN\\n                            if (!ok || v.length == 0) {\\n                                lu.flags |= FLAG_CALL_ERROR;\\n                            }\\n                            if (v.length == 0) {\\n                                lu.flags |= FLAG_EMPTY_RESPONSE;\\n                            }\\n                        }\\n                    }\\n                    lu.data = v;\\n                }\\n                ++expected;\\n            }\\n        }\\n        if (expected != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        _revertBatchGateway(batch);\\n    }\\n}\\n\",\"keccak256\":\"0x8315d7930568e488eac59ac205e4ed20a3ebf19445358b4218c62a49f2e5ebf6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/CCIPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @author Modified from https://github.com/unruggable-labs/CCIPReader.sol/blob/341576fe7ff2b6e0c93fc08f37740cf6439f5873/contracts/CCIPReader.sol\\n\\n/// MIT License\\n/// Portions Copyright (c) 2025 Unruggable\\n/// Portions Copyright (c) 2025 ENS Labs Ltd\\n\\n/// @dev Instructions:\\n/// 1. inherit this contract\\n/// 2. call `ccipRead()` similar to `staticcall()`\\n/// 3. do not put logic after this invocation\\n/// 4. implement all response logic in callback\\n/// 5. ensure that return type of calling function == callback function\\n\\nimport {EIP3668, OffchainLookup} from \\\"./EIP3668.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\n\\ncontract CCIPReader {\\n    /// @dev Default unsafe call gas (sufficient for legacy ENS resolver profiles).\\n    uint256 constant DEFAULT_UNSAFE_CALL_GAS = 50000;\\n\\n    /// @dev Special-purpose value for identity callback: `f(x) = x`.\\n    bytes4 constant IDENTITY_FUNCTION = bytes4(0);\\n\\n    /// @dev The gas limit for calling functions on unsafe contracts.\\n    uint256 immutable unsafeCallGas;\\n\\n    constructor(uint256 _unsafeCallGas) {\\n        unsafeCallGas = _unsafeCallGas;\\n    }\\n\\n    /// @dev A recursive CCIP-Read session.\\n    struct Context {\\n        address target;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n        bytes4 successCallbackFunction;\\n        bytes4 failureCallbackFunction;\\n        bytes myExtraData;\\n    }\\n\\n    /// @dev Same as `ccipRead()` but the callback function is the identity.\\n    function ccipRead(address target, bytes memory call) internal view {\\n        ccipRead(target, call, IDENTITY_FUNCTION, IDENTITY_FUNCTION, \\\"\\\");\\n    }\\n\\n    /// @dev Performs a CCIP-Read and handles internal recursion.\\n    ///      Reverts `OffchainLookup` if necessary.\\n    ///      Use `IDENTITY_FUNCTION` as the callback function selector for return/revert behavior.\\n    /// @param target The contract address.\\n    /// @param call The calldata to `staticcall()` on `target`.\\n    /// @param successCallbackFunction The function selector of callback on success.\\n    /// @param failureCallbackFunction The function selector of callback on failure.\\n    /// @param extraData The contextual data relayed to callback function.\\n    function ccipRead(\\n        address target,\\n        bytes memory call,\\n        bytes4 successCallbackFunction,\\n        bytes4 failureCallbackFunction,\\n        bytes memory extraData\\n    ) internal view {\\n        // We call the intended function that **could** revert with an `OffchainLookup`\\n        // We destructure the response into an execution status bool and our return bytes\\n        (bool ok, bytes memory v) = safeCall(\\n            detectEIP140(target),\\n            target,\\n            call\\n        );\\n        // IF the function reverted with an `OffchainLookup`\\n        if (!ok && bytes4(v) == OffchainLookup.selector) {\\n            // We decode the response error into a tuple\\n            // tuples allow flexibility noting stack too deep constraints\\n            EIP3668.Params memory p = decodeOffchainLookup(v);\\n            if (p.sender == target) {\\n                // We then wrap the error data in an `OffchainLookup` sent/'owned' by this contract\\n                revert OffchainLookup(\\n                    address(this),\\n                    p.urls,\\n                    p.callData,\\n                    this.ccipReadCallback.selector,\\n                    abi.encode(\\n                        Context(\\n                            target,\\n                            p.callbackFunction,\\n                            p.extraData,\\n                            successCallbackFunction,\\n                            failureCallbackFunction,\\n                            extraData\\n                        )\\n                    )\\n                );\\n            }\\n        }\\n        // IF we have gotten here, the 'real' target does not revert with an `OffchainLookup` error\\n        // figure out what callback to call\\n        bytes4 callbackFunction = ok\\n            ? successCallbackFunction\\n            : failureCallbackFunction;\\n        if (callbackFunction != IDENTITY_FUNCTION) {\\n            // The exit point of this architecture is OUR callback in the 'real'\\n            // We pass through the response to that callback\\n            (ok, v) = address(this).staticcall(\\n                abi.encodeWithSelector(callbackFunction, v, extraData)\\n            );\\n        }\\n        // OR the call to the 'real' target reverts with a different error selector\\n        // OR the call to OUR callback reverts with ANY error selector\\n        if (ok) {\\n            assembly {\\n                return(add(v, 32), mload(v))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(v, 32), mload(v))\\n            }\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipRead()`.\\n    /// @param response The response from offchain.\\n    /// @param extraData The contextual data passed from `ccipRead()`.\\n    /// @dev The return type of this function is polymorphic depending on the caller.\\n    function ccipReadCallback(\\n        bytes memory response,\\n        bytes memory extraData\\n    ) external view {\\n        Context memory ctx = abi.decode(extraData, (Context));\\n        // Since the callback can revert too (but has the same return structure)\\n        // We can reuse the calling infrastructure to call the callback\\n        ccipRead(\\n            ctx.target,\\n            abi.encodeWithSelector(\\n                ctx.callbackFunction,\\n                response,\\n                ctx.extraData\\n            ),\\n            ctx.successCallbackFunction,\\n            ctx.failureCallbackFunction,\\n            ctx.myExtraData\\n        );\\n    }\\n\\n    /// @dev Decode `OffchainLookup` error data into a struct.\\n    /// @param v The error data of the revert.\\n    /// @return p The decoded `OffchainLookup` params.\\n    function decodeOffchainLookup(\\n        bytes memory v\\n    ) internal pure returns (EIP3668.Params memory p) {\\n        p = EIP3668.decode(BytesUtils.substring(v, 4, v.length - 4));\\n    }\\n\\n    /// @dev Determine if `target` uses `revert()` instead of `invalid()`.\\n    //       Assumption: only newer contracts revert `OffchainLookup`.\\n    /// @param target The contract to test.\\n    /// @return safe True if safe to call.\\n    function detectEIP140(address target) internal view returns (bool safe) {\\n        if (target == address(this)) return true;\\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md\\n        assembly {\\n            let G := 5000\\n            let g := gas()\\n            pop(staticcall(G, target, 0, 0, 0, 0))\\n            safe := lt(sub(g, gas()), G)\\n        }\\n    }\\n\\n    /// @dev Same as `staticcall()` but prevents OOG when not `safe`.\\n    function safeCall(\\n        bool safe,\\n        address target,\\n        bytes memory call\\n    ) internal view returns (bool ok, bytes memory v) {\\n        (ok, v) = target.staticcall{gas: safe ? gasleft() : unsafeCallGas}(\\n            call\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xa6f483e89e779385c2b7ea6376d92cd3c05c98f91d1a3c7c43dc7422fe6b014f\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/EIP3668.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev https://eips.ethereum.org/EIPS/eip-3668\\n/// Error selector: `0x556f1830`\\nerror OffchainLookup(\\n    address sender,\\n    string[] urls,\\n    bytes callData,\\n    bytes4 callbackFunction,\\n    bytes extraData\\n);\\n\\n/// @dev Simple library for decoding `OffchainLookup` error data.\\n/// Avoids \\\"stack too deep\\\" issues as the natural decoding consumes 5 variables.\\nlibrary EIP3668 {\\n    /// @dev Struct with members matching `OffchainLookup`.\\n    struct Params {\\n        address sender;\\n        string[] urls;\\n        bytes callData;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n    }\\n\\n    /// @dev Decode an `OffchainLookup` into a struct from the data after the error selector.\\n    function decode(bytes memory v) internal pure returns (Params memory p) {\\n        (p.sender, p.urls, p.callData, p.callbackFunction, p.extraData) = abi\\n            .decode(v, (address, string[], bytes, bytes4, bytes));\\n    }\\n}\\n\",\"keccak256\":\"0x14619de0f3d9f085e6209767b35c2888b8d2af6d787af535f30db7b51e843bf8\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IBatchGateway.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for Batch Gateway Offchain Lookup Protocol.\\n///         https://docs.ens.domains/ensip/21/\\n/// @dev Interface selector: `0xa780bab6`\\ninterface IBatchGateway {\\n    /// @notice An HTTP error occurred.\\n    /// @dev Error selector: `0x01800152`\\n    error HttpError(uint16 status, string message);\\n\\n    /// @dev Information extracted from an `OffchainLookup` revert.\\n    struct Request {\\n        address sender;\\n        string[] urls;\\n        bytes data;\\n    }\\n\\n    /// @notice Perform multiple `OffchainLookup` in parallel.\\n    ///         Callers should enable EIP-3668.\\n    /// @param requests The array of requests to lookup in parallel.\\n    /// @return failures The failure status of the corresponding request.\\n    /// @return responses The response or error data of the corresponding request.\\n    function query(\\n        Request[] memory requests\\n    ) external view returns (bool[] memory failures, bytes[] memory responses);\\n}\\n\",\"keccak256\":\"0xfd7f0c7bdc29fc732ec54da2ebaea241873e55082e484729901811bc9374d6f6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IGatewayProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for shared gateway URLs.\\n/// @dev Interface selector: `0x093a86d3`\\ninterface IGatewayProvider {\\n    /// @notice Get the gateways.\\n    /// @return The gateway URLs.\\n    function gateways() external view returns (string[] memory);\\n}\\n\",\"keccak256\":\"0x7c169843cfb65657a88fb4d5f7ec44612994d7d87cb7b1a67cbfdb18758823e0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8e208b44d5dbf22552fe72d79b45c640855b84fbc9ee21f4c3bb4bfe81cbe8db\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/IMulticallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n\\n    function multicallWithNodeCheck(\\n        bytes32,\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x0334202e20bb11995997083d05963f5e8e7ed6194cba494e7f9371ab7bf4e2c3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/ResolverFeatures.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary ResolverFeatures {\\n    /// @notice Implements `resolve(multicall([...]))`.\\n    /// @dev Feature: `0x96b62db8`\\n    bytes4 constant RESOLVE_MULTICALL =\\n        bytes4(keccak256(\\\"eth.ens.resolver.extended.multicall\\\"));\\n\\n    /// @notice Returns the same records independent of name or node.\\n    /// @dev Feature: `0x86fb8da8`\\n    bytes4 constant SINGULAR = bytes4(keccak256(\\\"eth.ens.resolver.singular\\\"));\\n}\\n\",\"keccak256\":\"0x87d131fcbdd7951a17b0a94f7f02470ec3f62c6004cf91c2d2acc54098373be6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedDNSResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedDNSResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data,\\n        bytes memory context\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x541f8799c34ff9e7035d09f06ae0f0f8a16b6065e9b60a15670b957321630f72\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/RegistryUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ENS} from \\\"../registry/ENS.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nlibrary RegistryUtils {\\n    /// @notice Find the resolver for `name[offset:]`.\\n    /// @dev Reverts `DNSDecodingFailed`.\\n    /// @param registry The ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    /// @return resolver The resolver or `address(0)` if not found.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return resolverOffset The offset into `name` corresponding to `resolver`.\\n    function findResolver(\\n        ENS registry,\\n        bytes memory name,\\n        uint256 offset\\n    )\\n        internal\\n        view\\n        returns (address resolver, bytes32 node, uint256 resolverOffset)\\n    {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (\\n                address parentResolver,\\n                bytes32 parentNode,\\n                uint256 parentOffset\\n            ) = findResolver(registry, name, next);\\n            node = NameCoder.namehash(parentNode, labelHash);\\n            resolver = registry.resolver(node);\\n            return\\n                resolver != address(0)\\n                    ? (resolver, node, offset)\\n                    : (parentResolver, node, parentOffset);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x050dd0e2823fc92df8a29f4516c5af22dcd42cd7c7fbd88d852fb330939285c7\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/ResolverCaller.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ERC165Checker\\n} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {CCIPBatcher} from \\\"../ccipRead/CCIPBatcher.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\nimport {IERC7996} from \\\"../utils/IERC7996.sol\\\";\\nimport {ResolverFeatures} from \\\"../resolvers/ResolverFeatures.sol\\\";\\n\\n// resolver profiles\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {\\n    IExtendedDNSResolver\\n} from \\\"../resolvers/profiles/IExtendedDNSResolver.sol\\\";\\nimport {IMulticallable} from \\\"../resolvers/IMulticallable.sol\\\";\\n\\nabstract contract ResolverCaller is CCIPBatcher {\\n    /// @dev `name` cannot be resolved.\\n    ///      Error selector: `0x5fe9a5df`\\n    /// @param name The DNS-encoded ENS name.\\n    error UnreachableName(bytes name);\\n\\n    /// @notice Perform forward resolution.\\n    ///\\n    /// Call this function with `ccipRead()` to intercept the response.\\n    /// Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers.\\n    ///\\n    /// - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,\\n    ///   the call is performed directly without the batch gateway.\\n    /// - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,\\n    ///   the call is performed directly without the batch gateway.\\n    /// - Otherwise, the call is performed with the batch gateway.\\n    ///   The batch gateway is only invoked if any call reverts `OffchainLookup`.\\n    ///   If the calldata is `multicall()` it is disassembled, called separately, and reassembled.\\n    ///\\n    /// @dev Reverts `UnreachableName` if resolver is not a contract.\\n\\t///      This function never returns normally.\\n\\t///      The return type is necessary to define the result of the callback.\\n\\t///      Call this function externally or with `ccipRead()` to intercept the response.\\n    /// @param resolver The resolver to call.\\n    /// @param name The DNS-encoded ENS name.\\n    /// @param data The calldata for the resolution.\\n    /// @param hasContext True if `IExtendedDNSResolver` should be considered.\\n    /// @param context The context for `IExtendedDNSResolver`.\\n    /// @param batchGateways The batch gateway URLs.\\n    function callResolver(\\n        address resolver,\\n        bytes memory name,\\n        bytes memory data,\\n        bool hasContext,\\n        bytes memory context,\\n        string[] memory batchGateways\\n    ) public view returns (bytes memory) {\\n        if (resolver.code.length == 0) {\\n            revert UnreachableName(name);\\n        }\\n        bool multi = bytes4(data) == IMulticallable.multicall.selector;\\n        bool extendedDNS = hasContext &&\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IExtendedDNSResolver).interfaceId\\n            );\\n        bool extended = extendedDNS ||\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IExtendedResolver).interfaceId\\n            );\\n        if (\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IERC7996).interfaceId\\n            ) &&\\n            (!multi ||\\n                (extended &&\\n                    IERC7996(resolver).supportsFeature(\\n                        ResolverFeatures.RESOLVE_MULTICALL\\n                    )))\\n        ) {\\n            if (extended) {\\n                // resolve() has the same return signature as callResolver()\\n                ccipRead(\\n                    resolver,\\n                    _makeExtendedCall(extendedDNS, name, data, context)\\n                );\\n            } else {\\n                ccipRead(\\n                    resolver,\\n                    data,\\n                    this.resolveDirectImmediateCallback.selector, // ==> step 2\\n                    IDENTITY_FUNCTION,\\n                    \\\"\\\"\\n                );\\n            }\\n        }\\n        bytes[] memory calls;\\n        if (multi) {\\n            calls = abi.decode(\\n                BytesUtils.substring(data, 4, data.length - 4),\\n                (bytes[])\\n            );\\n        } else {\\n            calls = new bytes[](1);\\n            calls[0] = data;\\n        }\\n        if (extended) {\\n            for (uint256 i; i < calls.length; ++i) {\\n                calls[i] = _makeExtendedCall(\\n                    extendedDNS,\\n                    name,\\n                    calls[i],\\n                    context\\n                );\\n            }\\n        }\\n        ccipRead(\\n            address(this),\\n            abi.encodeCall(\\n                this.ccipBatch,\\n                (createBatch(resolver, calls, batchGateways))\\n            ),\\n            this.resolveBatchCallback.selector, // ==> step 2\\n            IDENTITY_FUNCTION,\\n            abi.encode(multi, extended)\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `callResolver()` from direct calling an immediate resolver.\\n    function resolveDirectImmediateCallback(\\n        bytes calldata response,\\n        bytes calldata\\n    ) external pure returns (bytes calldata) {\\n        return response; // the calldata was direct, so wrap it\\n    }\\n\\n    /// @dev CCIP-Read callback for `callResolver()` from batch calling a resolver.\\n    /// @param response The response data from the batch gateway.\\n    /// @param extraData The abi-encoded properties of the call.\\n    /// @return result The response from the resolver.\\n    function resolveBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external pure returns (bytes memory) {\\n        Lookup[] memory lookups = abi.decode(response, (Batch)).lookups;\\n        (bool multi, bool extended) = abi.decode(extraData, (bool, bool));\\n        if (multi) {\\n            bytes[] memory m = new bytes[](lookups.length);\\n            for (uint256 i; i < lookups.length; ++i) {\\n                Lookup memory lu = lookups[i];\\n                bytes memory v = lu.data;\\n                if (extended && (lu.flags & FLAGS_ANY_ERROR) == 0) {\\n                    v = abi.decode(v, (bytes)); // unwrap resolve()\\n                }\\n                m[i] = v;\\n            }\\n            return abi.encode(m);\\n        } else {\\n            Lookup memory lu = lookups[0];\\n            bytes memory v = lu.data;\\n            if ((lu.flags & FLAGS_ANY_ERROR) != 0) {\\n                assembly {\\n                    revert(add(v, 32), mload(v))\\n                }\\n            }\\n            if (extended) {\\n                v = abi.decode(v, (bytes)); // unwrap resolve()\\n            }\\n            return v;\\n        }\\n    }\\n\\n    /// @dev Create extended resolver calldata.\\n    function _makeExtendedCall(\\n        bool extendedDNS,\\n        bytes memory name,\\n        bytes memory call,\\n        bytes memory context\\n    ) internal pure returns (bytes memory) {\\n        return\\n            extendedDNS\\n                ? abi.encodeCall(\\n                    IExtendedDNSResolver.resolve,\\n                    (name, call, context)\\n                )\\n                : abi.encodeCall(IExtendedResolver.resolve, (name, call));\\n    }\\n}\\n\",\"keccak256\":\"0x38307321fb62ccee51f3ea2241c018aba1822e758c05ae7e228a760949c26848\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/IERC7996.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for expressing contract features not visible from the ABI.\\n/// @dev Interface selector: `0x582de3e7`\\ninterface IERC7996 {\\n    /// @notice Check if a feature is supported.\\n    /// @param featureId The feature identifier.\\n    /// @return `true` if the feature is supported by the contract.\\n    function supportsFeature(bytes4 featureId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf499a48e4e879ec7775f375d2cb5af047720ab6ae4b6f89a40a578c4e0f51631\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5a08ad61f4e82b8a3323562661a86fb10b10190848073fdc13d4ac43710ffba5\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"project/src/resolver/ENSV1Resolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {CCIPReader} from \\\"@ens/contracts/ccipRead/CCIPReader.sol\\\";\\nimport {IGatewayProvider} from \\\"@ens/contracts/ccipRead/IGatewayProvider.sol\\\";\\nimport {IExtendedResolver} from \\\"@ens/contracts/resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {ResolverFeatures} from \\\"@ens/contracts/resolvers/ResolverFeatures.sol\\\";\\nimport {RegistryUtils, ENS} from \\\"@ens/contracts/universalResolver/RegistryUtils.sol\\\";\\nimport {ResolverCaller} from \\\"@ens/contracts/universalResolver/ResolverCaller.sol\\\";\\nimport {IERC7996} from \\\"@ens/contracts/utils/IERC7996.sol\\\";\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/// @notice Resolver that performs resolutions using ENSv1.\\n///\\n/// Basically an UniversalResolverV1 (ResolverCaller + RegistryUtils) that implements IExtendedResolver.\\n///\\ncontract ENSV1Resolver is IExtendedResolver, IERC7996, ResolverCaller, ERC165 {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    ENS public immutable REGISTRY_V1;\\n\\n    /// @dev Shared batch gateway provider.\\n    IGatewayProvider public immutable BATCH_GATEWAY_PROVIDER;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        ENS registryV1,\\n        IGatewayProvider batchGatewayProvider\\n    ) CCIPReader(DEFAULT_UNSAFE_CALL_GAS) {\\n        REGISTRY_V1 = registryV1;\\n        BATCH_GATEWAY_PROVIDER = batchGatewayProvider;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165) returns (bool) {\\n        return\\n            type(IExtendedResolver).interfaceId == interfaceId ||\\n            type(IERC7996).interfaceId == interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc IERC7996\\n    function supportsFeature(bytes4 feature) external pure returns (bool) {\\n        return ResolverFeatures.RESOLVE_MULTICALL == feature;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory) {\\n        (address resolver, , ) = RegistryUtils.findResolver(REGISTRY_V1, name, 0);\\n        callResolver(resolver, name, data, false, \\\"\\\", BATCH_GATEWAY_PROVIDER.gateways());\\n    }\\n}\\n\",\"keccak256\":\"0x99635253470a3c25c2e0e3bf2d6cf4f133843c42b30417847162a5f6484ae3a0\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "InvalidBatchGatewayResponse()": [
        {
          "notice": "The batch gateway supplied an incorrect number of responses."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "callResolver(address,bytes,bytes,bool,bytes,string[])": {
        "notice": "Perform forward resolution. Call this function with `ccipRead()` to intercept the response. Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers. - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,   the call is performed directly without the batch gateway. - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,   the call is performed directly without the batch gateway. - Otherwise, the call is performed with the batch gateway.   The batch gateway is only invoked if any call reverts `OffchainLookup`.   If the calldata is `multicall()` it is disassembled, called separately, and reassembled."
      },
      "supportsFeature(bytes4)": {
        "notice": "Check if a feature is supported."
      }
    },
    "notice": "Resolver that performs resolutions using ENSv1. Basically an UniversalResolverV1 (ResolverCaller + RegistryUtils) that implements IExtendedResolver.",
    "version": 1
  },
  "argsData": "0x000000000000000000000000cf7ed3acca5a467e9e704c703e8d87f634fb0fc9000000000000000000000000dc64a140aa3e981100a9beca4e685f962f0cf6c9",
  "transaction": {
    "hash": "0xf379704c8218e7949188c183948958730a39c134a458ddb138bb7499090c7220",
    "nonce": "0x5",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x8913b773211d1ee2d83c11f6267d54254a05d4d194b23ab1d63de9b00134e11d",
    "blockNumber": "0x6",
    "transactionIndex": "0x0"
  }
}
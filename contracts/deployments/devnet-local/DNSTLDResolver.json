{
  "address": "0x09635f643e140090a9a8dcd712ed6285858cebef",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ENS",
          "name": "ensRegistryV1",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dnsTLDResolverV1",
          "type": "address"
        },
        {
          "internalType": "contract IRegistry",
          "name": "rootRegistry",
          "type": "address"
        },
        {
          "internalType": "contract DNSSEC",
          "name": "dnssecOracle",
          "type": "address"
        },
        {
          "internalType": "contract IGatewayProvider",
          "name": "oracleGatewayProvider",
          "type": "address"
        },
        {
          "internalType": "contract IGatewayProvider",
          "name": "batchGatewayProvider",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ens",
          "type": "string"
        }
      ],
      "name": "DNSEncodingFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBatchGatewayResponse",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTXT",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "string[]",
          "name": "urls",
          "type": "string[]"
        },
        {
          "internalType": "bytes",
          "name": "callData",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "callbackFunction",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "OffchainLookup",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "UnreachableName",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "verifier",
          "type": "address"
        }
      ],
      "name": "VerifierChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BATCH_GATEWAY_PROVIDER",
      "outputs": [
        {
          "internalType": "contract IGatewayProvider",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DNSSEC_ORACLE",
      "outputs": [
        {
          "internalType": "contract DNSSEC",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DNS_TLD_RESOLVER_V1",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ENS_REGISTRY_V1",
      "outputs": [
        {
          "internalType": "contract ENS",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ORACLE_GATEWAY_PROVIDER",
      "outputs": [
        {
          "internalType": "contract IGatewayProvider",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_REGISTRY",
      "outputs": [
        {
          "internalType": "contract IRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "hasContext",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "string[]",
          "name": "batchGateways",
          "type": "string[]"
        }
      ],
      "name": "callResolver",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "name": "ccipBatch",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipBatchCallback",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipReadCallback",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "getDNSSECRecords",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "getDNSSECRecordsCallback",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "txts",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "getResolver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "getResolverCallback",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "txt",
          "type": "bytes"
        }
      ],
      "name": "parseDNSSECRecord",
      "outputs": [
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "requiresOffchain",
      "outputs": [
        {
          "internalType": "bool",
          "name": "offchain",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveBatchCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "resolveDirectImmediateCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveOracleCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "feature",
          "type": "bytes4"
        }
      ],
      "name": "supportsFeature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "verifierMetadata",
      "outputs": [
        {
          "internalType": "address",
          "name": "verifier",
          "type": "address"
        },
        {
          "internalType": "string[]",
          "name": "gateways",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "DNSTLDResolver",
  "sourceName": "src/dns/DNSTLDResolver.sol",
  "bytecode": "0x610160604052348015610010575f80fd5b5060405161447438038061447483398101604081905261002f9161007c565b61c3506080526001600160a01b0395861660a05293851660c05291841660e05283166101005282166101205216610140526100ff565b6001600160a01b0381168114610079575f80fd5b50565b5f805f805f8060c08789031215610091575f80fd5b865161009c81610065565b60208801519096506100ad81610065565b60408801519095506100be81610065565b60608801519094506100cf81610065565b60808801519093506100e081610065565b60a08801519092506100f181610065565b809150509295509295509295565b60805160a05160c05160e0516101005161012051610140516142d06101a45f395f818161022c01528181610a93015261132401525f81816103b001528181610b0e01528181610cc10152818161140801526114f101525f818161044601528181610535015281816113e50152611c9401525f818161038901526121e701525f81816102fb0152611c2c01525f818161028f0152611bfd01525f611dd901526142d05ff3fe608060405234801561000f575f80fd5b5060043610610184575f3560e01c80639cf82aa5116100dd578063e9187d0111610088578063ef46c0b811610063578063ef46c0b814610419578063f394443a1461042e578063f8c8761314610441575f80fd5b8063e9187d01146103d2578063ed57d294146103e5578063eea330f914610406575f80fd5b8063c4314175116100b8578063c431417514610363578063c92cc49a14610384578063d93fea04146103ab575f80fd5b80639cf82aa51461031d5780639f28e99d14610330578063b536af7614610350575f80fd5b80636ccb86601161013d578063833d6ba711610118578063833d6ba7146102b15780639061b923146102e35780639ad59435146102f6575f80fd5b80636ccb8660146102275780636d6dd540146102665780637f4c88f61461028a575f80fd5b806329476d8a1161016d57806329476d8a146101d0578063491fc4f9146101e3578063582de3e714610203575f80fd5b806301ffc9a71461018857806319b4949c146101b0575b5f80fd5b61019b610196366004613012565b610468565b60405190151581526020015b60405180910390f35b6101c36101be36600461306b565b610521565b6040516101a79190613100565b61019b6101de366004613162565b61074a565b6101f66101f136600461306b565b6107a4565b6040516101a791906131a1565b61019b610211366004613012565b6001600160e01b0319166312d6c5b760e31b1490565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101a7565b61027c61027436600461306b565b509192909150565b6040516101a79291906131db565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6102c46102bf36600461306b565b610942565b604080516001600160a01b0390931683529015156020830152016101a7565b6101f66102f136600461306b565b610996565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6101c361032b366004613162565b610c39565b61034361033e3660046133fd565b610dc1565b6040516101a791906135bd565b61034361035e36600461306b565b610f82565b610376610371366004613686565b6111d1565b6040516101a79291906136b8565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6101f66103e036600461306b565b6112ca565b6103f86103f3366004613162565b61138a565b6040516101a79291906136d9565b6102c4610414366004613162565b611492565b61042c6104273660046136fa565b6115f1565b005b6101f661043c366004613772565b611676565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b5f639061b92360e01b6001600160e01b0319831614806104b157507fc7e45d73000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b806104e557507fed57d294000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b80610500575063582de3e760e01b6001600160e01b03198316145b8061051b57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60605f61053085870187613837565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bdf95fef836040518263ffffffff1660e01b815260040161057f9190613936565b5f60405180830381865afa158015610599573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526105c09190810190613a0f565b5090505f806105cf835f611986565b90505b8051516020820151101561063e5761061f8188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506119e192505050565b156106305761062d82613a7a565b91505b61063981611a26565b6105d2565b508067ffffffffffffffff811115610658576106586131ee565b60405190808252806020026020018201604052801561068b57816020015b60608152602001906001900390816106765790505b5093505f90505f61069c835f611986565b90505b8051516020820151101561073e576106ec8188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506119e192505050565b1561073057610707815f01518260a001518360c00151611b0b565b858361071281613a7a565b94508151811061072457610724613a92565b60200260200101819052505b61073981611a26565b61069f565b50505050949350505050565b5f806001600160a01b031661079384848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b6001600160a01b0316149392505050565b60605f6107b3858701876133fd565b5190505f806107c485870187613aa6565b9150915081156108d1575f835167ffffffffffffffff8111156107e9576107e96131ee565b60405190808252806020026020018201604052801561081c57816020015b60608152602001906001900390816108075790505b5090505f5b84518110156108a5575f85828151811061083d5761083d613a92565b602002602001015190505f8160400151905084801561086157506060820151600e16155b1561087d578080602001905181019061087a9190613ad2565b90505b8084848151811061089057610890613a92565b60209081029190910101525050600101610821565b50806040516020016108b79190613100565b60405160208183030381529060405294505050505061093a565b5f835f815181106108e4576108e4613a92565b60209081029190910101516040810151606082015191925090600e161561090d57805160208201fd5b821561092a57808060200190518101906109279190613ad2565b90505b945061093a9350505050565b5050505b949350505050565b5f805f61098785858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b92508a9150611c7f9050565b50976001975095505050505050565b60605f6109d786868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b90506001600160a01b03811615610b0b57610b038187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516020601f8b0181900481028201810190925289815292508991508890819084018382808284375f9201829052506040805160208101825282815281517f093a86d3000000000000000000000000000000000000000000000000000000008152915192955093506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063093a86d391600480830192879291908290030181865afa158015610adc573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261043c9190810190613b92565b91505061093a565b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610b67573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610b8e9190810190613b92565b87876010604051602401610ba493929190613bc4565b60408051601f19818403018152918152602080830180516001600160e01b03166331b137b960e01b17905290517fe9187d010000000000000000000000000000000000000000000000000000000091610c05918c918c918c918c9101613beb565b60408051601f1981840301815290829052630556f18360e41b8252610c309594939291600401613c11565b60405180910390fd5b60605f610c7a84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b90506001600160a01b03811615610cbe57604080515f8082526020820190925290610cb5565b6060815260200190600190039081610ca05790505b5091505061051b565b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610d1a573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610d419190810190613b92565b85856010604051602401610d5793929190613bc4565b60408051601f198184030181529181526020820180516001600160e01b03166331b137b960e01b17905251630556f18360e41b8152610c30939291907f19b4949c000000000000000000000000000000000000000000000000000000009089908990600401613c74565b60408051808201909152606080825260208201525f5b825151811015610f74575f835f01518281518110610df757610df7613a92565b6020026020010151905060408160600151165f14610e155750610f6c565b60608101516030165f03610ebf575f610e30825f0151611d93565b610e3b576010610e3e565b60205b9050825b855151811015610ebc57825f01516001600160a01b0316865f01518281518110610e6e57610e6e613a92565b60200260200101515f01516001600160a01b031603610eb45781865f01518281518110610e9d57610e9d613a92565b602002602001015160600181815117915081815250505b600101610e42565b50505b5f60208260600151165f1490505f80610ee18315855f01518660200151611dc5565b9150915081158015610f0b5750630556f18360e41b610eff82613ccc565b6001600160e01b031916145b15610f20576060840180516001179052610f60565b6060840180516040179052828015610f3757508051155b610f4c5781610f4c5760608401805160021790525b80515f03610f605760608401805160081790525b60409093019290925250505b600101610dd7565b50610f7e82611e58565b5090565b60408051808201909152606080825260208201525f80610fa486880188613d7e565b915091508051825114610fca5760405163252e18f560e11b815260040160405180910390fd5b610fd6848601866133fd565b92505f805b8451518110156111a6575f855f01518281518110610ffb57610ffb613a92565b6020026020010151905060408160600151165f0361119d578351831015611191575f84848151811061102f5761102f613a92565b6020026020010151905085848151811061104b5761104b613a92565b60200260200101511561106857606082018051604417905261118b565b5f6110768360400151612018565b90505f815f01516001600160a01b031682606001518484608001516040516024016110a2929190613e30565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516110e09190613e54565b5f60405180830381855afa9150503d805f8114611118576040519150601f19603f3d011682016040523d82523d5f602084013e61111d565b606091505b509350905080806111475750630556f18360e41b61113a84613ccc565b6001600160e01b03191614155b1561118857606084018051604017905280158061116357508251155b156111745760608401805160021790525b82515f036111885760608401805160081790525b50505b60408201525b61119a83613a7a565b92505b50600101610fdb565b50815181146111c85760405163252e18f560e11b815260040160405180910390fd5b61093684611e58565b5f60605f60405180604001604052806005815260200164022a72998960dd1b8152505190505f84519050818111801561122f575061122f855f60405180604001604052806005815260200164022a72998960dd1b8152505f8661205c565b156112c3575f61126a86846112448186613e6a565b7f200000000000000000000000000000000000000000000000000000000000000061207e565b9050818110156112a55761129e86611283836001613e7d565b600161128f8587613e6a565b6112999190613e6a565b6120fe565b93506112a8565b50805b6112bf6112ba87856112998186613e6a565b612153565b9450505b5050915091565b60605f806112da848601866136fa565b915091505f806112eb848a8a611c7f565b90925090506001600160a01b0382166113195783604051635fe9a5df60e01b8152600401610c3091906131a1565b61137d8285856001857f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610adc573d5f803e3d5ffd5b9998505050505050505050565b5f60605f6001600160a01b03166113d585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b6001600160a01b03160361148b577f000000000000000000000000000000000000000000000000000000000000000091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015611461573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526114889190810190613b92565b90505b9250929050565b5f805f6114d385858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b90506001600160a01b038116156114ee5791505f905061148b565b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa15801561154a573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526115719190810190613b92565b8686601060405160240161158793929190613bc4565b60408051601f198184030181529181526020820180516001600160e01b03166331b137b960e01b17905251630556f18360e41b8152610c30939291907f833d6ba700000000000000000000000000000000000000000000000000000000908a908a90600401613c74565b5f818060200190518101906116069190613ea6565b9050611671815f0151826020015185846040015160405160240161162b929190613e30565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a08601516122a1565b505050565b6060866001600160a01b03163b5f036116a45785604051635fe9a5df60e01b8152600401610c3091906131a1565b5f7fac9650d8000000000000000000000000000000000000000000000000000000006116cf87613ccc565b6001600160e01b0319161490505f8580156116f657506116f68963477cc53f60e11b612464565b90505f818061171157506117118a639061b92360e01b612464565b90506117248a63582de3e760e01b612464565b80156117a857508215806117a857508080156117a8575060405163582de3e760e01b81526312d6c5b760e31b60048201526001600160a01b038b169063582de3e790602401602060405180830381865afa158015611784573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117a89190613f75565b156117f25780156117cd576117c88a6117c3848c8c8b6124ea565b61257c565b6117f2565b6117f28a89636d6dd54060e01b5f60e01b60405180602001604052805f8152506122a1565b606083156118275761180d896004808c516112999190613e6a565b8060200190518101906118209190613f90565b9050611872565b60408051600180825281830190925290816020015b606081526020019060019003908161183c57905050905088815f8151811061186657611866613a92565b60200260200101819052505b81156118cf575f5b81518110156118cd576118a8848c84848151811061189a5761189a613a92565b60200260200101518b6124ea565b8282815181106118ba576118ba613a92565b602090810291909101015260010161187a565b505b6119783080639f28e99d6118e48f868c6125a1565b6040516024016118f491906135bd565b60408051601f19818403018152918152602080830180516001600160e01b031660e09590951b94909417909352519092507f491fc4f900000000000000000000000000000000000000000000000000000000915f91611964918b918a910191151582521515602082015260400190565b6040516020818303038152906040526122a1565b505050509695505050505050565b6119ce6040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b82815260c0810182905261051b81611a26565b60608201515f9061ffff166001148015611a035750604083015161ffff166010145b8015611a1f5750611a1f835f01518460200151845f865161205c565b9392505050565b60c08101516020820181905281515111611a3d5750565b5f611a4f825f015183602001516126b6565b8260200151611a5e9190613e7d565b8251909150611a6d908261270d565b61ffff166040830152611a81600282613e7d565b8251909150611a90908261270d565b61ffff166060830152611aa4600282613e7d565b8251909150611ab3908261272e565b63ffffffff166080830152611ac9600482613e7d565b82519091505f90611ada908361270d565b61ffff169050611aeb600283613e7d565b60a084018190529150611afe8183613e7d565b60c0909301929092525050565b60608351821115611b2f5760405163f4ba19b760e01b815260040160405180910390fd5b611b398383613e6a565b67ffffffffffffffff811115611b5157611b516131ee565b6040519080825280601f01601f191660200182016040528015611b7b576020820181803683370190505b50928401602090810193928501810192915081015b82841015611bce5783515f1a6001850194508015611bc85780850184811115611bbd575f94505050611bce565b8186845e9450908101905b50611b90565b602082018103825250818314611a1f5760405163f4ba19b760e01b815260040160405180910390fd5b5f611c237f0000000000000000000000000000000000000000000000000000000000000000835f61274a565b905050809150507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03161480611c7257506001600160a01b03811630145b15611c7a57505f5b919050565b5f606081611c8f84860186613837565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bdf95fef836040518263ffffffff1660e01b8152600401611cde9190613936565b5f60405180830381865afa158015611cf8573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611d1f9190810190613a0f565b5090505f611d2d825f611986565b90505b80515160208201511015611d8857611d4881896119e1565b15611d7a57611d66610371825f01518360a001518460c00151611b0b565b90955093506001600160a01b038516611d88575b611d8381611a26565b611d30565b505050935093915050565b5f306001600160a01b03831603611dac57506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685611dfd577f0000000000000000000000000000000000000000000000000000000000000000611dff565b5a5b84604051611e0d9190613e54565b5f604051808303818686fa925050503d805f8114611e46576040519150601f19603f3d011682016040523d82523d5f602084013e611e4b565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff811115611e7557611e756131ee565b604051908082528060200260200182016040528015611ed257816020015b611ebf60405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b815260200190600190039081611e935790505b5090505f805b835151811015611f83575f845f01518281518110611ef857611ef8613a92565b6020026020010151905060408160600151165f03611f7a575f611f1e8260400151612018565b90506040518060600160405280825f01516001600160a01b03168152602001826020015181526020018260400151815250858580611f5b90613a7a565b965081518110611f6d57611f6d613a92565b6020026020010181905250505b50600101611ed8565b5080156116715780825230836020015183604051602401611fa4919061402d565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af760000000000000000000000000000000000000000000000000000000091610c05918991016135bd565b6040805160a0810182525f80825260606020830181905292820183905282820152608081019190915261051b6120578360048086516112999190613e6a565b612846565b5f6120688484846128b1565b6120738787856128b1565b149695505050505050565b5f8061208a8486613e7d565b90505b808510156120f257826001600160f81b0319168686815181106120b2576120b2613a92565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016036120e7578491505061093a565b60019094019361208d565b505f1995945050505050565b60608167ffffffffffffffff811115612119576121196131ee565b6040519080825280601f01601f191660200182016040528015612143576020820181803683370190505b509050611a1f8484835f866128ca565b5f8151602a1480156121ad5750612169826140b9565b7dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f3078000000000000000000000000000000000000000000000000000000000000145b156121d5575f806121c1846002602a612902565b9150915080156121d2575092915050565b50505b5f6121df8361293a565b90505f61220d7f0000000000000000000000000000000000000000000000000000000000000000835f612afc565b5090925050506001600160a01b0381161561229a57806001600160a01b0316633b3b57de61223b845f612c81565b6040518263ffffffff1660e01b815260040161225991815260200190565b602060405180830381865afa925050508015612292575060408051601f3d908101601f1916820190925261228f91810190614104565b60015b1561229a5792505b5050919050565b5f806122b66122af88611d93565b8888611dc5565b91509150811580156122e05750630556f18360e41b6122d482613ccc565b6001600160e01b031916145b1561238e575f6122ef82612018565b9050876001600160a01b0316815f01516001600160a01b03160361238c57308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b031916815260200189815250604051602001610c05919061411f565b505b5f8261239a578461239c565b855b90506001600160e01b031981161561244e57306001600160a01b03168183866040516024016123cc929190613e30565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b031990941693909317909252905161240a9190613e54565b5f60405180830381855afa9150503d805f8114612442576040519150601f19603f3d011682016040523d82523d5f602084013e612447565b606091505b5090935091505b821561245c57815160208301f35b815160208301fd5b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f5190508280156124d4575060208210155b80156124df57505f81115b979650505050505050565b606084612533578383604051602401612504929190613e30565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b179052612573565b8383836040516024016125489392919061419b565b60408051601f198184030181529190526020810180516001600160e01b031663477cc53f60e11b1790525b95945050505050565b61259d82825f60e01b5f60e01b60405180602001604052805f8152506122a1565b5050565b60408051808201909152606080825260208201525f835167ffffffffffffffff8111156125d0576125d06131ee565b60405190808252806020026020018201604052801561263357816020015b61262060405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b8152602001906001900390816125ee5790505b5090505f5b8451811015612699575f82828151811061265457612654613a92565b60209081029190910101516001600160a01b0388168152865190915086908390811061268257612682613a92565b602090810291909101810151910152600101612638565b506040805180820190915290815260208101929092525092915050565b5f815b835181106126c9576126c96141dd565b5f6126d48583612cb2565b60ff1690506126e4816001613e7d565b6126ee9083613e7d565b9150805f036126fd5750612703565b506126b9565b61093a8382613e6a565b5f6127228361271d846002613e7d565b612ce4565b50016020015160f01c90565b5f61273e8361271d846004613e7d565b50016020015160e01c90565b5f805f805f6127598787612d2c565b9092509050811561283a575f805f6127728b8b8661274a565b92509250925061278b82865f9182526020526040902090565b6040517f0178b8bf000000000000000000000000000000000000000000000000000000008152600481018290529097506001600160a01b038c1690630178b8bf90602401602060405180830381865afa1580156127ea573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061280e9190614104565b97506001600160a01b0388166128265782878261282a565b87878a5b975097509750505050505061283d565b50505b93509350939050565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091528180602001905181019061288391906141f1565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b5f6128c08461271d8486613e7d565b5091016020012090565b6128d88561271d8387613e7d565b6128e68361271d8385613e7d565b6128fb82602085010185602088010183612d59565b5050505050565b5f8082612910856028613e7d565b1461291f57505f905080612932565b5f61292b868686612da2565b9093509150505b935093915050565b80516060905f81900361296257505060408051808201909152600181525f6020820152919050565b8060020167ffffffffffffffff81111561297e5761297e6131ee565b6040519080825280601f01601f1916602001820160405280156129a8576020820181803683370190505b5091506129bc602183016020850183612d59565b5f805f5b83811015612a95578581815181106129da576129da613a92565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f2e0000000000000000000000000000000000000000000000000000000000000003612a8d578281039150815f1480612a3a575060ff82115b15612a5a5785604051639a4c3e3b60e01b8152600401610c3091906131a1565b8160f81b858481518110612a7057612a70613a92565b60200101906001600160f81b03191690815f1a9053508060010192505b6001016129c0565b505080820382821480612aa8575060ff81115b15612ac85784604051639a4c3e3b60e01b8152600401610c3091906131a1565b8060f81b848381518110612ade57612ade613a92565b60200101906001600160f81b03191690815f1a905350505050919050565b5f805f805f80612b0c8888612d2c565b909250905081612b2a57508794505f9350839250859150612c789050565b612b35898983612afc565b929850909650945092506001600160a01b03861615612c69575f612b598989612e14565b5090505f876001600160a01b031663e4ae7d77836040518263ffffffff1660e01b8152600401612b8991906131a1565b602060405180830381865afa158015612ba4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612bc89190614104565b90506001600160a01b03811615612be0578096508894505b6040517f35af62160000000000000000000000000000000000000000000000000000000081526001600160a01b038916906335af621690612c259085906004016131a1565b602060405180830381865afa158015612c40573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612c649190614104565b975050505b505f9283526020526040909120905b93509350935093565b5f612c8c8383612d2c565b92509050801561051b57611a1f612ca38484612c81565b825f9182526020526040902090565b5f612cc28361271d846001613e7d565b828281518110612cd457612cd4613a92565b016020015160f81c905092915050565b815181111561259d5781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610c30918391600401918252602082015260400190565b5f805f612d398585612e91565b9250905060ff811615612d5157806021858701012092505b509250929050565b5b601f811115612d7a578151835260209283019290910190601f1901612d5a565b80156116715790518251600160209390930360031b9290921b5f190180199091169116179052565b5f8083831015612db657505f905080612932565b5f612dc18585613e6a565b90506040811180612dd25750855184115b15612de357505f9150819050612932565b858501602001612df4815f84612f0e565b92506001820160011c6020035f518160031b1c9450505050935093915050565b60605f80612e228585612e91565b925090505f60ff821667ffffffffffffffff811115612e4357612e436131ee565b6040519080825280601f01601f191660200182016040528015612e6d576020820181803683370190505b509050612e866020820160218888010160ff8516612d59565b959194509092505050565b5f8083518310612eb6578360405163ba4adc2360e01b8152600401610c3091906131a1565b838381518110612ec857612ec8613a92565b016020015160f81c91505081810160010181612ee8578351811415612eee565b83518110155b1561148b578360405163ba4adc2360e01b8152600401610c3091906131a1565b5f612f6c565b811a5f602f8211603a83101615612f305750602f19810161051b565b60478210604083111615612f495750603619810161051b565b60678210606083111615612f625750605619810161051b565b5061010092915050565b50600183820182821615612fa657612f855f8651612f14565b80855360018601955060018501945060ff811115612fa4575f92508195505b505b80851015612ff2578451612fbb600182612f14565b612fc55f83612f14565b60041b17905060ff811115612fdd575f925050612ff2565b80855350600285019450600184019350612fa6565b509392505050565b6001600160e01b03198116811461300f575f80fd5b50565b5f60208284031215613022575f80fd5b8135611a1f81612ffa565b5f8083601f84011261303d575f80fd5b50813567ffffffffffffffff811115613054575f80fd5b60208301915083602082850101111561148b575f80fd5b5f805f806040858703121561307e575f80fd5b843567ffffffffffffffff80821115613095575f80fd5b6130a18883890161302d565b909650945060208701359150808211156130b9575f80fd5b506130c68782880161302d565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561315557603f198886030184526131438583516130d2565b94509285019290850190600101613127565b5092979650505050505050565b5f8060208385031215613173575f80fd5b823567ffffffffffffffff811115613189575f80fd5b6131958582860161302d565b90969095509350505050565b602081525f611a1f60208301846130d2565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b602081525f61093a6020830184866131b3565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff81118282101715613225576132256131ee565b60405290565b6040516080810167ffffffffffffffff81118282101715613225576132256131ee565b60405160c0810167ffffffffffffffff81118282101715613225576132256131ee565b604051601f8201601f1916810167ffffffffffffffff8111828210171561329a5761329a6131ee565b604052919050565b5f67ffffffffffffffff8211156132bb576132bb6131ee565b5060051b60200190565b6001600160a01b038116811461300f575f80fd5b8035611c7a816132c5565b5f67ffffffffffffffff8211156132fd576132fd6131ee565b50601f01601f191660200190565b5f61331d613318846132e4565b613271565b9050828152838383011115613330575f80fd5b828260208301375f602084830101529392505050565b5f82601f830112613355575f80fd5b611a1f8383356020850161330b565b5f82601f830112613373575f80fd5b81356020613383613318836132a2565b82815260059290921b840181019181810190868411156133a1575f80fd5b8286015b848110156133f257803567ffffffffffffffff8111156133c3575f80fd5b8701603f810189136133d3575f80fd5b6133e489868301356040840161330b565b8452509183019183016133a5565b509695505050505050565b5f602080838503121561340e575f80fd5b823567ffffffffffffffff80821115613425575f80fd5b9084019060408287031215613438575f80fd5b613440613202565b82358281111561344e575f80fd5b8301601f8101881361345e575f80fd5b803561346c613318826132a2565b81815260059190911b8201860190868101908a83111561348a575f80fd5b8784015b83811015613532578035878111156134a4575f80fd5b85016080818e03601f190112156134b9575f80fd5b6134c161322b565b8a8201356134ce816132c5565b81526040820135898111156134e1575f80fd5b6134ef8f8d83860101613346565b8c83015250606082013589811115613505575f80fd5b6135138f8d83860101613346565b604083015250608091909101356060820152835291880191880161348e565b5084525050508284013582811115613548575f80fd5b61355488828601613364565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b848110156135b057601f1986840301895261359e8383516130d2565b98840198925090830190600101613582565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b8281101561365b57607f198b830301845285516001600160a01b03815116835289810151888b850152613626898501826130d2565b9050868201518482038886015261363d82826130d2565b928b0151948b019490945250958901959389019391506001016135f1565b50968a0151898803601f190160408b0152966136778189613565565b9b9a5050505050505050505050565b5f60208284031215613696575f80fd5b813567ffffffffffffffff8111156136ac575f80fd5b61093a84828501613346565b6001600160a01b0383168152604060208201525f61093a60408301846130d2565b6001600160a01b0383168152604060208201525f61093a6040830184613565565b5f806040838503121561370b575f80fd5b823567ffffffffffffffff80821115613722575f80fd5b61372e86838701613346565b93506020850135915080821115613743575f80fd5b5061375085828601613346565b9150509250929050565b801515811461300f575f80fd5b8035611c7a8161375a565b5f805f805f8060c08789031215613787575f80fd5b613790876132d9565b9550602087013567ffffffffffffffff808211156137ac575f80fd5b6137b88a838b01613346565b965060408901359150808211156137cd575f80fd5b6137d98a838b01613346565b95506137e760608a01613767565b945060808901359150808211156137fc575f80fd5b6138088a838b01613346565b935060a089013591508082111561381d575f80fd5b5061382a89828a01613364565b9150509295509295509295565b5f6020808385031215613848575f80fd5b823567ffffffffffffffff8082111561385f575f80fd5b818501915085601f830112613872575f80fd5b8135613880613318826132a2565b81815260059190911b8301840190848101908883111561389e575f80fd5b8585015b83811015613929578035858111156138b8575f80fd5b86016040818c03601f19018113156138ce575f80fd5b6138d6613202565b89830135888111156138e6575f80fd5b6138f48e8c83870101613346565b825250908201359087821115613908575f80fd5b6139168d8b84860101613346565b818b0152855250509186019186016138a2565b5098975050505050505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156139ad57888303603f1901855281518051878552613981888601826130d2565b91890151858303868b015291905061399981836130d2565b96890196945050509086019060010161395d565b509098975050505050505050565b5f6139c8613318846132e4565b90508281528383830111156139db575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f830112613a00575f80fd5b611a1f838351602085016139bb565b5f8060408385031215613a20575f80fd5b825167ffffffffffffffff811115613a36575f80fd5b613a42858286016139f1565b925050602083015163ffffffff81168114613a5b575f80fd5b809150509250929050565b634e487b7160e01b5f52601160045260245ffd5b5f60018201613a8b57613a8b613a66565b5060010190565b634e487b7160e01b5f52603260045260245ffd5b5f8060408385031215613ab7575f80fd5b8235613ac28161375a565b91506020830135613a5b8161375a565b5f60208284031215613ae2575f80fd5b815167ffffffffffffffff811115613af8575f80fd5b61093a848285016139f1565b5f82601f830112613b13575f80fd5b81516020613b23613318836132a2565b82815260059290921b84018101918181019086841115613b41575f80fd5b8286015b848110156133f257805167ffffffffffffffff811115613b63575f80fd5b8701603f81018913613b73575f80fd5b613b848986830151604084016139bb565b845250918301918301613b45565b5f60208284031215613ba2575f80fd5b815167ffffffffffffffff811115613bb8575f80fd5b61093a84828501613b04565b604081525f613bd76040830185876131b3565b905061ffff83166020830152949350505050565b604081525f613bfe6040830186886131b3565b82810360208401526124df8185876131b3565b6001600160a01b038616815260a060208201525f613c3260a0830187613565565b8281036040840152613c4481876130d2565b90506001600160e01b0319851660608401528281036080840152613c6881856130d2565b98975050505050505050565b6001600160a01b038716815260a060208201525f613c9560a0830188613565565b8281036040840152613ca781886130d2565b90506001600160e01b031986166060840152828103608084015261137d8185876131b3565b5f815160208301516001600160e01b031980821693506004831015613cfb5780818460040360031b1b83161693505b505050919050565b5f82601f830112613d12575f80fd5b81356020613d22613318836132a2565b82815260059290921b84018101918181019086841115613d40575f80fd5b8286015b848110156133f257803567ffffffffffffffff811115613d62575f80fd5b613d708986838b0101613346565b845250918301918301613d44565b5f8060408385031215613d8f575f80fd5b823567ffffffffffffffff80821115613da6575f80fd5b818501915085601f830112613db9575f80fd5b81356020613dc9613318836132a2565b82815260059290921b84018101918181019089841115613de7575f80fd5b948201945b83861015613e0e578535613dff8161375a565b82529482019490820190613dec565b96505086013592505080821115613e23575f80fd5b5061375085828601613d03565b604081525f613e4260408301856130d2565b828103602084015261257381856130d2565b5f82518060208501845e5f920191825250919050565b8181038181111561051b5761051b613a66565b8082018082111561051b5761051b613a66565b8051611c7a816132c5565b8051611c7a81612ffa565b5f60208284031215613eb6575f80fd5b815167ffffffffffffffff80821115613ecd575f80fd5b9083019060c08286031215613ee0575f80fd5b613ee861324e565b613ef183613e90565b8152613eff60208401613e9b565b6020820152604083015182811115613f15575f80fd5b613f21878286016139f1565b604083015250613f3360608401613e9b565b6060820152613f4460808401613e9b565b608082015260a083015182811115613f5a575f80fd5b613f66878286016139f1565b60a08301525095945050505050565b5f60208284031215613f85575f80fd5b8151611a1f8161375a565b5f6020808385031215613fa1575f80fd5b825167ffffffffffffffff80821115613fb8575f80fd5b818501915085601f830112613fcb575f80fd5b8151613fd9613318826132a2565b81815260059190911b83018401908481019088831115613ff7575f80fd5b8585015b8381101561392957805185811115614011575f80fd5b61401f8b89838a01016139f1565b845250918601918601613ffb565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156139ad57603f19898403018552815160606001600160a01b03825116855288820151818a87015261408b82870182613565565b915050878201519150848103888601526140a581836130d2565b968901969450505090860190600101614054565b5f815160208301517fffff00000000000000000000000000000000000000000000000000000000000080821693506002831015613cfb5760029290920360031b82901b161692915050565b5f60208284031215614114575f80fd5b8151611a1f816132c5565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c0606085015261416560e08501836130d2565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c085015261257382826130d2565b606081525f6141ad60608301866130d2565b82810360208401526141bf81866130d2565b905082810360408401526141d381856130d2565b9695505050505050565b634e487b7160e01b5f52600160045260245ffd5b5f805f805f60a08688031215614205575f80fd5b8551614210816132c5565b602087015190955067ffffffffffffffff8082111561422d575f80fd5b61423989838a01613b04565b9550604088015191508082111561424e575f80fd5b61425a89838a016139f1565b94506060880151915061426c82612ffa565b608088015191935080821115614280575f80fd5b5061428d888289016139f1565b915050929550929590935056fea2646970667358221220bc259f69cdf0833870993e13cadfdc6ccebbf788e63fbc0bfcc978527f109bd164736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b5060043610610184575f3560e01c80639cf82aa5116100dd578063e9187d0111610088578063ef46c0b811610063578063ef46c0b814610419578063f394443a1461042e578063f8c8761314610441575f80fd5b8063e9187d01146103d2578063ed57d294146103e5578063eea330f914610406575f80fd5b8063c4314175116100b8578063c431417514610363578063c92cc49a14610384578063d93fea04146103ab575f80fd5b80639cf82aa51461031d5780639f28e99d14610330578063b536af7614610350575f80fd5b80636ccb86601161013d578063833d6ba711610118578063833d6ba7146102b15780639061b923146102e35780639ad59435146102f6575f80fd5b80636ccb8660146102275780636d6dd540146102665780637f4c88f61461028a575f80fd5b806329476d8a1161016d57806329476d8a146101d0578063491fc4f9146101e3578063582de3e714610203575f80fd5b806301ffc9a71461018857806319b4949c146101b0575b5f80fd5b61019b610196366004613012565b610468565b60405190151581526020015b60405180910390f35b6101c36101be36600461306b565b610521565b6040516101a79190613100565b61019b6101de366004613162565b61074a565b6101f66101f136600461306b565b6107a4565b6040516101a791906131a1565b61019b610211366004613012565b6001600160e01b0319166312d6c5b760e31b1490565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101a7565b61027c61027436600461306b565b509192909150565b6040516101a79291906131db565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6102c46102bf36600461306b565b610942565b604080516001600160a01b0390931683529015156020830152016101a7565b6101f66102f136600461306b565b610996565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6101c361032b366004613162565b610c39565b61034361033e3660046133fd565b610dc1565b6040516101a791906135bd565b61034361035e36600461306b565b610f82565b610376610371366004613686565b6111d1565b6040516101a79291906136b8565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b6101f66103e036600461306b565b6112ca565b6103f86103f3366004613162565b61138a565b6040516101a79291906136d9565b6102c4610414366004613162565b611492565b61042c6104273660046136fa565b6115f1565b005b6101f661043c366004613772565b611676565b61024e7f000000000000000000000000000000000000000000000000000000000000000081565b5f639061b92360e01b6001600160e01b0319831614806104b157507fc7e45d73000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b806104e557507fed57d294000000000000000000000000000000000000000000000000000000006001600160e01b03198316145b80610500575063582de3e760e01b6001600160e01b03198316145b8061051b57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60605f61053085870187613837565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bdf95fef836040518263ffffffff1660e01b815260040161057f9190613936565b5f60405180830381865afa158015610599573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526105c09190810190613a0f565b5090505f806105cf835f611986565b90505b8051516020820151101561063e5761061f8188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506119e192505050565b156106305761062d82613a7a565b91505b61063981611a26565b6105d2565b508067ffffffffffffffff811115610658576106586131ee565b60405190808252806020026020018201604052801561068b57816020015b60608152602001906001900390816106765790505b5093505f90505f61069c835f611986565b90505b8051516020820151101561073e576106ec8188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506119e192505050565b1561073057610707815f01518260a001518360c00151611b0b565b858361071281613a7a565b94508151811061072457610724613a92565b60200260200101819052505b61073981611a26565b61069f565b50505050949350505050565b5f806001600160a01b031661079384848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b6001600160a01b0316149392505050565b60605f6107b3858701876133fd565b5190505f806107c485870187613aa6565b9150915081156108d1575f835167ffffffffffffffff8111156107e9576107e96131ee565b60405190808252806020026020018201604052801561081c57816020015b60608152602001906001900390816108075790505b5090505f5b84518110156108a5575f85828151811061083d5761083d613a92565b602002602001015190505f8160400151905084801561086157506060820151600e16155b1561087d578080602001905181019061087a9190613ad2565b90505b8084848151811061089057610890613a92565b60209081029190910101525050600101610821565b50806040516020016108b79190613100565b60405160208183030381529060405294505050505061093a565b5f835f815181106108e4576108e4613a92565b60209081029190910101516040810151606082015191925090600e161561090d57805160208201fd5b821561092a57808060200190518101906109279190613ad2565b90505b945061093a9350505050565b5050505b949350505050565b5f805f61098785858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b92508a9150611c7f9050565b50976001975095505050505050565b60605f6109d786868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b90506001600160a01b03811615610b0b57610b038187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516020601f8b0181900481028201810190925289815292508991508890819084018382808284375f9201829052506040805160208101825282815281517f093a86d3000000000000000000000000000000000000000000000000000000008152915192955093506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063093a86d391600480830192879291908290030181865afa158015610adc573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261043c9190810190613b92565b91505061093a565b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610b67573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610b8e9190810190613b92565b87876010604051602401610ba493929190613bc4565b60408051601f19818403018152918152602080830180516001600160e01b03166331b137b960e01b17905290517fe9187d010000000000000000000000000000000000000000000000000000000091610c05918c918c918c918c9101613beb565b60408051601f1981840301815290829052630556f18360e41b8252610c309594939291600401613c11565b60405180910390fd5b60605f610c7a84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b90506001600160a01b03811615610cbe57604080515f8082526020820190925290610cb5565b6060815260200190600190039081610ca05790505b5091505061051b565b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610d1a573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610d419190810190613b92565b85856010604051602401610d5793929190613bc4565b60408051601f198184030181529181526020820180516001600160e01b03166331b137b960e01b17905251630556f18360e41b8152610c30939291907f19b4949c000000000000000000000000000000000000000000000000000000009089908990600401613c74565b60408051808201909152606080825260208201525f5b825151811015610f74575f835f01518281518110610df757610df7613a92565b6020026020010151905060408160600151165f14610e155750610f6c565b60608101516030165f03610ebf575f610e30825f0151611d93565b610e3b576010610e3e565b60205b9050825b855151811015610ebc57825f01516001600160a01b0316865f01518281518110610e6e57610e6e613a92565b60200260200101515f01516001600160a01b031603610eb45781865f01518281518110610e9d57610e9d613a92565b602002602001015160600181815117915081815250505b600101610e42565b50505b5f60208260600151165f1490505f80610ee18315855f01518660200151611dc5565b9150915081158015610f0b5750630556f18360e41b610eff82613ccc565b6001600160e01b031916145b15610f20576060840180516001179052610f60565b6060840180516040179052828015610f3757508051155b610f4c5781610f4c5760608401805160021790525b80515f03610f605760608401805160081790525b60409093019290925250505b600101610dd7565b50610f7e82611e58565b5090565b60408051808201909152606080825260208201525f80610fa486880188613d7e565b915091508051825114610fca5760405163252e18f560e11b815260040160405180910390fd5b610fd6848601866133fd565b92505f805b8451518110156111a6575f855f01518281518110610ffb57610ffb613a92565b6020026020010151905060408160600151165f0361119d578351831015611191575f84848151811061102f5761102f613a92565b6020026020010151905085848151811061104b5761104b613a92565b60200260200101511561106857606082018051604417905261118b565b5f6110768360400151612018565b90505f815f01516001600160a01b031682606001518484608001516040516024016110a2929190613e30565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516110e09190613e54565b5f60405180830381855afa9150503d805f8114611118576040519150601f19603f3d011682016040523d82523d5f602084013e61111d565b606091505b509350905080806111475750630556f18360e41b61113a84613ccc565b6001600160e01b03191614155b1561118857606084018051604017905280158061116357508251155b156111745760608401805160021790525b82515f036111885760608401805160081790525b50505b60408201525b61119a83613a7a565b92505b50600101610fdb565b50815181146111c85760405163252e18f560e11b815260040160405180910390fd5b61093684611e58565b5f60605f60405180604001604052806005815260200164022a72998960dd1b8152505190505f84519050818111801561122f575061122f855f60405180604001604052806005815260200164022a72998960dd1b8152505f8661205c565b156112c3575f61126a86846112448186613e6a565b7f200000000000000000000000000000000000000000000000000000000000000061207e565b9050818110156112a55761129e86611283836001613e7d565b600161128f8587613e6a565b6112999190613e6a565b6120fe565b93506112a8565b50805b6112bf6112ba87856112998186613e6a565b612153565b9450505b5050915091565b60605f806112da848601866136fa565b915091505f806112eb848a8a611c7f565b90925090506001600160a01b0382166113195783604051635fe9a5df60e01b8152600401610c3091906131a1565b61137d8285856001857f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015610adc573d5f803e3d5ffd5b9998505050505050505050565b5f60605f6001600160a01b03166113d585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b6001600160a01b03160361148b577f000000000000000000000000000000000000000000000000000000000000000091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa158015611461573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526114889190810190613b92565b90505b9250929050565b5f805f6114d385858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611bf792505050565b90506001600160a01b038116156114ee5791505f905061148b565b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa15801561154a573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526115719190810190613b92565b8686601060405160240161158793929190613bc4565b60408051601f198184030181529181526020820180516001600160e01b03166331b137b960e01b17905251630556f18360e41b8152610c30939291907f833d6ba700000000000000000000000000000000000000000000000000000000908a908a90600401613c74565b5f818060200190518101906116069190613ea6565b9050611671815f0151826020015185846040015160405160240161162b929190613e30565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a08601516122a1565b505050565b6060866001600160a01b03163b5f036116a45785604051635fe9a5df60e01b8152600401610c3091906131a1565b5f7fac9650d8000000000000000000000000000000000000000000000000000000006116cf87613ccc565b6001600160e01b0319161490505f8580156116f657506116f68963477cc53f60e11b612464565b90505f818061171157506117118a639061b92360e01b612464565b90506117248a63582de3e760e01b612464565b80156117a857508215806117a857508080156117a8575060405163582de3e760e01b81526312d6c5b760e31b60048201526001600160a01b038b169063582de3e790602401602060405180830381865afa158015611784573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117a89190613f75565b156117f25780156117cd576117c88a6117c3848c8c8b6124ea565b61257c565b6117f2565b6117f28a89636d6dd54060e01b5f60e01b60405180602001604052805f8152506122a1565b606083156118275761180d896004808c516112999190613e6a565b8060200190518101906118209190613f90565b9050611872565b60408051600180825281830190925290816020015b606081526020019060019003908161183c57905050905088815f8151811061186657611866613a92565b60200260200101819052505b81156118cf575f5b81518110156118cd576118a8848c84848151811061189a5761189a613a92565b60200260200101518b6124ea565b8282815181106118ba576118ba613a92565b602090810291909101015260010161187a565b505b6119783080639f28e99d6118e48f868c6125a1565b6040516024016118f491906135bd565b60408051601f19818403018152918152602080830180516001600160e01b031660e09590951b94909417909352519092507f491fc4f900000000000000000000000000000000000000000000000000000000915f91611964918b918a910191151582521515602082015260400190565b6040516020818303038152906040526122a1565b505050509695505050505050565b6119ce6040518060e00160405280606081526020015f81526020015f61ffff1681526020015f61ffff1681526020015f63ffffffff1681526020015f81526020015f81525090565b82815260c0810182905261051b81611a26565b60608201515f9061ffff166001148015611a035750604083015161ffff166010145b8015611a1f5750611a1f835f01518460200151845f865161205c565b9392505050565b60c08101516020820181905281515111611a3d5750565b5f611a4f825f015183602001516126b6565b8260200151611a5e9190613e7d565b8251909150611a6d908261270d565b61ffff166040830152611a81600282613e7d565b8251909150611a90908261270d565b61ffff166060830152611aa4600282613e7d565b8251909150611ab3908261272e565b63ffffffff166080830152611ac9600482613e7d565b82519091505f90611ada908361270d565b61ffff169050611aeb600283613e7d565b60a084018190529150611afe8183613e7d565b60c0909301929092525050565b60608351821115611b2f5760405163f4ba19b760e01b815260040160405180910390fd5b611b398383613e6a565b67ffffffffffffffff811115611b5157611b516131ee565b6040519080825280601f01601f191660200182016040528015611b7b576020820181803683370190505b50928401602090810193928501810192915081015b82841015611bce5783515f1a6001850194508015611bc85780850184811115611bbd575f94505050611bce565b8186845e9450908101905b50611b90565b602082018103825250818314611a1f5760405163f4ba19b760e01b815260040160405180910390fd5b5f611c237f0000000000000000000000000000000000000000000000000000000000000000835f61274a565b905050809150507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03161480611c7257506001600160a01b03811630145b15611c7a57505f5b919050565b5f606081611c8f84860186613837565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bdf95fef836040518263ffffffff1660e01b8152600401611cde9190613936565b5f60405180830381865afa158015611cf8573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611d1f9190810190613a0f565b5090505f611d2d825f611986565b90505b80515160208201511015611d8857611d4881896119e1565b15611d7a57611d66610371825f01518360a001518460c00151611b0b565b90955093506001600160a01b038516611d88575b611d8381611a26565b611d30565b505050935093915050565b5f306001600160a01b03831603611dac57506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685611dfd577f0000000000000000000000000000000000000000000000000000000000000000611dff565b5a5b84604051611e0d9190613e54565b5f604051808303818686fa925050503d805f8114611e46576040519150601f19603f3d011682016040523d82523d5f602084013e611e4b565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff811115611e7557611e756131ee565b604051908082528060200260200182016040528015611ed257816020015b611ebf60405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b815260200190600190039081611e935790505b5090505f805b835151811015611f83575f845f01518281518110611ef857611ef8613a92565b6020026020010151905060408160600151165f03611f7a575f611f1e8260400151612018565b90506040518060600160405280825f01516001600160a01b03168152602001826020015181526020018260400151815250858580611f5b90613a7a565b965081518110611f6d57611f6d613a92565b6020026020010181905250505b50600101611ed8565b5080156116715780825230836020015183604051602401611fa4919061402d565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af760000000000000000000000000000000000000000000000000000000091610c05918991016135bd565b6040805160a0810182525f80825260606020830181905292820183905282820152608081019190915261051b6120578360048086516112999190613e6a565b612846565b5f6120688484846128b1565b6120738787856128b1565b149695505050505050565b5f8061208a8486613e7d565b90505b808510156120f257826001600160f81b0319168686815181106120b2576120b2613a92565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016036120e7578491505061093a565b60019094019361208d565b505f1995945050505050565b60608167ffffffffffffffff811115612119576121196131ee565b6040519080825280601f01601f191660200182016040528015612143576020820181803683370190505b509050611a1f8484835f866128ca565b5f8151602a1480156121ad5750612169826140b9565b7dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f3078000000000000000000000000000000000000000000000000000000000000145b156121d5575f806121c1846002602a612902565b9150915080156121d2575092915050565b50505b5f6121df8361293a565b90505f61220d7f0000000000000000000000000000000000000000000000000000000000000000835f612afc565b5090925050506001600160a01b0381161561229a57806001600160a01b0316633b3b57de61223b845f612c81565b6040518263ffffffff1660e01b815260040161225991815260200190565b602060405180830381865afa925050508015612292575060408051601f3d908101601f1916820190925261228f91810190614104565b60015b1561229a5792505b5050919050565b5f806122b66122af88611d93565b8888611dc5565b91509150811580156122e05750630556f18360e41b6122d482613ccc565b6001600160e01b031916145b1561238e575f6122ef82612018565b9050876001600160a01b0316815f01516001600160a01b03160361238c57308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b031916815260200189815250604051602001610c05919061411f565b505b5f8261239a578461239c565b855b90506001600160e01b031981161561244e57306001600160a01b03168183866040516024016123cc929190613e30565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b031990941693909317909252905161240a9190613e54565b5f60405180830381855afa9150503d805f8114612442576040519150601f19603f3d011682016040523d82523d5f602084013e612447565b606091505b5090935091505b821561245c57815160208301f35b815160208301fd5b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f5190508280156124d4575060208210155b80156124df57505f81115b979650505050505050565b606084612533578383604051602401612504929190613e30565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b179052612573565b8383836040516024016125489392919061419b565b60408051601f198184030181529190526020810180516001600160e01b031663477cc53f60e11b1790525b95945050505050565b61259d82825f60e01b5f60e01b60405180602001604052805f8152506122a1565b5050565b60408051808201909152606080825260208201525f835167ffffffffffffffff8111156125d0576125d06131ee565b60405190808252806020026020018201604052801561263357816020015b61262060405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b8152602001906001900390816125ee5790505b5090505f5b8451811015612699575f82828151811061265457612654613a92565b60209081029190910101516001600160a01b0388168152865190915086908390811061268257612682613a92565b602090810291909101810151910152600101612638565b506040805180820190915290815260208101929092525092915050565b5f815b835181106126c9576126c96141dd565b5f6126d48583612cb2565b60ff1690506126e4816001613e7d565b6126ee9083613e7d565b9150805f036126fd5750612703565b506126b9565b61093a8382613e6a565b5f6127228361271d846002613e7d565b612ce4565b50016020015160f01c90565b5f61273e8361271d846004613e7d565b50016020015160e01c90565b5f805f805f6127598787612d2c565b9092509050811561283a575f805f6127728b8b8661274a565b92509250925061278b82865f9182526020526040902090565b6040517f0178b8bf000000000000000000000000000000000000000000000000000000008152600481018290529097506001600160a01b038c1690630178b8bf90602401602060405180830381865afa1580156127ea573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061280e9190614104565b97506001600160a01b0388166128265782878261282a565b87878a5b975097509750505050505061283d565b50505b93509350939050565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091528180602001905181019061288391906141f1565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b5f6128c08461271d8486613e7d565b5091016020012090565b6128d88561271d8387613e7d565b6128e68361271d8385613e7d565b6128fb82602085010185602088010183612d59565b5050505050565b5f8082612910856028613e7d565b1461291f57505f905080612932565b5f61292b868686612da2565b9093509150505b935093915050565b80516060905f81900361296257505060408051808201909152600181525f6020820152919050565b8060020167ffffffffffffffff81111561297e5761297e6131ee565b6040519080825280601f01601f1916602001820160405280156129a8576020820181803683370190505b5091506129bc602183016020850183612d59565b5f805f5b83811015612a95578581815181106129da576129da613a92565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f2e0000000000000000000000000000000000000000000000000000000000000003612a8d578281039150815f1480612a3a575060ff82115b15612a5a5785604051639a4c3e3b60e01b8152600401610c3091906131a1565b8160f81b858481518110612a7057612a70613a92565b60200101906001600160f81b03191690815f1a9053508060010192505b6001016129c0565b505080820382821480612aa8575060ff81115b15612ac85784604051639a4c3e3b60e01b8152600401610c3091906131a1565b8060f81b848381518110612ade57612ade613a92565b60200101906001600160f81b03191690815f1a905350505050919050565b5f805f805f80612b0c8888612d2c565b909250905081612b2a57508794505f9350839250859150612c789050565b612b35898983612afc565b929850909650945092506001600160a01b03861615612c69575f612b598989612e14565b5090505f876001600160a01b031663e4ae7d77836040518263ffffffff1660e01b8152600401612b8991906131a1565b602060405180830381865afa158015612ba4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612bc89190614104565b90506001600160a01b03811615612be0578096508894505b6040517f35af62160000000000000000000000000000000000000000000000000000000081526001600160a01b038916906335af621690612c259085906004016131a1565b602060405180830381865afa158015612c40573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612c649190614104565b975050505b505f9283526020526040909120905b93509350935093565b5f612c8c8383612d2c565b92509050801561051b57611a1f612ca38484612c81565b825f9182526020526040902090565b5f612cc28361271d846001613e7d565b828281518110612cd457612cd4613a92565b016020015160f81c905092915050565b815181111561259d5781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610c30918391600401918252602082015260400190565b5f805f612d398585612e91565b9250905060ff811615612d5157806021858701012092505b509250929050565b5b601f811115612d7a578151835260209283019290910190601f1901612d5a565b80156116715790518251600160209390930360031b9290921b5f190180199091169116179052565b5f8083831015612db657505f905080612932565b5f612dc18585613e6a565b90506040811180612dd25750855184115b15612de357505f9150819050612932565b858501602001612df4815f84612f0e565b92506001820160011c6020035f518160031b1c9450505050935093915050565b60605f80612e228585612e91565b925090505f60ff821667ffffffffffffffff811115612e4357612e436131ee565b6040519080825280601f01601f191660200182016040528015612e6d576020820181803683370190505b509050612e866020820160218888010160ff8516612d59565b959194509092505050565b5f8083518310612eb6578360405163ba4adc2360e01b8152600401610c3091906131a1565b838381518110612ec857612ec8613a92565b016020015160f81c91505081810160010181612ee8578351811415612eee565b83518110155b1561148b578360405163ba4adc2360e01b8152600401610c3091906131a1565b5f612f6c565b811a5f602f8211603a83101615612f305750602f19810161051b565b60478210604083111615612f495750603619810161051b565b60678210606083111615612f625750605619810161051b565b5061010092915050565b50600183820182821615612fa657612f855f8651612f14565b80855360018601955060018501945060ff811115612fa4575f92508195505b505b80851015612ff2578451612fbb600182612f14565b612fc55f83612f14565b60041b17905060ff811115612fdd575f925050612ff2565b80855350600285019450600184019350612fa6565b509392505050565b6001600160e01b03198116811461300f575f80fd5b50565b5f60208284031215613022575f80fd5b8135611a1f81612ffa565b5f8083601f84011261303d575f80fd5b50813567ffffffffffffffff811115613054575f80fd5b60208301915083602082850101111561148b575f80fd5b5f805f806040858703121561307e575f80fd5b843567ffffffffffffffff80821115613095575f80fd5b6130a18883890161302d565b909650945060208701359150808211156130b9575f80fd5b506130c68782880161302d565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561315557603f198886030184526131438583516130d2565b94509285019290850190600101613127565b5092979650505050505050565b5f8060208385031215613173575f80fd5b823567ffffffffffffffff811115613189575f80fd5b6131958582860161302d565b90969095509350505050565b602081525f611a1f60208301846130d2565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b602081525f61093a6020830184866131b3565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff81118282101715613225576132256131ee565b60405290565b6040516080810167ffffffffffffffff81118282101715613225576132256131ee565b60405160c0810167ffffffffffffffff81118282101715613225576132256131ee565b604051601f8201601f1916810167ffffffffffffffff8111828210171561329a5761329a6131ee565b604052919050565b5f67ffffffffffffffff8211156132bb576132bb6131ee565b5060051b60200190565b6001600160a01b038116811461300f575f80fd5b8035611c7a816132c5565b5f67ffffffffffffffff8211156132fd576132fd6131ee565b50601f01601f191660200190565b5f61331d613318846132e4565b613271565b9050828152838383011115613330575f80fd5b828260208301375f602084830101529392505050565b5f82601f830112613355575f80fd5b611a1f8383356020850161330b565b5f82601f830112613373575f80fd5b81356020613383613318836132a2565b82815260059290921b840181019181810190868411156133a1575f80fd5b8286015b848110156133f257803567ffffffffffffffff8111156133c3575f80fd5b8701603f810189136133d3575f80fd5b6133e489868301356040840161330b565b8452509183019183016133a5565b509695505050505050565b5f602080838503121561340e575f80fd5b823567ffffffffffffffff80821115613425575f80fd5b9084019060408287031215613438575f80fd5b613440613202565b82358281111561344e575f80fd5b8301601f8101881361345e575f80fd5b803561346c613318826132a2565b81815260059190911b8201860190868101908a83111561348a575f80fd5b8784015b83811015613532578035878111156134a4575f80fd5b85016080818e03601f190112156134b9575f80fd5b6134c161322b565b8a8201356134ce816132c5565b81526040820135898111156134e1575f80fd5b6134ef8f8d83860101613346565b8c83015250606082013589811115613505575f80fd5b6135138f8d83860101613346565b604083015250608091909101356060820152835291880191880161348e565b5084525050508284013582811115613548575f80fd5b61355488828601613364565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b848110156135b057601f1986840301895261359e8383516130d2565b98840198925090830190600101613582565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b8281101561365b57607f198b830301845285516001600160a01b03815116835289810151888b850152613626898501826130d2565b9050868201518482038886015261363d82826130d2565b928b0151948b019490945250958901959389019391506001016135f1565b50968a0151898803601f190160408b0152966136778189613565565b9b9a5050505050505050505050565b5f60208284031215613696575f80fd5b813567ffffffffffffffff8111156136ac575f80fd5b61093a84828501613346565b6001600160a01b0383168152604060208201525f61093a60408301846130d2565b6001600160a01b0383168152604060208201525f61093a6040830184613565565b5f806040838503121561370b575f80fd5b823567ffffffffffffffff80821115613722575f80fd5b61372e86838701613346565b93506020850135915080821115613743575f80fd5b5061375085828601613346565b9150509250929050565b801515811461300f575f80fd5b8035611c7a8161375a565b5f805f805f8060c08789031215613787575f80fd5b613790876132d9565b9550602087013567ffffffffffffffff808211156137ac575f80fd5b6137b88a838b01613346565b965060408901359150808211156137cd575f80fd5b6137d98a838b01613346565b95506137e760608a01613767565b945060808901359150808211156137fc575f80fd5b6138088a838b01613346565b935060a089013591508082111561381d575f80fd5b5061382a89828a01613364565b9150509295509295509295565b5f6020808385031215613848575f80fd5b823567ffffffffffffffff8082111561385f575f80fd5b818501915085601f830112613872575f80fd5b8135613880613318826132a2565b81815260059190911b8301840190848101908883111561389e575f80fd5b8585015b83811015613929578035858111156138b8575f80fd5b86016040818c03601f19018113156138ce575f80fd5b6138d6613202565b89830135888111156138e6575f80fd5b6138f48e8c83870101613346565b825250908201359087821115613908575f80fd5b6139168d8b84860101613346565b818b0152855250509186019186016138a2565b5098975050505050505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156139ad57888303603f1901855281518051878552613981888601826130d2565b91890151858303868b015291905061399981836130d2565b96890196945050509086019060010161395d565b509098975050505050505050565b5f6139c8613318846132e4565b90508281528383830111156139db575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f830112613a00575f80fd5b611a1f838351602085016139bb565b5f8060408385031215613a20575f80fd5b825167ffffffffffffffff811115613a36575f80fd5b613a42858286016139f1565b925050602083015163ffffffff81168114613a5b575f80fd5b809150509250929050565b634e487b7160e01b5f52601160045260245ffd5b5f60018201613a8b57613a8b613a66565b5060010190565b634e487b7160e01b5f52603260045260245ffd5b5f8060408385031215613ab7575f80fd5b8235613ac28161375a565b91506020830135613a5b8161375a565b5f60208284031215613ae2575f80fd5b815167ffffffffffffffff811115613af8575f80fd5b61093a848285016139f1565b5f82601f830112613b13575f80fd5b81516020613b23613318836132a2565b82815260059290921b84018101918181019086841115613b41575f80fd5b8286015b848110156133f257805167ffffffffffffffff811115613b63575f80fd5b8701603f81018913613b73575f80fd5b613b848986830151604084016139bb565b845250918301918301613b45565b5f60208284031215613ba2575f80fd5b815167ffffffffffffffff811115613bb8575f80fd5b61093a84828501613b04565b604081525f613bd76040830185876131b3565b905061ffff83166020830152949350505050565b604081525f613bfe6040830186886131b3565b82810360208401526124df8185876131b3565b6001600160a01b038616815260a060208201525f613c3260a0830187613565565b8281036040840152613c4481876130d2565b90506001600160e01b0319851660608401528281036080840152613c6881856130d2565b98975050505050505050565b6001600160a01b038716815260a060208201525f613c9560a0830188613565565b8281036040840152613ca781886130d2565b90506001600160e01b031986166060840152828103608084015261137d8185876131b3565b5f815160208301516001600160e01b031980821693506004831015613cfb5780818460040360031b1b83161693505b505050919050565b5f82601f830112613d12575f80fd5b81356020613d22613318836132a2565b82815260059290921b84018101918181019086841115613d40575f80fd5b8286015b848110156133f257803567ffffffffffffffff811115613d62575f80fd5b613d708986838b0101613346565b845250918301918301613d44565b5f8060408385031215613d8f575f80fd5b823567ffffffffffffffff80821115613da6575f80fd5b818501915085601f830112613db9575f80fd5b81356020613dc9613318836132a2565b82815260059290921b84018101918181019089841115613de7575f80fd5b948201945b83861015613e0e578535613dff8161375a565b82529482019490820190613dec565b96505086013592505080821115613e23575f80fd5b5061375085828601613d03565b604081525f613e4260408301856130d2565b828103602084015261257381856130d2565b5f82518060208501845e5f920191825250919050565b8181038181111561051b5761051b613a66565b8082018082111561051b5761051b613a66565b8051611c7a816132c5565b8051611c7a81612ffa565b5f60208284031215613eb6575f80fd5b815167ffffffffffffffff80821115613ecd575f80fd5b9083019060c08286031215613ee0575f80fd5b613ee861324e565b613ef183613e90565b8152613eff60208401613e9b565b6020820152604083015182811115613f15575f80fd5b613f21878286016139f1565b604083015250613f3360608401613e9b565b6060820152613f4460808401613e9b565b608082015260a083015182811115613f5a575f80fd5b613f66878286016139f1565b60a08301525095945050505050565b5f60208284031215613f85575f80fd5b8151611a1f8161375a565b5f6020808385031215613fa1575f80fd5b825167ffffffffffffffff80821115613fb8575f80fd5b818501915085601f830112613fcb575f80fd5b8151613fd9613318826132a2565b81815260059190911b83018401908481019088831115613ff7575f80fd5b8585015b8381101561392957805185811115614011575f80fd5b61401f8b89838a01016139f1565b845250918601918601613ffb565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156139ad57603f19898403018552815160606001600160a01b03825116855288820151818a87015261408b82870182613565565b915050878201519150848103888601526140a581836130d2565b968901969450505090860190600101614054565b5f815160208301517fffff00000000000000000000000000000000000000000000000000000000000080821693506002831015613cfb5760029290920360031b82901b161692915050565b5f60208284031215614114575f80fd5b8151611a1f816132c5565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c0606085015261416560e08501836130d2565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c085015261257382826130d2565b606081525f6141ad60608301866130d2565b82810360208401526141bf81866130d2565b905082810360408401526141d381856130d2565b9695505050505050565b634e487b7160e01b5f52600160045260245ffd5b5f805f805f60a08688031215614205575f80fd5b8551614210816132c5565b602087015190955067ffffffffffffffff8082111561422d575f80fd5b61423989838a01613b04565b9550604088015191508082111561424e575f80fd5b61425a89838a016139f1565b94506060880151915061426c82612ffa565b608088015191935080821115614280575f80fd5b5061428d888289016139f1565b915050929550929590935056fea2646970667358221220bc259f69cdf0833870993e13cadfdc6ccebbf788e63fbc0bfcc978527f109bd164736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "1090": [
      {
        "length": 32,
        "start": 7641
      }
    ],
    "14406": [
      {
        "length": 32,
        "start": 655
      },
      {
        "length": 32,
        "start": 7165
      }
    ],
    "14408": [
      {
        "length": 32,
        "start": 763
      },
      {
        "length": 32,
        "start": 7212
      }
    ],
    "14411": [
      {
        "length": 32,
        "start": 905
      },
      {
        "length": 32,
        "start": 8679
      }
    ],
    "14414": [
      {
        "length": 32,
        "start": 1094
      },
      {
        "length": 32,
        "start": 1333
      },
      {
        "length": 32,
        "start": 5093
      },
      {
        "length": 32,
        "start": 7316
      }
    ],
    "14418": [
      {
        "length": 32,
        "start": 944
      },
      {
        "length": 32,
        "start": 2830
      },
      {
        "length": 32,
        "start": 3265
      },
      {
        "length": 32,
        "start": 5128
      },
      {
        "length": 32,
        "start": 5361
      }
    ],
    "14422": [
      {
        "length": 32,
        "start": 556
      },
      {
        "length": 32,
        "start": 2707
      },
      {
        "length": 32,
        "start": 4900
      }
    ]
  },
  "inputSourceName": "project/src/dns/DNSTLDResolver.sol",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "DNSEncodingFailed(string)": [
        {
          "details": "A label of the ENS name has an invalid size.      Error selector: `0x9a4c3e3b`"
        }
      ],
      "InvalidBatchGatewayResponse()": [
        {
          "details": "Error selector: `0x4a5c31ea`"
        }
      ],
      "InvalidTXT()": [
        {
          "details": "Error selector: `0xf4ba19b7`"
        }
      ],
      "OffchainLookup(address,string[],bytes,bytes4,bytes)": [
        {
          "details": "https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`"
        }
      ],
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ],
      "UnreachableName(bytes)": [
        {
          "details": "`name` cannot be resolved.      Error selector: `0x5fe9a5df`",
          "params": {
            "name": "The DNS-encoded ENS name."
          }
        }
      ]
    },
    "events": {
      "VerifierChanged(bytes,address)": {
        "params": {
          "name": "The DNS-encoded name.",
          "verifier": "The new verifier contract."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "callResolver(address,bytes,bytes,bool,bytes,string[])": {
        "details": "Reverts `UnreachableName` if resolver is not a contract.      This function never returns normally.      The return type is necessary to define the result of the callback.      Call this function externally or with `ccipRead()` to intercept the response.",
        "params": {
          "batchGateways": "The batch gateway URLs.",
          "context": "The context for `IExtendedDNSResolver`.",
          "data": "The calldata for the resolution.",
          "hasContext": "True if `IExtendedDNSResolver` should be considered.",
          "name": "The DNS-encoded ENS name.",
          "resolver": "The resolver to call."
        }
      },
      "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": {
        "details": "Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`."
      },
      "ccipBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \"done\".",
        "params": {
          "extraData": "The contextual data passed from `ccipBatch()`.",
          "response": "The response from the batch gateway."
        },
        "returns": {
          "batch": "The batch where every lookup is \"done\"."
        }
      },
      "ccipReadCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.",
        "params": {
          "extraData": "The contextual data passed from `ccipRead()`.",
          "response": "The response from offchain."
        }
      },
      "getDNSSECRecords(bytes)": {
        "details": "This function executes over multiple steps.",
        "params": {
          "name": "The DNS-encoded name."
        },
        "returns": {
          "_0": "The verified DNSSEC TXT records."
        }
      },
      "getResolver(bytes)": {
        "details": "This function executes over multiple steps.",
        "params": {
          "name": "The DNS-encoded name."
        },
        "returns": {
          "_0": "The underlying resolver address.",
          "_1": "`true` if `resolver` is offchain."
        }
      },
      "parseDNSSECRecord(bytes)": {
        "params": {
          "txt": "The DNSSEC TXT record."
        },
        "returns": {
          "context": "The context data.",
          "resolver": "The resolver address or null if wrong format or name didn't resolve."
        }
      },
      "requiresOffchain(bytes)": {
        "params": {
          "name": "The DNS-encoded name."
        },
        "returns": {
          "offchain": "`true` if requires offchain data."
        }
      },
      "resolve(bytes,bytes)": {
        "details": "This function executes over multiple steps."
      },
      "resolveBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `callResolver()` from batch calling a resolver.",
        "params": {
          "extraData": "The abi-encoded properties of the call.",
          "response": "The response data from the batch gateway."
        },
        "returns": {
          "_0": "result The response from the resolver."
        }
      },
      "resolveDirectImmediateCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `callResolver()` from direct calling an immediate resolver."
      },
      "resolveOracleCallback(bytes,bytes)": {
        "params": {
          "extraData": "The contextual data passed from `resolve()`.",
          "response": "The response data."
        },
        "returns": {
          "_0": "The abi-encoded result from the resolver."
        }
      },
      "supportsFeature(bytes4)": {
        "params": {
          "featureId": "The feature identifier."
        },
        "returns": {
          "_0": "`true` if the feature is supported by the contract."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "verifierMetadata(bytes)": {
        "params": {
          "name": "The DNS-encoded name."
        },
        "returns": {
          "gateways": "The gateways used by the verifier.",
          "verifier": "The verifier contract."
        }
      }
    },
    "stateVariables": {
      "BATCH_GATEWAY_PROVIDER": {
        "details": "Shared batch gateway provider."
      },
      "ORACLE_GATEWAY_PROVIDER": {
        "details": "Shared DNSSEC oracle gateway provider."
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "3420800",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "BATCH_GATEWAY_PROVIDER()": "infinite",
        "DNSSEC_ORACLE()": "infinite",
        "DNS_TLD_RESOLVER_V1()": "infinite",
        "ENS_REGISTRY_V1()": "infinite",
        "ORACLE_GATEWAY_PROVIDER()": "infinite",
        "ROOT_REGISTRY()": "infinite",
        "callResolver(address,bytes,bytes,bool,bytes,string[])": "infinite",
        "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": "infinite",
        "ccipBatchCallback(bytes,bytes)": "infinite",
        "ccipReadCallback(bytes,bytes)": "infinite",
        "getDNSSECRecords(bytes)": "infinite",
        "getDNSSECRecordsCallback(bytes,bytes)": "infinite",
        "getResolver(bytes)": "infinite",
        "getResolverCallback(bytes,bytes)": "infinite",
        "parseDNSSECRecord(bytes)": "infinite",
        "requiresOffchain(bytes)": "infinite",
        "resolve(bytes,bytes)": "infinite",
        "resolveBatchCallback(bytes,bytes)": "infinite",
        "resolveDirectImmediateCallback(bytes,bytes)": "infinite",
        "resolveOracleCallback(bytes,bytes)": "infinite",
        "supportsFeature(bytes4)": "463",
        "supportsInterface(bytes4)": "652",
        "verifierMetadata(bytes)": "infinite"
      },
      "internal": {
        "_determineMainnetResolver(bytes memory)": "infinite",
        "_isTXTForName(struct RRUtils.RRIterator memory,bytes memory)": "infinite",
        "_parseResolver(bytes memory)": "infinite",
        "_readTXT(bytes memory,uint256,uint256)": "infinite",
        "_verifyDNSSEC(bytes memory,bytes calldata)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ensRegistryV1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dnsTLDResolverV1\",\"type\":\"address\"},{\"internalType\":\"contract IRegistry\",\"name\":\"rootRegistry\",\"type\":\"address\"},{\"internalType\":\"contract DNSSEC\",\"name\":\"dnssecOracle\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayProvider\",\"name\":\"oracleGatewayProvider\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayProvider\",\"name\":\"batchGatewayProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ens\",\"type\":\"string\"}],\"name\":\"DNSEncodingFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchGatewayResponse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTXT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"UnreachableName\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BATCH_GATEWAY_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IGatewayProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DNSSEC_ORACLE\",\"outputs\":[{\"internalType\":\"contract DNSSEC\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DNS_TLD_RESOLVER_V1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENS_REGISTRY_V1\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE_GATEWAY_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IGatewayProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasContext\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"string[]\",\"name\":\"batchGateways\",\"type\":\"string[]\"}],\"name\":\"callResolver\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"ccipBatch\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipBatchCallback\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipReadCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"getDNSSECRecords\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"getDNSSECRecordsCallback\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"txts\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"getResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"getResolverCallback\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txt\",\"type\":\"bytes\"}],\"name\":\"parseDNSSECRecord\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"requiresOffchain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"offchain\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveBatchCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"resolveDirectImmediateCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveOracleCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"feature\",\"type\":\"bytes4\"}],\"name\":\"supportsFeature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"verifierMetadata\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"DNSEncodingFailed(string)\":[{\"details\":\"A label of the ENS name has an invalid size.      Error selector: `0x9a4c3e3b`\"}],\"InvalidBatchGatewayResponse()\":[{\"details\":\"Error selector: `0x4a5c31ea`\"}],\"InvalidTXT()\":[{\"details\":\"Error selector: `0xf4ba19b7`\"}],\"OffchainLookup(address,string[],bytes,bytes4,bytes)\":[{\"details\":\"https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`\"}],\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}],\"UnreachableName(bytes)\":[{\"details\":\"`name` cannot be resolved.      Error selector: `0x5fe9a5df`\",\"params\":{\"name\":\"The DNS-encoded ENS name.\"}}]},\"events\":{\"VerifierChanged(bytes,address)\":{\"params\":{\"name\":\"The DNS-encoded name.\",\"verifier\":\"The new verifier contract.\"}}},\"kind\":\"dev\",\"methods\":{\"callResolver(address,bytes,bytes,bool,bytes,string[])\":{\"details\":\"Reverts `UnreachableName` if resolver is not a contract.      This function never returns normally.      The return type is necessary to define the result of the callback.      Call this function externally or with `ccipRead()` to intercept the response.\",\"params\":{\"batchGateways\":\"The batch gateway URLs.\",\"context\":\"The context for `IExtendedDNSResolver`.\",\"data\":\"The calldata for the resolution.\",\"hasContext\":\"True if `IExtendedDNSResolver` should be considered.\",\"name\":\"The DNS-encoded ENS name.\",\"resolver\":\"The resolver to call.\"}},\"ccipBatch(((address,bytes,bytes,uint256)[],string[]))\":{\"details\":\"Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`.\"},\"ccipBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\",\"params\":{\"extraData\":\"The contextual data passed from `ccipBatch()`.\",\"response\":\"The response from the batch gateway.\"},\"returns\":{\"batch\":\"The batch where every lookup is \\\"done\\\".\"}},\"ccipReadCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.\",\"params\":{\"extraData\":\"The contextual data passed from `ccipRead()`.\",\"response\":\"The response from offchain.\"}},\"getDNSSECRecords(bytes)\":{\"details\":\"This function executes over multiple steps.\",\"params\":{\"name\":\"The DNS-encoded name.\"},\"returns\":{\"_0\":\"The verified DNSSEC TXT records.\"}},\"getResolver(bytes)\":{\"details\":\"This function executes over multiple steps.\",\"params\":{\"name\":\"The DNS-encoded name.\"},\"returns\":{\"_0\":\"The underlying resolver address.\",\"_1\":\"`true` if `resolver` is offchain.\"}},\"parseDNSSECRecord(bytes)\":{\"params\":{\"txt\":\"The DNSSEC TXT record.\"},\"returns\":{\"context\":\"The context data.\",\"resolver\":\"The resolver address or null if wrong format or name didn't resolve.\"}},\"requiresOffchain(bytes)\":{\"params\":{\"name\":\"The DNS-encoded name.\"},\"returns\":{\"offchain\":\"`true` if requires offchain data.\"}},\"resolve(bytes,bytes)\":{\"details\":\"This function executes over multiple steps.\"},\"resolveBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `callResolver()` from batch calling a resolver.\",\"params\":{\"extraData\":\"The abi-encoded properties of the call.\",\"response\":\"The response data from the batch gateway.\"},\"returns\":{\"_0\":\"result The response from the resolver.\"}},\"resolveDirectImmediateCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `callResolver()` from direct calling an immediate resolver.\"},\"resolveOracleCallback(bytes,bytes)\":{\"params\":{\"extraData\":\"The contextual data passed from `resolve()`.\",\"response\":\"The response data.\"},\"returns\":{\"_0\":\"The abi-encoded result from the resolver.\"}},\"supportsFeature(bytes4)\":{\"params\":{\"featureId\":\"The feature identifier.\"},\"returns\":{\"_0\":\"`true` if the feature is supported by the contract.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"verifierMetadata(bytes)\":{\"params\":{\"name\":\"The DNS-encoded name.\"},\"returns\":{\"gateways\":\"The gateways used by the verifier.\",\"verifier\":\"The verifier contract.\"}}},\"stateVariables\":{\"BATCH_GATEWAY_PROVIDER\":{\"details\":\"Shared batch gateway provider.\"},\"ORACLE_GATEWAY_PROVIDER\":{\"details\":\"Shared DNSSEC oracle gateway provider.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidBatchGatewayResponse()\":[{\"notice\":\"The batch gateway supplied an incorrect number of responses.\"}],\"InvalidTXT()\":[{\"notice\":\"Some raw TXT data was incorrectly encoded.\"}]},\"events\":{\"VerifierChanged(bytes,address)\":{\"notice\":\"The verifier contract has changed.         Use `0x00` for any name.\"}},\"kind\":\"user\",\"methods\":{\"callResolver(address,bytes,bytes,bool,bytes,string[])\":{\"notice\":\"Perform forward resolution. Call this function with `ccipRead()` to intercept the response. Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers. - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,   the call is performed directly without the batch gateway. - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,   the call is performed directly without the batch gateway. - Otherwise, the call is performed with the batch gateway.   The batch gateway is only invoked if any call reverts `OffchainLookup`.   If the calldata is `multicall()` it is disassembled, called separately, and reassembled.\"},\"getDNSSECRecords(bytes)\":{\"notice\":\"Fetch the DNSSEC TXT record.         Callers should enable EIP-3668.\"},\"getDNSSECRecordsCallback(bytes,bytes)\":{\"notice\":\"CCIP-Read callback for `getDNSSECRecords()`.\"},\"getResolver(bytes)\":{\"notice\":\"Fetch the underlying resolver for `name`.         Callers should enable EIP-3668. * If `offchain`, additional information is necessary to locate `resolver`. * If `resolver` is null, `offchain` is irrelevant.\"},\"getResolverCallback(bytes,bytes)\":{\"notice\":\"CCIP-Read callback for `getResolver()`.\"},\"parseDNSSECRecord(bytes)\":{\"notice\":\"Parse DNSSEC TXT record into parts.         Format: \\\"ENS1 <name-or-address> <context>\\\".\"},\"requiresOffchain(bytes)\":{\"notice\":\"Determine if resolving `name` requires offchain data.\"},\"resolve(bytes,bytes)\":{\"notice\":\"Resolve `name` using V1 or DNSSEC.         Caller should enable EIP-3668.\"},\"resolveOracleCallback(bytes,bytes)\":{\"notice\":\"CCIP-Read callback for `resolve()` from calling the DNSSEC oracle.         Reverts `UnreachableName` if no \\\"ENS1\\\" TXT record is found.\"},\"supportsFeature(bytes4)\":{\"notice\":\"Check if a feature is supported.\"},\"verifierMetadata(bytes)\":{\"notice\":\"Get information about the verification process.         Use ERC-165 to determine the verifier type.\"}},\"notice\":\"Resolver that performs imported DNS fallback to V1 and gasless DNS resolution. 0. Note: an imported DNS name will not reach this resolver unless set specifically. 1. If there exists a resolver in V1, go to 4. 2. Query the DNSSEC oracle for TXT records. 3. Verify TXT records, find ENS1 record, parse resolver and context. 4. Call the resolver and return the requested records.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/dns/DNSTLDResolver.sol\":\"DNSTLDResolver\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/buffer/=project/lib/buffer/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:~src/=project/src/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\"]},\"sources\":{\"project/lib/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd85358722045348893aeedd23539816c9d1b218ab801a3fcd1ec4e38ecc8eb22\",\"license\":\"BSD-2-Clause\"},\"project/lib/ens-contracts/contracts/ccipRead/CCIPBatcher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IBatchGateway} from \\\"./IBatchGateway.sol\\\";\\nimport {CCIPReader, EIP3668, OffchainLookup} from \\\"./CCIPReader.sol\\\";\\n\\nabstract contract CCIPBatcher is CCIPReader {\\n    /// @notice The batch gateway supplied an incorrect number of responses.\\n    /// @dev Error selector: `0x4a5c31ea`\\n    error InvalidBatchGatewayResponse();\\n\\n    uint256 constant FLAG_OFFCHAIN = 1 << 0; // the lookup reverted `OffchainLookup`\\n    uint256 constant FLAG_CALL_ERROR = 1 << 1; // the initial call or callback reverted\\n    uint256 constant FLAG_BATCH_ERROR = 1 << 2; // `OffchainLookup` failed on the batch gateway\\n    uint256 constant FLAG_EMPTY_RESPONSE = 1 << 3; // the initial call or callback returned `0x`\\n    uint256 constant FLAG_EIP140_BEFORE = 1 << 4; // does not have revert op code\\n    uint256 constant FLAG_EIP140_AFTER = 1 << 5; // has revert op code\\n    uint256 constant FLAG_DONE = 1 << 6; // the lookup has finished processing (private)\\n\\n    uint256 constant FLAGS_ANY_ERROR =\\n        FLAG_CALL_ERROR | FLAG_BATCH_ERROR | FLAG_EMPTY_RESPONSE;\\n    uint256 constant FLAGS_ANY_EIP140 = FLAG_EIP140_BEFORE | FLAG_EIP140_AFTER;\\n\\n    /// @dev An independent `OffchainLookup` session.\\n    struct Lookup {\\n        address target; // contract to call\\n        bytes call; // initial calldata\\n        bytes data; // response or error\\n        uint256 flags; // see: FLAG_*\\n    }\\n\\n    /// @dev A batch gateway session.\\n    struct Batch {\\n        Lookup[] lookups;\\n        string[] gateways;\\n    }\\n\\n    /// @dev Create a batch for a single target with multiple calls.\\n    /// @param target The target contract.\\n    /// @param calls The list of calldata.\\n    /// @param gateways The batch gateway URLs.\\n    function createBatch(\\n        address target,\\n        bytes[] memory calls,\\n        string[] memory gateways\\n    ) internal pure returns (Batch memory) {\\n        Lookup[] memory lookups = new Lookup[](calls.length);\\n        for (uint256 i; i < calls.length; ++i) {\\n            Lookup memory lu = lookups[i];\\n            lu.target = target;\\n            lu.call = calls[i];\\n        }\\n        return Batch(lookups, gateways);\\n    }\\n\\n    /// @dev Use `ccipRead()` to call this function with a batch.\\n    ///      The callback response will be `abi.encode(batch)`.\\n    function ccipBatch(\\n        Batch memory batch\\n    ) external view returns (Batch memory) {\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) != 0) {\\n                continue; // don't call a lookup that's already done\\n            }\\n            if ((lu.flags & FLAGS_ANY_EIP140) == 0) {\\n                uint256 flags = detectEIP140(lu.target)\\n                    ? FLAG_EIP140_AFTER\\n                    : FLAG_EIP140_BEFORE;\\n                for (uint256 j = i; j < batch.lookups.length; ++j) {\\n                    if (batch.lookups[j].target == lu.target) {\\n                        batch.lookups[j].flags |= flags;\\n                    }\\n                }\\n            }\\n            bool unsafe = (lu.flags & FLAG_EIP140_AFTER) == 0;\\n            (bool ok, bytes memory v) = safeCall(!unsafe, lu.target, lu.call);\\n            if (!ok && bytes4(v) == OffchainLookup.selector) {\\n                lu.flags |= FLAG_OFFCHAIN;\\n            } else {\\n                lu.flags |= FLAG_DONE;\\n                if (unsafe && v.length == 0) {\\n                    // unsafe contracts appear the same for throw and unimplemented fallback\\n                    // decision: interpret like an unimplemented function selector response\\n                } else if (!ok) {\\n                    lu.flags |= FLAG_CALL_ERROR;\\n                }\\n                if (v.length == 0) {\\n                    lu.flags |= FLAG_EMPTY_RESPONSE;\\n                }\\n            }\\n            lu.data = v;\\n        }\\n        _revertBatchGateway(batch); // reverts if any offchain\\n        return batch;\\n    }\\n\\n    /// @dev Check if the batch is \\\"done\\\".  If not, revert `OffchainLookup` for batch gateway.\\n    function _revertBatchGateway(Batch memory batch) internal view {\\n        IBatchGateway.Request[] memory requests = new IBatchGateway.Request[](\\n            batch.lookups.length\\n        );\\n        uint256 count;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                requests[count++] = IBatchGateway.Request(\\n                    p.sender,\\n                    p.urls,\\n                    p.callData\\n                );\\n            }\\n        }\\n        if (count > 0) {\\n            assembly {\\n                mstore(requests, count) // truncate to number of offchain requests\\n            }\\n            revert OffchainLookup(\\n                address(this),\\n                batch.gateways,\\n                abi.encodeCall(IBatchGateway.query, (requests)),\\n                this.ccipBatchCallback.selector,\\n                abi.encode(batch)\\n            );\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipBatch()`.\\n    ///      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\\n    /// @param response The response from the batch gateway.\\n    /// @param extraData The contextual data passed from `ccipBatch()`.\\n    /// @return batch The batch where every lookup is \\\"done\\\".\\n    function ccipBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (Batch memory batch) {\\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\\n            response,\\n            (bool[], bytes[])\\n        );\\n        if (failures.length != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        batch = abi.decode(extraData, (Batch));\\n        uint256 expected;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                if (expected < responses.length) {\\n                    bytes memory v = responses[expected];\\n                    if (failures[expected]) {\\n                        lu.flags |= FLAG_DONE | FLAG_BATCH_ERROR;\\n                    } else {\\n                        EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                        bool ok;\\n                        // assumption: unsafe contracts don't revert OffchainLookup()\\n                        (ok, v) = p.sender.staticcall(\\n                            abi.encodeWithSelector(\\n                                p.callbackFunction,\\n                                v,\\n                                p.extraData\\n                            )\\n                        );\\n                        if (ok || bytes4(v) != OffchainLookup.selector) {\\n                            lu.flags |= FLAG_DONE;\\n                            // decision: promote empty response from the callback => call error\\n                            // ie. the initial function was implemented but the callback was not\\n                            // this can be detected via FLAG_OFFCHAIN\\n                            if (!ok || v.length == 0) {\\n                                lu.flags |= FLAG_CALL_ERROR;\\n                            }\\n                            if (v.length == 0) {\\n                                lu.flags |= FLAG_EMPTY_RESPONSE;\\n                            }\\n                        }\\n                    }\\n                    lu.data = v;\\n                }\\n                ++expected;\\n            }\\n        }\\n        if (expected != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        _revertBatchGateway(batch);\\n    }\\n}\\n\",\"keccak256\":\"0x8315d7930568e488eac59ac205e4ed20a3ebf19445358b4218c62a49f2e5ebf6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/CCIPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @author Modified from https://github.com/unruggable-labs/CCIPReader.sol/blob/341576fe7ff2b6e0c93fc08f37740cf6439f5873/contracts/CCIPReader.sol\\n\\n/// MIT License\\n/// Portions Copyright (c) 2025 Unruggable\\n/// Portions Copyright (c) 2025 ENS Labs Ltd\\n\\n/// @dev Instructions:\\n/// 1. inherit this contract\\n/// 2. call `ccipRead()` similar to `staticcall()`\\n/// 3. do not put logic after this invocation\\n/// 4. implement all response logic in callback\\n/// 5. ensure that return type of calling function == callback function\\n\\nimport {EIP3668, OffchainLookup} from \\\"./EIP3668.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\n\\ncontract CCIPReader {\\n    /// @dev Default unsafe call gas (sufficient for legacy ENS resolver profiles).\\n    uint256 constant DEFAULT_UNSAFE_CALL_GAS = 50000;\\n\\n    /// @dev Special-purpose value for identity callback: `f(x) = x`.\\n    bytes4 constant IDENTITY_FUNCTION = bytes4(0);\\n\\n    /// @dev The gas limit for calling functions on unsafe contracts.\\n    uint256 immutable unsafeCallGas;\\n\\n    constructor(uint256 _unsafeCallGas) {\\n        unsafeCallGas = _unsafeCallGas;\\n    }\\n\\n    /// @dev A recursive CCIP-Read session.\\n    struct Context {\\n        address target;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n        bytes4 successCallbackFunction;\\n        bytes4 failureCallbackFunction;\\n        bytes myExtraData;\\n    }\\n\\n    /// @dev Same as `ccipRead()` but the callback function is the identity.\\n    function ccipRead(address target, bytes memory call) internal view {\\n        ccipRead(target, call, IDENTITY_FUNCTION, IDENTITY_FUNCTION, \\\"\\\");\\n    }\\n\\n    /// @dev Performs a CCIP-Read and handles internal recursion.\\n    ///      Reverts `OffchainLookup` if necessary.\\n    ///      Use `IDENTITY_FUNCTION` as the callback function selector for return/revert behavior.\\n    /// @param target The contract address.\\n    /// @param call The calldata to `staticcall()` on `target`.\\n    /// @param successCallbackFunction The function selector of callback on success.\\n    /// @param failureCallbackFunction The function selector of callback on failure.\\n    /// @param extraData The contextual data relayed to callback function.\\n    function ccipRead(\\n        address target,\\n        bytes memory call,\\n        bytes4 successCallbackFunction,\\n        bytes4 failureCallbackFunction,\\n        bytes memory extraData\\n    ) internal view {\\n        // We call the intended function that **could** revert with an `OffchainLookup`\\n        // We destructure the response into an execution status bool and our return bytes\\n        (bool ok, bytes memory v) = safeCall(\\n            detectEIP140(target),\\n            target,\\n            call\\n        );\\n        // IF the function reverted with an `OffchainLookup`\\n        if (!ok && bytes4(v) == OffchainLookup.selector) {\\n            // We decode the response error into a tuple\\n            // tuples allow flexibility noting stack too deep constraints\\n            EIP3668.Params memory p = decodeOffchainLookup(v);\\n            if (p.sender == target) {\\n                // We then wrap the error data in an `OffchainLookup` sent/'owned' by this contract\\n                revert OffchainLookup(\\n                    address(this),\\n                    p.urls,\\n                    p.callData,\\n                    this.ccipReadCallback.selector,\\n                    abi.encode(\\n                        Context(\\n                            target,\\n                            p.callbackFunction,\\n                            p.extraData,\\n                            successCallbackFunction,\\n                            failureCallbackFunction,\\n                            extraData\\n                        )\\n                    )\\n                );\\n            }\\n        }\\n        // IF we have gotten here, the 'real' target does not revert with an `OffchainLookup` error\\n        // figure out what callback to call\\n        bytes4 callbackFunction = ok\\n            ? successCallbackFunction\\n            : failureCallbackFunction;\\n        if (callbackFunction != IDENTITY_FUNCTION) {\\n            // The exit point of this architecture is OUR callback in the 'real'\\n            // We pass through the response to that callback\\n            (ok, v) = address(this).staticcall(\\n                abi.encodeWithSelector(callbackFunction, v, extraData)\\n            );\\n        }\\n        // OR the call to the 'real' target reverts with a different error selector\\n        // OR the call to OUR callback reverts with ANY error selector\\n        if (ok) {\\n            assembly {\\n                return(add(v, 32), mload(v))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(v, 32), mload(v))\\n            }\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipRead()`.\\n    /// @param response The response from offchain.\\n    /// @param extraData The contextual data passed from `ccipRead()`.\\n    /// @dev The return type of this function is polymorphic depending on the caller.\\n    function ccipReadCallback(\\n        bytes memory response,\\n        bytes memory extraData\\n    ) external view {\\n        Context memory ctx = abi.decode(extraData, (Context));\\n        // Since the callback can revert too (but has the same return structure)\\n        // We can reuse the calling infrastructure to call the callback\\n        ccipRead(\\n            ctx.target,\\n            abi.encodeWithSelector(\\n                ctx.callbackFunction,\\n                response,\\n                ctx.extraData\\n            ),\\n            ctx.successCallbackFunction,\\n            ctx.failureCallbackFunction,\\n            ctx.myExtraData\\n        );\\n    }\\n\\n    /// @dev Decode `OffchainLookup` error data into a struct.\\n    /// @param v The error data of the revert.\\n    /// @return p The decoded `OffchainLookup` params.\\n    function decodeOffchainLookup(\\n        bytes memory v\\n    ) internal pure returns (EIP3668.Params memory p) {\\n        p = EIP3668.decode(BytesUtils.substring(v, 4, v.length - 4));\\n    }\\n\\n    /// @dev Determine if `target` uses `revert()` instead of `invalid()`.\\n    //       Assumption: only newer contracts revert `OffchainLookup`.\\n    /// @param target The contract to test.\\n    /// @return safe True if safe to call.\\n    function detectEIP140(address target) internal view returns (bool safe) {\\n        if (target == address(this)) return true;\\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md\\n        assembly {\\n            let G := 5000\\n            let g := gas()\\n            pop(staticcall(G, target, 0, 0, 0, 0))\\n            safe := lt(sub(g, gas()), G)\\n        }\\n    }\\n\\n    /// @dev Same as `staticcall()` but prevents OOG when not `safe`.\\n    function safeCall(\\n        bool safe,\\n        address target,\\n        bytes memory call\\n    ) internal view returns (bool ok, bytes memory v) {\\n        (ok, v) = target.staticcall{gas: safe ? gasleft() : unsafeCallGas}(\\n            call\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xa6f483e89e779385c2b7ea6376d92cd3c05c98f91d1a3c7c43dc7422fe6b014f\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/EIP3668.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev https://eips.ethereum.org/EIPS/eip-3668\\n/// Error selector: `0x556f1830`\\nerror OffchainLookup(\\n    address sender,\\n    string[] urls,\\n    bytes callData,\\n    bytes4 callbackFunction,\\n    bytes extraData\\n);\\n\\n/// @dev Simple library for decoding `OffchainLookup` error data.\\n/// Avoids \\\"stack too deep\\\" issues as the natural decoding consumes 5 variables.\\nlibrary EIP3668 {\\n    /// @dev Struct with members matching `OffchainLookup`.\\n    struct Params {\\n        address sender;\\n        string[] urls;\\n        bytes callData;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n    }\\n\\n    /// @dev Decode an `OffchainLookup` into a struct from the data after the error selector.\\n    function decode(bytes memory v) internal pure returns (Params memory p) {\\n        (p.sender, p.urls, p.callData, p.callbackFunction, p.extraData) = abi\\n            .decode(v, (address, string[], bytes, bytes4, bytes));\\n    }\\n}\\n\",\"keccak256\":\"0x14619de0f3d9f085e6209767b35c2888b8d2af6d787af535f30db7b51e843bf8\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IBatchGateway.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for Batch Gateway Offchain Lookup Protocol.\\n///         https://docs.ens.domains/ensip/21/\\n/// @dev Interface selector: `0xa780bab6`\\ninterface IBatchGateway {\\n    /// @notice An HTTP error occurred.\\n    /// @dev Error selector: `0x01800152`\\n    error HttpError(uint16 status, string message);\\n\\n    /// @dev Information extracted from an `OffchainLookup` revert.\\n    struct Request {\\n        address sender;\\n        string[] urls;\\n        bytes data;\\n    }\\n\\n    /// @notice Perform multiple `OffchainLookup` in parallel.\\n    ///         Callers should enable EIP-3668.\\n    /// @param requests The array of requests to lookup in parallel.\\n    /// @return failures The failure status of the corresponding request.\\n    /// @return responses The response or error data of the corresponding request.\\n    function query(\\n        Request[] memory requests\\n    ) external view returns (bool[] memory failures, bytes[] memory responses);\\n}\\n\",\"keccak256\":\"0xfd7f0c7bdc29fc732ec54da2ebaea241873e55082e484729901811bc9374d6f6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IGatewayProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for shared gateway URLs.\\n/// @dev Interface selector: `0x093a86d3`\\ninterface IGatewayProvider {\\n    /// @notice Get the gateways.\\n    /// @return The gateway URLs.\\n    function gateways() external view returns (string[] memory);\\n}\\n\",\"keccak256\":\"0x7c169843cfb65657a88fb4d5f7ec44612994d7d87cb7b1a67cbfdb18758823e0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/DNSSEC.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract DNSSEC {\\n    bytes public anchors;\\n\\n    struct RRSetWithSignature {\\n        bytes rrset;\\n        bytes sig;\\n    }\\n\\n    event AlgorithmUpdated(uint8 id, address addr);\\n    event DigestUpdated(uint8 id, address addr);\\n\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input\\n    ) external view virtual returns (bytes memory rrs, uint32 inception);\\n\\n    function verifyRRSet(\\n        RRSetWithSignature[] memory input,\\n        uint256 now\\n    ) public view virtual returns (bytes memory rrs, uint32 inception);\\n}\\n\",\"keccak256\":\"0xee6a236a59e5db8418c98ee4640a91987d26533c02d305cc6c7a37a3ac4ee907\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/IDNSGateway.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {DNSSEC} from \\\"./DNSSEC.sol\\\";\\n\\n/// @notice Interface for the offchain DNSSEC oracle gateway.\\n///         https://docs.ens.domains/ensip/17#dnssec-gateway-api\\n/// @dev Interface selector: `0x31b137b9`\\ninterface IDNSGateway {\\n    /// @dev Fetch verifiable DNSSEC resource records of a specific type for a name.\\n    /// @param name The DNS-encoded name.\\n    /// @param qtype The DNS record query type according to RFC-1034.\\n    /// @return The list of verifiable DNS resource records according to RFC-4035.\\n    function resolve(\\n        bytes memory name,\\n        uint16 qtype\\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\\n}\\n\",\"keccak256\":\"0x020c5ced30e6d5a537515c58fda91cfde483a1431d803f543bb2e63b1bc0eb81\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/// @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /// @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return The length of the DNS name at 'offset', in bytes.\\n    function nameLength(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint256 labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /// @dev Returns a DNS format name at the specified offset of self.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return ret The name.\\n    function readName(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes memory ret) {\\n        uint256 len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /// @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n    /// @param self The byte array to read a name from.\\n    /// @param offset The offset to start reading at.\\n    /// @return The number of labels in the DNS name at 'offset', in bytes.\\n    function labelCount(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint256 labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint256 constant RRSIG_TYPE = 0;\\n    uint256 constant RRSIG_ALGORITHM = 2;\\n    uint256 constant RRSIG_LABELS = 3;\\n    uint256 constant RRSIG_TTL = 4;\\n    uint256 constant RRSIG_EXPIRATION = 8;\\n    uint256 constant RRSIG_INCEPTION = 12;\\n    uint256 constant RRSIG_KEY_TAG = 16;\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(\\n        bytes memory data\\n    ) internal pure returns (SignedSet memory self) {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\n        );\\n    }\\n\\n    function rrs(\\n        SignedSet memory rrset\\n    ) internal pure returns (RRIterator memory) {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /// @dev An iterator over resource records.\\n    struct RRIterator {\\n        bytes data;\\n        uint256 offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint256 rdataOffset;\\n        uint256 nextOffset;\\n    }\\n\\n    /// @dev Begins iterating over resource records.\\n    /// @param self The byte string to read from.\\n    /// @param offset The offset to start reading at.\\n    /// @return ret An iterator object.\\n    function iterateRRs(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (RRIterator memory ret) {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /// @dev Returns true iff there are more RRs to iterate.\\n    /// @param iter The iterator to check.\\n    /// @return True iff the iterator has finished.\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /// @dev Moves the iterator to the next resource record.\\n    /// @param iter The iterator to advance.\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint256 rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /// @dev Returns the name of the current record.\\n    /// @param iter The iterator.\\n    /// @return A new bytes object containing the owner name from the RR.\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.offset,\\n                nameLength(iter.data, iter.offset)\\n            );\\n    }\\n\\n    /// @dev Returns the rdata portion of the current record.\\n    /// @param iter The iterator.\\n    /// @return A new bytes object containing the RR's RDATA.\\n    function rdata(\\n        RRIterator memory iter\\n    ) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.rdataOffset,\\n                iter.nextOffset - iter.rdataOffset\\n            );\\n    }\\n\\n    uint256 constant DNSKEY_FLAGS = 0;\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\n    uint256 constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(\\n            offset + DNSKEY_PUBKEY,\\n            length - DNSKEY_PUBKEY\\n        );\\n    }\\n\\n    uint256 constant DS_KEY_TAG = 0;\\n    uint256 constant DS_ALGORITHM = 2;\\n    uint256 constant DS_DIGEST_TYPE = 3;\\n    uint256 constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    function isSubdomainOf(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        uint256 off = 0;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        while (counts > othercounts) {\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        return self.equals(off, other, 0);\\n    }\\n\\n    function compareNames(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (int256) {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint256 off;\\n        uint256 otheroff;\\n        uint256 prevoff;\\n        uint256 otherprevoff;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if (otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return\\n            self.compare(\\n                prevoff + 1,\\n                self.readUint8(prevoff),\\n                other,\\n                otherprevoff + 1,\\n                other.readUint8(otherprevoff)\\n            );\\n    }\\n\\n    /// @dev Compares two serial numbers using RFC1982 serial number math.\\n    function serialNumberGte(\\n        uint32 i1,\\n        uint32 i2\\n    ) internal pure returns (bool) {\\n        unchecked {\\n            return int32(i1) - int32(i2) >= 0;\\n        }\\n    }\\n\\n    function progress(\\n        bytes memory body,\\n        uint256 off\\n    ) internal pure returns (uint256) {\\n        return off + 1 + body.readUint8(off);\\n    }\\n\\n    /// @dev Computes the keytag for a chunk of data.\\n    /// @param data The data to compute a keytag for.\\n    /// @return The computed key tag.\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n        /* This function probably deserves some explanation.\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\n         *\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n         *         uint ac;\\n         *         for (uint i = 0; i < data.length; i++) {\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\n         *         }\\n         *         return uint16(ac + (ac >> 16));\\n         *     }\\n         *\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\n         * large words work in our favour.\\n         *\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\n         *\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\n         * and the remaining sums can be done just on ac1.\\n         */\\n        unchecked {\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\n            uint256 ac1;\\n            uint256 ac2;\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(add(add(data, 32), i))\\n                }\\n                if (i + 32 > data.length) {\\n                    uint256 unused = 256 - (data.length - i) * 8;\\n                    word = (word >> unused) << unused;\\n                }\\n                ac1 +=\\n                    (word &\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\n                    8;\\n                ac2 += (word &\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\n            }\\n            ac1 =\\n                (ac1 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac1 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac2 =\\n                (ac2 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac2 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac1 = (ac1 << 8) + ac2;\\n            ac1 =\\n                (ac1 &\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\n                    32);\\n            ac1 =\\n                (ac1 &\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\n                    64);\\n            ac1 =\\n                (ac1 &\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\n                (ac1 >> 128);\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\n            return uint16(ac1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdbab10dde632a1a02ee1c706bd4a31f9fb6195bd15a360528f7f6615e8fc895a\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8e208b44d5dbf22552fe72d79b45c640855b84fbc9ee21f4c3bb4bfe81cbe8db\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/IMulticallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n\\n    function multicallWithNodeCheck(\\n        bytes32,\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x0334202e20bb11995997083d05963f5e8e7ed6194cba494e7f9371ab7bf4e2c3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/ResolverFeatures.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary ResolverFeatures {\\n    /// @notice Implements `resolve(multicall([...]))`.\\n    /// @dev Feature: `0x96b62db8`\\n    bytes4 constant RESOLVE_MULTICALL =\\n        bytes4(keccak256(\\\"eth.ens.resolver.extended.multicall\\\"));\\n\\n    /// @notice Returns the same records independent of name or node.\\n    /// @dev Feature: `0x86fb8da8`\\n    bytes4 constant SINGULAR = bytes4(keccak256(\\\"eth.ens.resolver.singular\\\"));\\n}\\n\",\"keccak256\":\"0x87d131fcbdd7951a17b0a94f7f02470ec3f62c6004cf91c2d2acc54098373be6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the legacy (ETH-only) addr function.\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /// Returns the address associated with an ENS node.\\n    /// @param node The ENS node to query.\\n    /// @return The associated address.\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/ICompositeResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport {IExtendedResolver} from \\\"./IExtendedResolver.sol\\\";\\n\\n/// @notice A resolver that calls other resolvers.\\n/// @dev Interface selector: `0xc7e45d73`\\ninterface ICompositeResolver is IExtendedResolver {\\n    /// @notice Fetch the underlying resolver for `name`.\\n    ///         Callers should enable EIP-3668.\\n    ///\\n    /// * If `offchain`, additional information is necessary to locate `resolver`.\\n    /// * If `resolver` is null, `offchain` is irrelevant.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return resolver The underlying resolver address.\\n    /// @return offchain `true` if `resolver` is offchain.\\n    function getResolver(\\n        bytes memory name\\n    ) external view returns (address resolver, bool offchain);\\n\\n    /// @notice Determine if resolving `name` requires offchain data.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return `true` if requires offchain data.\\n    function requiresOffchain(bytes calldata name) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x772398a485be2c5c729cd3504108a7698f746a445a0cdf5b18248e00378e3786\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedDNSResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedDNSResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data,\\n        bytes memory context\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x541f8799c34ff9e7035d09f06ae0f0f8a16b6065e9b60a15670b957321630f72\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IVerifiableResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// @notice A resolver that uses a verifier.\\n/// @dev Interface selector: `0xed57d294`\\ninterface IVerifiableResolver {\\n    /// @notice The verifier contract has changed.\\n    ///         Use `0x00` for any name.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param verifier The new verifier contract.\\n    event VerifierChanged(bytes name, address verifier);\\n\\n    /// @notice Get information about the verification process.\\n    ///         Use ERC-165 to determine the verifier type.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return verifier The verifier contract.\\n    /// @return gateways The gateways used by the verifier.\\n    function verifierMetadata(\\n        bytes memory name\\n    ) external view returns (address verifier, string[] memory gateways);\\n}\\n\",\"keccak256\":\"0xce406ff5781062cb506bc4dae904bafa93afe1b0745c00deb767929c209c3989\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/RegistryUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ENS} from \\\"../registry/ENS.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nlibrary RegistryUtils {\\n    /// @notice Find the resolver for `name[offset:]`.\\n    /// @dev Reverts `DNSDecodingFailed`.\\n    /// @param registry The ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    /// @return resolver The resolver or `address(0)` if not found.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return resolverOffset The offset into `name` corresponding to `resolver`.\\n    function findResolver(\\n        ENS registry,\\n        bytes memory name,\\n        uint256 offset\\n    )\\n        internal\\n        view\\n        returns (address resolver, bytes32 node, uint256 resolverOffset)\\n    {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (\\n                address parentResolver,\\n                bytes32 parentNode,\\n                uint256 parentOffset\\n            ) = findResolver(registry, name, next);\\n            node = NameCoder.namehash(parentNode, labelHash);\\n            resolver = registry.resolver(node);\\n            return\\n                resolver != address(0)\\n                    ? (resolver, node, offset)\\n                    : (parentResolver, node, parentOffset);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x050dd0e2823fc92df8a29f4516c5af22dcd42cd7c7fbd88d852fb330939285c7\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/ResolverCaller.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ERC165Checker\\n} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {CCIPBatcher} from \\\"../ccipRead/CCIPBatcher.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\nimport {IERC7996} from \\\"../utils/IERC7996.sol\\\";\\nimport {ResolverFeatures} from \\\"../resolvers/ResolverFeatures.sol\\\";\\n\\n// resolver profiles\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {\\n    IExtendedDNSResolver\\n} from \\\"../resolvers/profiles/IExtendedDNSResolver.sol\\\";\\nimport {IMulticallable} from \\\"../resolvers/IMulticallable.sol\\\";\\n\\nabstract contract ResolverCaller is CCIPBatcher {\\n    /// @dev `name` cannot be resolved.\\n    ///      Error selector: `0x5fe9a5df`\\n    /// @param name The DNS-encoded ENS name.\\n    error UnreachableName(bytes name);\\n\\n    /// @notice Perform forward resolution.\\n    ///\\n    /// Call this function with `ccipRead()` to intercept the response.\\n    /// Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers.\\n    ///\\n    /// - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,\\n    ///   the call is performed directly without the batch gateway.\\n    /// - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,\\n    ///   the call is performed directly without the batch gateway.\\n    /// - Otherwise, the call is performed with the batch gateway.\\n    ///   The batch gateway is only invoked if any call reverts `OffchainLookup`.\\n    ///   If the calldata is `multicall()` it is disassembled, called separately, and reassembled.\\n    ///\\n    /// @dev Reverts `UnreachableName` if resolver is not a contract.\\n\\t///      This function never returns normally.\\n\\t///      The return type is necessary to define the result of the callback.\\n\\t///      Call this function externally or with `ccipRead()` to intercept the response.\\n    /// @param resolver The resolver to call.\\n    /// @param name The DNS-encoded ENS name.\\n    /// @param data The calldata for the resolution.\\n    /// @param hasContext True if `IExtendedDNSResolver` should be considered.\\n    /// @param context The context for `IExtendedDNSResolver`.\\n    /// @param batchGateways The batch gateway URLs.\\n    function callResolver(\\n        address resolver,\\n        bytes memory name,\\n        bytes memory data,\\n        bool hasContext,\\n        bytes memory context,\\n        string[] memory batchGateways\\n    ) public view returns (bytes memory) {\\n        if (resolver.code.length == 0) {\\n            revert UnreachableName(name);\\n        }\\n        bool multi = bytes4(data) == IMulticallable.multicall.selector;\\n        bool extendedDNS = hasContext &&\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IExtendedDNSResolver).interfaceId\\n            );\\n        bool extended = extendedDNS ||\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IExtendedResolver).interfaceId\\n            );\\n        if (\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IERC7996).interfaceId\\n            ) &&\\n            (!multi ||\\n                (extended &&\\n                    IERC7996(resolver).supportsFeature(\\n                        ResolverFeatures.RESOLVE_MULTICALL\\n                    )))\\n        ) {\\n            if (extended) {\\n                // resolve() has the same return signature as callResolver()\\n                ccipRead(\\n                    resolver,\\n                    _makeExtendedCall(extendedDNS, name, data, context)\\n                );\\n            } else {\\n                ccipRead(\\n                    resolver,\\n                    data,\\n                    this.resolveDirectImmediateCallback.selector, // ==> step 2\\n                    IDENTITY_FUNCTION,\\n                    \\\"\\\"\\n                );\\n            }\\n        }\\n        bytes[] memory calls;\\n        if (multi) {\\n            calls = abi.decode(\\n                BytesUtils.substring(data, 4, data.length - 4),\\n                (bytes[])\\n            );\\n        } else {\\n            calls = new bytes[](1);\\n            calls[0] = data;\\n        }\\n        if (extended) {\\n            for (uint256 i; i < calls.length; ++i) {\\n                calls[i] = _makeExtendedCall(\\n                    extendedDNS,\\n                    name,\\n                    calls[i],\\n                    context\\n                );\\n            }\\n        }\\n        ccipRead(\\n            address(this),\\n            abi.encodeCall(\\n                this.ccipBatch,\\n                (createBatch(resolver, calls, batchGateways))\\n            ),\\n            this.resolveBatchCallback.selector, // ==> step 2\\n            IDENTITY_FUNCTION,\\n            abi.encode(multi, extended)\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `callResolver()` from direct calling an immediate resolver.\\n    function resolveDirectImmediateCallback(\\n        bytes calldata response,\\n        bytes calldata\\n    ) external pure returns (bytes calldata) {\\n        return response; // the calldata was direct, so wrap it\\n    }\\n\\n    /// @dev CCIP-Read callback for `callResolver()` from batch calling a resolver.\\n    /// @param response The response data from the batch gateway.\\n    /// @param extraData The abi-encoded properties of the call.\\n    /// @return result The response from the resolver.\\n    function resolveBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external pure returns (bytes memory) {\\n        Lookup[] memory lookups = abi.decode(response, (Batch)).lookups;\\n        (bool multi, bool extended) = abi.decode(extraData, (bool, bool));\\n        if (multi) {\\n            bytes[] memory m = new bytes[](lookups.length);\\n            for (uint256 i; i < lookups.length; ++i) {\\n                Lookup memory lu = lookups[i];\\n                bytes memory v = lu.data;\\n                if (extended && (lu.flags & FLAGS_ANY_ERROR) == 0) {\\n                    v = abi.decode(v, (bytes)); // unwrap resolve()\\n                }\\n                m[i] = v;\\n            }\\n            return abi.encode(m);\\n        } else {\\n            Lookup memory lu = lookups[0];\\n            bytes memory v = lu.data;\\n            if ((lu.flags & FLAGS_ANY_ERROR) != 0) {\\n                assembly {\\n                    revert(add(v, 32), mload(v))\\n                }\\n            }\\n            if (extended) {\\n                v = abi.decode(v, (bytes)); // unwrap resolve()\\n            }\\n            return v;\\n        }\\n    }\\n\\n    /// @dev Create extended resolver calldata.\\n    function _makeExtendedCall(\\n        bool extendedDNS,\\n        bytes memory name,\\n        bytes memory call,\\n        bytes memory context\\n    ) internal pure returns (bytes memory) {\\n        return\\n            extendedDNS\\n                ? abi.encodeCall(\\n                    IExtendedDNSResolver.resolve,\\n                    (name, call, context)\\n                )\\n                : abi.encodeCall(IExtendedResolver.resolve, (name, call));\\n    }\\n}\\n\",\"keccak256\":\"0x38307321fb62ccee51f3ea2241c018aba1822e758c05ae7e228a760949c26848\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary HexUtils {\\n    /// @dev Convert `hexString[off:end]` to `bytes32`.\\n    ///      Accepts 0-64 hex-chars.\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return word The parsed bytes32.\\n    /// @return valid True if the parse was successful.\\n    function hexStringToBytes32(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes32 word, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        if (nibbles > 64 || end > hexString.length) {\\n            return (bytes32(0), false); // too large or out of bounds\\n        }\\n        uint256 src;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n        }\\n        valid = unsafeBytes(src, 0, nibbles);\\n        assembly {\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\n            word := shr(shl(3, pad), mload(0)) // right align\\n        }\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `address`.\\n    ///      Accepts exactly 40 hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return addr The parsed address.\\n    /// @return valid True if the parse was successful.\\n    function hexToAddress(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (address addr, bool valid) {\\n        if (off + 40 != end) return (address(0), false); // wrong length\\n        bytes32 word;\\n        (word, valid) = hexStringToBytes32(hexString, off, end);\\n        addr = address(uint160(uint256(word)));\\n    }\\n\\n    /// @dev Convert `hexString[off:end]` to `bytes`.\\n    ///      Accepts 0+ hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param off The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return v The parsed bytes.\\n    /// @return valid True if the parse was successful.\\n    function hexToBytes(\\n        bytes memory hexString,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes memory v, bool valid) {\\n        if (end < off) return (\\\"\\\", false); // invalid range\\n        uint256 nibbles = end - off;\\n        v = new bytes((1 + nibbles) >> 1); // round up\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(add(hexString, 32), off)\\n            dst := add(v, 32)\\n        }\\n        valid = unsafeBytes(src, dst, nibbles);\\n    }\\n\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\n    ///      Matches: `/^[0-9a-f]*$/i`.\\n    /// @param src The memory offset of first hex-char of input.\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\n    /// @param nibbles The number of hex-chars to convert.\\n    /// @return valid True if all characters were hex.\\n    function unsafeBytes(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure returns (bool valid) {\\n        assembly {\\n            function getHex(c, i) -> ascii {\\n                c := byte(i, c)\\n                // chars 48-57: 0-9\\n                if and(gt(c, 47), lt(c, 58)) {\\n                    ascii := sub(c, 48)\\n                    leave\\n                }\\n                // chars 65-70: A-F\\n                if and(gt(c, 64), lt(c, 71)) {\\n                    ascii := add(sub(c, 65), 10)\\n                    leave\\n                }\\n                // chars 97-102: a-f\\n                if and(gt(c, 96), lt(c, 103)) {\\n                    ascii := add(sub(c, 97), 10)\\n                    leave\\n                }\\n                // invalid char\\n                ascii := 0x100\\n            }\\n            valid := true\\n            let end := add(src, nibbles)\\n            if and(nibbles, 1) {\\n                let b := getHex(mload(src), 0) // \\\"f\\\" -> 15\\n                mstore8(dst, b) // write ascii byte\\n                src := add(src, 1) // update pointers\\n                dst := add(dst, 1)\\n                if gt(b, 255) {\\n                    valid := false\\n                    src := end // terminate loop\\n                }\\n            }\\n            // prettier-ignore\\n            for {} lt(src, end) {\\n                src := add(src, 2) // 2 nibbles\\n                dst := add(dst, 1) // per byte\\n            } {\\n                let word := mload(src) // read word (left aligned)\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\"ff\\\" -> 255\\n                if gt(b, 255) {\\n                    valid := false\\n                    break\\n                }\\n                mstore8(dst, b) // write ascii byte\\n            }\\n        }\\n    }\\n\\n    /// @dev Format `address` as a hex string.\\n    /// @param addr The address to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function addressToHex(\\n        address addr\\n    ) internal pure returns (string memory hexString) {\\n        // return bytesToHex(abi.encodePacked(addr));\\n        hexString = new string(40);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, addr)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(12, dst, 40);\\n    }\\n\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\n    /// * unpaddedUintToHex(0, true)  = \\\"0\\\"\\n    /// * unpaddedUintToHex(1, true)  = \\\"1\\\"\\n    /// * unpaddedUintToHex(0, false) = \\\"00\\\"\\n    /// * unpaddedUintToHex(1, false) = \\\"01\\\"\\n    /// @param value The number to format.\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\n    function unpaddedUintToHex(\\n        uint256 value,\\n        bool dropZeroNibble\\n    ) internal pure returns (string memory hexString) {\\n        uint256 temp = value;\\n        uint256 shift;\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\n            if (temp < (1 << b)) {\\n                shift += b; // number of zero upper bits\\n            } else {\\n                temp >>= b; // shift away lower half\\n            }\\n        }\\n        if (dropZeroNibble && temp < 16) shift += 4;\\n        uint256 nibbles = 64 - (shift >> 2);\\n        hexString = new string(nibbles);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, shl(shift, value)) // left-align\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(0, dst, nibbles);\\n    }\\n\\n    /// @dev Format `bytes` as a hex string.\\n    /// @param v The bytes to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function bytesToHex(\\n        bytes memory v\\n    ) internal pure returns (string memory hexString) {\\n        uint256 nibbles = v.length << 1;\\n        hexString = new string(nibbles);\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(v, 32)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(src, dst, nibbles);\\n    }\\n\\n    /// @dev Converts arbitrary memory to a hex string.\\n    /// @param src The memory offset of first nibble of input.\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\n    function unsafeHex(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure {\\n        unchecked {\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(src)\\n                }\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\"a\\\" - 10) => 0x57\\n                    assembly {\\n                        mstore8(dst, b)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab784cab15b7a06154be3555edf0d25bcdad8e6bf116aa2016119a233875b02b\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/IERC7996.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for expressing contract features not visible from the ABI.\\n/// @dev Interface selector: `0x582de3e7`\\ninterface IERC7996 {\\n    /// @notice Check if a feature is supported.\\n    /// @param featureId The feature identifier.\\n    /// @return `true` if the feature is supported by the contract.\\n    function supportsFeature(bytes4 featureId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf499a48e4e879ec7775f375d2cb5af047720ab6ae4b6f89a40a578c4e0f51631\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5a08ad61f4e82b8a3323562661a86fb10b10190848073fdc13d4ac43710ffba5\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the zero address.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1d7a05b3219532ea5ece50a80cf390cac9109dc74e07763adfa463ab5a3af0dc\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"project/src/dns/DNSTLDResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.24;\\n\\nimport {CCIPReader, OffchainLookup} from \\\"@ens/contracts/ccipRead/CCIPBatcher.sol\\\";\\nimport {IGatewayProvider} from \\\"@ens/contracts/ccipRead/IGatewayProvider.sol\\\";\\nimport {DNSSEC} from \\\"@ens/contracts/dnssec-oracle/DNSSEC.sol\\\";\\nimport {IDNSGateway} from \\\"@ens/contracts/dnssec-oracle/IDNSGateway.sol\\\";\\nimport {RRUtils} from \\\"@ens/contracts/dnssec-oracle/RRUtils.sol\\\";\\nimport {IAddrResolver} from \\\"@ens/contracts/resolvers/profiles/IAddrResolver.sol\\\";\\nimport {ICompositeResolver} from \\\"@ens/contracts/resolvers/profiles/ICompositeResolver.sol\\\";\\nimport {IExtendedResolver} from \\\"@ens/contracts/resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IVerifiableResolver} from \\\"@ens/contracts/resolvers/profiles/IVerifiableResolver.sol\\\";\\nimport {ResolverFeatures} from \\\"@ens/contracts/resolvers/ResolverFeatures.sol\\\";\\nimport {\\n    RegistryUtils as RegistryUtilsV1,\\n    ENS\\n} from \\\"@ens/contracts/universalResolver/RegistryUtils.sol\\\";\\nimport {ResolverCaller} from \\\"@ens/contracts/universalResolver/ResolverCaller.sol\\\";\\nimport {BytesUtils} from \\\"@ens/contracts/utils/BytesUtils.sol\\\";\\nimport {HexUtils} from \\\"@ens/contracts/utils/HexUtils.sol\\\";\\nimport {IERC7996} from \\\"@ens/contracts/utils/IERC7996.sol\\\";\\nimport {NameCoder} from \\\"@ens/contracts/utils/NameCoder.sol\\\";\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport {LibRegistry, IRegistry} from \\\"../universalResolver/libraries/LibRegistry.sol\\\";\\n\\n/// @dev DNS class for the \\\"Internet\\\" according to RFC-1035.\\nuint16 constant CLASS_INET = 1;\\n\\n/// @dev DNS query/resource type for TXT according to RFC-1035.\\nuint16 constant QTYPE_TXT = 16;\\n\\n/// @dev DNS TXT record prefix for ENS data.\\nbytes constant TXT_PREFIX = \\\"ENS1 \\\";\\n\\n/// @notice Resolver that performs imported DNS fallback to V1 and gasless DNS resolution.\\n///\\n/// 0. Note: an imported DNS name will not reach this resolver unless set specifically.\\n/// 1. If there exists a resolver in V1, go to 4.\\n/// 2. Query the DNSSEC oracle for TXT records.\\n/// 3. Verify TXT records, find ENS1 record, parse resolver and context.\\n/// 4. Call the resolver and return the requested records.\\n///\\ncontract DNSTLDResolver is\\n    IERC7996,\\n    ICompositeResolver,\\n    IVerifiableResolver,\\n    ResolverCaller,\\n    ERC165\\n{\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n    ENS public immutable ENS_REGISTRY_V1;\\n\\n    address public immutable DNS_TLD_RESOLVER_V1;\\n\\n    IRegistry public immutable ROOT_REGISTRY;\\n\\n    DNSSEC public immutable DNSSEC_ORACLE;\\n\\n    /// @dev Shared DNSSEC oracle gateway provider.\\n    IGatewayProvider public immutable ORACLE_GATEWAY_PROVIDER;\\n\\n    /// @dev Shared batch gateway provider.\\n    IGatewayProvider public immutable BATCH_GATEWAY_PROVIDER;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Some raw TXT data was incorrectly encoded.\\n    /// @dev Error selector: `0xf4ba19b7`\\n    error InvalidTXT();\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        ENS ensRegistryV1,\\n        address dnsTLDResolverV1,\\n        IRegistry rootRegistry,\\n        DNSSEC dnssecOracle,\\n        IGatewayProvider oracleGatewayProvider,\\n        IGatewayProvider batchGatewayProvider\\n    ) CCIPReader(DEFAULT_UNSAFE_CALL_GAS) {\\n        ENS_REGISTRY_V1 = ensRegistryV1;\\n        DNS_TLD_RESOLVER_V1 = dnsTLDResolverV1;\\n        ROOT_REGISTRY = rootRegistry;\\n        DNSSEC_ORACLE = dnssecOracle;\\n        ORACLE_GATEWAY_PROVIDER = oracleGatewayProvider;\\n        BATCH_GATEWAY_PROVIDER = batchGatewayProvider;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165) returns (bool) {\\n        return\\n            type(IExtendedResolver).interfaceId == interfaceId ||\\n            type(ICompositeResolver).interfaceId == interfaceId ||\\n            type(IVerifiableResolver).interfaceId == interfaceId ||\\n            type(IERC7996).interfaceId == interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc IERC7996\\n    function supportsFeature(bytes4 feature) public pure returns (bool) {\\n        return ResolverFeatures.RESOLVE_MULTICALL == feature;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Fetch the DNSSEC TXT record.\\n    ///         Callers should enable EIP-3668.\\n    ///\\n    /// @dev This function executes over multiple steps.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The verified DNSSEC TXT records.\\n    function getDNSSECRecords(bytes calldata name) external view returns (bytes[] memory) {\\n        address resolver = _determineMainnetResolver(name);\\n        if (resolver != address(0)) {\\n            return new bytes[](0);\\n        }\\n        revert OffchainLookup(\\n            address(this),\\n            ORACLE_GATEWAY_PROVIDER.gateways(),\\n            abi.encodeCall(IDNSGateway.resolve, (name, QTYPE_TXT)),\\n            this.getDNSSECRecordsCallback.selector, // ==> step 2\\n            name\\n        );\\n    }\\n\\n    /// @notice CCIP-Read callback for `getDNSSECRecords()`.\\n    function getDNSSECRecordsCallback(\\n        bytes calldata response,\\n        bytes calldata name\\n    ) external view returns (bytes[] memory txts) {\\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\\n            response,\\n            (DNSSEC.RRSetWithSignature[])\\n        );\\n        (bytes memory data, ) = DNSSEC_ORACLE.verifyRRSet(rrsets);\\n        uint256 i;\\n        for (\\n            RRUtils.RRIterator memory iter = RRUtils.iterateRRs(data, 0);\\n            !RRUtils.done(iter);\\n            RRUtils.next(iter)\\n        ) {\\n            if (_isTXTForName(iter, name)) {\\n                ++i;\\n            }\\n        }\\n        txts = new bytes[](i);\\n        i = 0;\\n        for (\\n            RRUtils.RRIterator memory iter = RRUtils.iterateRRs(data, 0);\\n            !RRUtils.done(iter);\\n            RRUtils.next(iter)\\n        ) {\\n            if (_isTXTForName(iter, name)) {\\n                txts[i++] = _readTXT(iter.data, iter.rdataOffset, iter.nextOffset);\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IVerifiableResolver\\n    function verifierMetadata(\\n        bytes calldata name\\n    ) external view returns (address verifier, string[] memory gateways) {\\n        if (_determineMainnetResolver(name) == address(0)) {\\n            verifier = address(DNSSEC_ORACLE);\\n            gateways = ORACLE_GATEWAY_PROVIDER.gateways();\\n        }\\n    }\\n\\n    /// @inheritdoc ICompositeResolver\\n    function requiresOffchain(bytes calldata name) external view returns (bool offchain) {\\n        offchain = _determineMainnetResolver(name) == address(0);\\n    }\\n\\n    /// @inheritdoc ICompositeResolver\\n    /// @dev This function executes over multiple steps.\\n    function getResolver(bytes calldata name) external view returns (address, bool) {\\n        address resolver = _determineMainnetResolver(name);\\n        if (resolver != address(0)) {\\n            return (resolver, false);\\n        }\\n        revert OffchainLookup(\\n            address(this),\\n            ORACLE_GATEWAY_PROVIDER.gateways(),\\n            abi.encodeCall(IDNSGateway.resolve, (name, QTYPE_TXT)),\\n            this.getResolverCallback.selector, // ==> step 2\\n            name\\n        );\\n    }\\n\\n    /// @notice CCIP-Read callback for `getResolver()`.\\n    function getResolverCallback(\\n        bytes calldata response,\\n        bytes calldata name\\n    ) external view returns (address, bool) {\\n        (address resolver, ) = _verifyDNSSEC(name, response);\\n        return (resolver, true);\\n    }\\n\\n    /// @notice Resolve `name` using V1 or DNSSEC.\\n    ///         Caller should enable EIP-3668.\\n    ///\\n    /// @dev This function executes over multiple steps.\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory) {\\n        address resolver = _determineMainnetResolver(name);\\n        if (resolver != address(0)) {\\n            return callResolver(resolver, name, data, false, \\\"\\\", BATCH_GATEWAY_PROVIDER.gateways()); // ==> step 2\\n        }\\n        revert OffchainLookup(\\n            address(this),\\n            ORACLE_GATEWAY_PROVIDER.gateways(),\\n            abi.encodeCall(IDNSGateway.resolve, (name, QTYPE_TXT)),\\n            this.resolveOracleCallback.selector, // ==> step 2\\n            abi.encode(name, data)\\n        );\\n    }\\n\\n    /// @notice CCIP-Read callback for `resolve()` from calling the DNSSEC oracle.\\n    ///         Reverts `UnreachableName` if no \\\"ENS1\\\" TXT record is found.\\n    ///\\n    /// @param response The response data.\\n    /// @param extraData The contextual data passed from `resolve()`.\\n    ///\\n    /// @return The abi-encoded result from the resolver.\\n    function resolveOracleCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (bytes memory) {\\n        (bytes memory name, bytes memory call) = abi.decode(extraData, (bytes, bytes));\\n        (address resolver, bytes memory context) = _verifyDNSSEC(name, response);\\n        if (resolver == address(0)) {\\n            revert UnreachableName(name);\\n        }\\n        return callResolver(resolver, name, call, true, context, BATCH_GATEWAY_PROVIDER.gateways()); // ==> step 3\\n    }\\n\\n    /// @notice Parse DNSSEC TXT record into parts.\\n    ///         Format: \\\"ENS1 <name-or-address> <context>\\\".\\n    ///\\n    /// @param txt The DNSSEC TXT record.\\n    ///\\n    /// @return resolver The resolver address or null if wrong format or name didn't resolve.\\n    /// @return context The context data.\\n    function parseDNSSECRecord(\\n        bytes memory txt\\n    ) public view returns (address resolver, bytes memory context) {\\n        uint256 p = TXT_PREFIX.length;\\n        uint256 n = txt.length;\\n        if (n > p && BytesUtils.equals(txt, 0, TXT_PREFIX, 0, p)) {\\n            uint256 sep = BytesUtils.find(txt, p, n - p, \\\" \\\");\\n            if (sep < n) {\\n                context = BytesUtils.substring(txt, sep + 1, n - sep - 1);\\n            } else {\\n                sep = n;\\n            }\\n            resolver = _parseResolver(BytesUtils.substring(txt, p, sep - p));\\n        }\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Internal Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Determine underlying Mainnet resolver or null if not found.\\n    function _determineMainnetResolver(bytes memory name) internal view returns (address resolver) {\\n        (resolver, , ) = RegistryUtilsV1.findResolver(ENS_REGISTRY_V1, name, 0);\\n        if (resolver == DNS_TLD_RESOLVER_V1 || resolver == address(this)) {\\n            resolver = address(0);\\n        }\\n    }\\n\\n    /// @dev Verify DNSSEC TXT record.\\n    //       Returns the first non-zero resolver.\\n    function _verifyDNSSEC(\\n        bytes memory name,\\n        bytes calldata oracleWitness\\n    ) internal view returns (address resolver, bytes memory context) {\\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\\n            oracleWitness,\\n            (DNSSEC.RRSetWithSignature[])\\n        );\\n        (bytes memory data, ) = DNSSEC_ORACLE.verifyRRSet(rrsets);\\n        for (\\n            RRUtils.RRIterator memory iter = RRUtils.iterateRRs(data, 0);\\n            !RRUtils.done(iter);\\n            RRUtils.next(iter)\\n        ) {\\n            if (_isTXTForName(iter, name)) {\\n                (resolver, context) = parseDNSSECRecord(\\n                    _readTXT(iter.data, iter.rdataOffset, iter.nextOffset)\\n                );\\n                if (resolver != address(0)) {\\n                    break; // https://github.com/ensdomains/ens-contracts/blob/289913d7e3923228675add09498d66920216fe9b/contracts/dnsregistrar/OffchainDNSResolver.sol#L111\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Parse the value into a resolver address.\\n    ///      If the value matches `/^0x[0-9a-fA-F]{40}$/`, it's a literal address.\\n    ///      Otherwise, it's considered a name and resolved in the registry.\\n    ///      Reverts `DNSEncodingFailed` if the name cannot be encoded.\\n    ///\\n    /// @param v The address or name.\\n    ///\\n    /// @return resolver The corresponding resolver address.\\n    function _parseResolver(bytes memory v) internal view returns (address resolver) {\\n        if (v.length == 42 && bytes2(v) == \\\"0x\\\") {\\n            (address addr, bool valid) = HexUtils.hexToAddress(v, 2, 42);\\n            if (valid) {\\n                return addr;\\n            }\\n        }\\n        bytes memory name = NameCoder.encode(string(v));\\n        (, address r, , ) = LibRegistry.findResolver(ROOT_REGISTRY, name, 0);\\n        if (r != address(0)) {\\n            // according to V1, this must be immediate onchain\\n            try IAddrResolver(r).addr(NameCoder.namehash(name, 0)) returns (address payable a) {\\n                resolver = a;\\n            } catch {}\\n        }\\n    }\\n\\n    /// @dev Determine if the current DNSSEC record is a TXT record for `name`.\\n    function _isTXTForName(\\n        RRUtils.RRIterator memory iter,\\n        bytes memory name\\n    ) internal pure returns (bool) {\\n        return\\n            iter.class == CLASS_INET &&\\n            iter.dnstype == QTYPE_TXT &&\\n            BytesUtils.equals(iter.data, iter.offset, name, 0, name.length);\\n    }\\n\\n    /// @dev Decode `v[off:end]` as raw TXT chunks.\\n    ///      Encoding: `(byte(n) <n-bytes>)...`\\n    ///      Reverts `InvalidTXT` if the data is malformed.\\n    ///\\n    /// @param v The raw TXT data.\\n    /// @param off The offset of the record data.\\n    /// @param end The upper bound of the record data.\\n    ///\\n    /// @return txt The decoded TXT value.\\n    function _readTXT(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 end\\n    ) internal pure returns (bytes memory txt) {\\n        if (end > v.length) revert InvalidTXT();\\n        txt = new bytes(end - off);\\n        assembly {\\n            let ptr := add(v, 32)\\n            off := add(ptr, off) // start of input\\n            end := add(ptr, end) // end of input\\n            ptr := add(txt, 32) // start of output\\n            // prettier-ignore\\n            for { } lt(off, end) { } { // while input\\n                let size := byte(0, mload(off)) // length of chunk\\n                off := add(off, 1) // advance input\\n                if size { // length > 0\\n                    let next := add(off, size) // compute end of chunk\\n                    if gt(next, end) { // beyond end\\n                        end := 0 // error: overflow\\n                        break\\n                    }\\n                    mcopy(ptr, off, size) // copy chunk\\n                    off := next // advance input\\n                    ptr := add(ptr, size) // advance output\\n                }\\n            }\\n            mstore(txt, sub(ptr, add(txt, 32))) // truncate\\n        }\\n        if (off != end) revert InvalidTXT(); // overflow or junk at end\\n    }\\n}\\n\",\"keccak256\":\"0x5eb1d7477d823806ce2a907ecf0c5e7964f06b3a69cbd308f186d5bb4734bbef\",\"license\":\"MIT\"},\"project/src/erc1155/interfaces/IERC1155Singleton.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IERC1155Singleton is IERC1155 {\\n    function ownerOf(uint256 id) external view returns (address owner);\\n}\\n\",\"keccak256\":\"0xbfa4f4f1da56c42a6e878895cbcfc50d0d612ca9d75dda04c6df1ca0fdb72494\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155Singleton} from \\\"../../erc1155/interfaces/IERC1155Singleton.sol\\\";\\n\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\ninterface IRegistry is IERC1155Singleton {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Events\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev SHOULD be emitted when a new label is registered\\n    event NameRegistered(\\n        uint256 indexed tokenId,\\n        string label,\\n        uint64 expiry,\\n        address registeredBy\\n    );\\n\\n    /// @notice Expiry was changed.\\n    /// @dev Error selector: `0x`\\n    event ExpiryUpdated(uint256 indexed tokenId, uint64 newExpiry, address changedBy);\\n\\n    /// @notice Subregistry was changed.\\n    event SubregistryUpdated(uint256 indexed tokenId, IRegistry subregistry);\\n\\n    /// @notice Resolver was changed.\\n    event ResolverUpdated(uint256 indexed tokenId, address resolver);\\n\\n    /// @notice Token was regenerated with a new token ID.\\n    ///         This occurs when roles are granted or revoked to maintain ERC1155 compliance.\\n    event TokenRegenerated(\\n        uint256 indexed oldTokenId,\\n        uint256 indexed newTokenId,\\n        uint256 resource\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Fetches the registry for a subdomain.\\n     * @param label The label to resolve.\\n     * @return The address of the registry for this subdomain, or `address(0)` if none exists.\\n     */\\n    function getSubregistry(string calldata label) external view returns (IRegistry);\\n\\n    /**\\n     * @dev Fetches the resolver responsible for the specified label.\\n     * @param label The label to fetch a resolver for.\\n     * @return resolver The address of a resolver responsible for this name, or `address(0)` if none exists.\\n     */\\n    function getResolver(string calldata label) external view returns (address);\\n}\\n\",\"keccak256\":\"0xc3c7b964bbaadd35412ce44163ab335f802ac9b5f19d72b0fbb64bf772f63634\",\"license\":\"MIT\"},\"project/src/universalResolver/libraries/LibRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.24;\\n\\nimport {NameCoder} from \\\"@ens/contracts/utils/NameCoder.sol\\\";\\n\\nimport {IRegistry} from \\\"../../registry/interfaces/IRegistry.sol\\\";\\n\\nlibrary LibRegistry {\\n    /// @dev Find the resolver address for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    ///\\n    /// @return exactRegistry The exact registry or null if not exact.\\n    /// @return resolver The resolver or null if not found.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return resolverOffset The offset into `name` corresponding to `resolver`.\\n    function findResolver(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    )\\n        internal\\n        view\\n        returns (IRegistry exactRegistry, address resolver, bytes32 node, uint256 resolverOffset)\\n    {\\n        // supply <root> if end of name\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash == bytes32(0)) {\\n            return (rootRegistry, address(0), bytes32(0), offset);\\n        }\\n        // lookup parent name\\n        (exactRegistry, resolver, node, resolverOffset) = findResolver(rootRegistry, name, next);\\n        // if there was a parent registry...\\n        if (address(exactRegistry) != address(0)) {\\n            (string memory label, ) = NameCoder.extractLabel(name, offset);\\n            // remember the resolver (if it exists)\\n            address res = exactRegistry.getResolver(label);\\n            if (res != address(0)) {\\n                resolver = res;\\n                resolverOffset = offset;\\n            }\\n            exactRegistry = exactRegistry.getSubregistry(label);\\n        }\\n        node = NameCoder.namehash(node, labelHash); // update namehash\\n    }\\n\\n    /// @notice Find (registry, resolver) for `name[offset:]` starting from\\n    ///         (parentRegistry, parentRegistry) for `name[:parentOffset]`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    /// @param parentOffset The offset into `name` to use parent values.\\n    /// @param parentRegistry The registry at `name[length:]`.\\n    /// @param parentResolver The resolver at `name[length:]`.\\n    ///\\n    /// @return registry The exact registry or null if not exact.\\n    /// @return resolver The resolver or null if not found.\\n    function findResolverFromParent(\\n        bytes memory name,\\n        uint256 offset,\\n        uint256 parentOffset,\\n        IRegistry parentRegistry,\\n        address parentResolver\\n    ) internal view returns (IRegistry registry, address resolver) {\\n        if (offset > parentOffset) {\\n            revert NameCoder.DNSDecodingFailed(name);\\n        } else if (offset == parentOffset) {\\n            return (parentRegistry, parentResolver);\\n        } else {\\n            string memory label;\\n            (label, offset) = NameCoder.extractLabel(name, offset);\\n            (registry, resolver) = findResolverFromParent(\\n                name,\\n                offset,\\n                parentOffset,\\n                parentRegistry,\\n                parentResolver\\n            );\\n            if (address(registry) != address(0)) {\\n                address res = registry.getResolver(label);\\n                if (res != address(0)) {\\n                    resolver = res;\\n                }\\n                registry = registry.getSubregistry(label);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the exact registry for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    ///\\n    /// @return exactRegistry The exact registry or null if not found.\\n    function findExactRegistry(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry exactRegistry) {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash == bytes32(0)) {\\n            return rootRegistry;\\n        }\\n        IRegistry parent = findExactRegistry(rootRegistry, name, next);\\n        if (address(parent) != address(0)) {\\n            (string memory label, ) = NameCoder.extractLabel(name, offset);\\n            exactRegistry = parent.getSubregistry(label);\\n        }\\n    }\\n\\n    /// @dev Find the parent registry for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    ///\\n    /// @return parentRegistry The parent registry or null if not found.\\n    function findParentRegistry(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry parentRegistry) {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            parentRegistry = findExactRegistry(rootRegistry, name, next);\\n        }\\n    }\\n\\n    /// @notice Find all registries in the ancestry of `name`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to begin the search.\\n    ///\\n    /// @return registries Array of registries in label-order.\\n    function findRegistries(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry[] memory registries) {\\n        registries = new IRegistry[](1 + NameCoder.countLabels(name, offset));\\n        registries[registries.length - 1] = rootRegistry;\\n        _findRegistries(name, offset, registries, 0);\\n    }\\n\\n    /// @dev Recursive function for building ancestory.\\n    function _findRegistries(\\n        bytes memory name,\\n        uint256 offset,\\n        IRegistry[] memory registries,\\n        uint256 index\\n    ) private view returns (IRegistry registry) {\\n        (string memory label, uint256 nextOffset) = NameCoder.extractLabel(name, offset);\\n        if (bytes(label).length == 0) {\\n            return registries[registries.length - 1];\\n        }\\n        registry = _findRegistries(name, nextOffset, registries, index + 1);\\n        if (address(registry) != address(0)) {\\n            registry = registry.getSubregistry(label);\\n            registries[index] = registry;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd80793afdb36a5f7a2c7556a0dbcc1a4fefcdfb89357579b77cd31390fd1988d\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "InvalidBatchGatewayResponse()": [
        {
          "notice": "The batch gateway supplied an incorrect number of responses."
        }
      ],
      "InvalidTXT()": [
        {
          "notice": "Some raw TXT data was incorrectly encoded."
        }
      ]
    },
    "events": {
      "VerifierChanged(bytes,address)": {
        "notice": "The verifier contract has changed.         Use `0x00` for any name."
      }
    },
    "kind": "user",
    "methods": {
      "callResolver(address,bytes,bytes,bool,bytes,string[])": {
        "notice": "Perform forward resolution. Call this function with `ccipRead()` to intercept the response. Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers. - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,   the call is performed directly without the batch gateway. - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,   the call is performed directly without the batch gateway. - Otherwise, the call is performed with the batch gateway.   The batch gateway is only invoked if any call reverts `OffchainLookup`.   If the calldata is `multicall()` it is disassembled, called separately, and reassembled."
      },
      "getDNSSECRecords(bytes)": {
        "notice": "Fetch the DNSSEC TXT record.         Callers should enable EIP-3668."
      },
      "getDNSSECRecordsCallback(bytes,bytes)": {
        "notice": "CCIP-Read callback for `getDNSSECRecords()`."
      },
      "getResolver(bytes)": {
        "notice": "Fetch the underlying resolver for `name`.         Callers should enable EIP-3668. * If `offchain`, additional information is necessary to locate `resolver`. * If `resolver` is null, `offchain` is irrelevant."
      },
      "getResolverCallback(bytes,bytes)": {
        "notice": "CCIP-Read callback for `getResolver()`."
      },
      "parseDNSSECRecord(bytes)": {
        "notice": "Parse DNSSEC TXT record into parts.         Format: \"ENS1 <name-or-address> <context>\"."
      },
      "requiresOffchain(bytes)": {
        "notice": "Determine if resolving `name` requires offchain data."
      },
      "resolve(bytes,bytes)": {
        "notice": "Resolve `name` using V1 or DNSSEC.         Caller should enable EIP-3668."
      },
      "resolveOracleCallback(bytes,bytes)": {
        "notice": "CCIP-Read callback for `resolve()` from calling the DNSSEC oracle.         Reverts `UnreachableName` if no \"ENS1\" TXT record is found."
      },
      "supportsFeature(bytes4)": {
        "notice": "Check if a feature is supported."
      },
      "verifierMetadata(bytes)": {
        "notice": "Get information about the verification process.         Use ERC-165 to determine the verifier type."
      }
    },
    "notice": "Resolver that performs imported DNS fallback to V1 and gasless DNS resolution. 0. Note: an imported DNS name will not reach this resolver unless set specifically. 1. If there exists a resolver in V1, go to 4. 2. Query the DNSSEC oracle for TXT records. 3. Verify TXT records, find ENS1 record, parse resolver and context. 4. Call the resolver and return the requested records.",
    "version": 1
  },
  "argsData": "0x000000000000000000000000cf7ed3acca5a467e9e704c703e8d87f634fb0fc9000000000000000000000000a85233c63b9ee964add6f2cffe00fd84eb32338f000000000000000000000000610178da211fef7d417bc0e6fed39f05609ad7880000000000000000000000009a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae0000000000000000000000005fbdb2315678afecb367f032d93f642f64180aa3000000000000000000000000dc64a140aa3e981100a9beca4e685f962f0cf6c9",
  "transaction": {
    "hash": "0x004f933b4477a6ef3ee6835ec5022be868b6062067f2ef585f029bec32f61945",
    "nonce": "0x1b",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x533aaff6f54c15c077b6c1d3ec229159ab06e5b7699f9bd5ed6fe19ce1fd0078",
    "blockNumber": "0x1e",
    "transactionIndex": "0x0"
  }
}
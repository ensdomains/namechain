{
  "address": "0xb7f8bc63bbcad18155201308c8f3540b07f84f5e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IRegistry",
          "name": "rootRegistry",
          "type": "address"
        },
        {
          "internalType": "contract IGatewayProvider",
          "name": "batchGatewayProvider",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ens",
          "type": "string"
        }
      ],
      "name": "DNSEncodingFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBatchGatewayResponse",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "suffix",
          "type": "bytes"
        }
      ],
      "name": "NoSuffixMatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "string[]",
          "name": "urls",
          "type": "string[]"
        },
        {
          "internalType": "bytes",
          "name": "callData",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "callbackFunction",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "OffchainLookup",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OffsetOutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "UnreachableName",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BATCH_GATEWAY_PROVIDER",
      "outputs": [
        {
          "internalType": "contract IGatewayProvider",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_REGISTRY",
      "outputs": [
        {
          "internalType": "contract IRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resolver",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "hasContext",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "string[]",
          "name": "batchGateways",
          "type": "string[]"
        }
      ],
      "name": "callResolver",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "name": "ccipBatch",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipBatchCallback",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "target",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "call",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "flags",
                  "type": "uint256"
                }
              ],
              "internalType": "struct CCIPBatcher.Lookup[]",
              "name": "lookups",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "gateways",
              "type": "string[]"
            }
          ],
          "internalType": "struct CCIPBatcher.Batch",
          "name": "batch",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "ccipReadCallback",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "resolveBatchCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "resolveDirectImmediateCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        }
      ],
      "name": "rewriteNameWithContext",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "feature",
          "type": "bytes4"
        }
      ],
      "name": "supportsFeature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "contractName": "DNSAliasResolver",
  "sourceName": "src/dns/DNSAliasResolver.sol",
  "bytecode": "0x60e060405234801561000f575f80fd5b50604051612ed8380380612ed883398101604081905261002e91610062565b61c3506080526001600160a01b0391821660a0521660c05261009a565b6001600160a01b038116811461005f575f80fd5b50565b5f8060408385031215610073575f80fd5b825161007e8161004b565b602084015190925061008f8161004b565b809150509250929050565b60805160a05160c051612e066100d25f395f8181610157015261068d01525f8181610200015261063f01525f61141f0152612e065ff3fe608060405234801561000f575f80fd5b50600436106100cf575f3560e01c80638ef98a7e1161007d578063c92cc49a11610058578063c92cc49a146101fb578063ef46c0b814610222578063f394443a14610237575f80fd5b80638ef98a7e146101b55780639f28e99d146101c8578063b536af76146101e8575f80fd5b806361c23266116100ad57806361c232661461013f5780636ccb8660146101525780636d6dd54014610191575f80fd5b806301ffc9a7146100d3578063491fc4f9146100fb578063582de3e71461011b575b5f80fd5b6100e66100e1366004611daf565b61024a565b60405190151581526020015b60405180910390f35b61010e610109366004611e08565b61029b565b6040516100f29190611e9d565b6100e6610129366004611daf565b6001600160e01b0319166312d6c5b760e31b1490565b61010e61014d366004611e08565b610439565b6101797f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100f2565b6101a761019f366004611e08565b509192909150565b6040516100f2929190611ed7565b61010e6101c3366004611eea565b610627565b6101db6101d6366004612191565b61071b565b6040516100f29190612351565b6101db6101f6366004611e08565b6108dc565b6101797f000000000000000000000000000000000000000000000000000000000000000081565b61023561023036600461241a565b610b2b565b005b61010e610245366004612492565b610bb0565b5f63477cc53f60e11b6001600160e01b03198316148061027a575063582de3e760e01b6001600160e01b03198316145b8061029557506301ffc9a760e01b6001600160e01b03198316145b92915050565b60605f6102aa85870187612191565b5190505f806102bb85870187612557565b9150915081156103c8575f835167ffffffffffffffff8111156102e0576102e0611f7d565b60405190808252806020026020018201604052801561031357816020015b60608152602001906001900390816102fe5790505b5090505f5b845181101561039c575f8582815181106103345761033461258e565b602002602001015190505f8160400151905084801561035857506060820151600e16155b15610374578080602001905181019061037191906125f6565b90505b808484815181106103875761038761258e565b60209081029190910101525050600101610318565b50806040516020016103ae9190612628565b604051602081830303815290604052945050505050610431565b5f835f815181106103db576103db61258e565b60209081029190910101516040810151606082015191925090600e161561040457805160208201fd5b8215610421578080602001905181019061041e91906125f6565b90505b94506104319350505050565b5050505b949350505050565b60605f61049d84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92018290525092508791507f20000000000000000000000000000000000000000000000000000000000000009050610ed0565b9050828110156105e1575f6104f06104b78383878961268a565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610f5092505050565b90505f8061053d89898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610538915087905082611112565b61114a565b93505050915081610589578888846040517f017817ea000000000000000000000000000000000000000000000000000000008152600401610580939291906126b1565b60405180910390fd5b5f6105a5888861059a8860016126f4565b6104b792829061268a565b90506105b3825f8b8d61268a565b826040516020016105c69392919061271e565b60405160208183030381529060405295505050505050610431565b61061f84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610f5092505050565b915050610431565b60605f61063688888686610439565b90505f806106657f0000000000000000000000000000000000000000000000000000000000000000845f6111b9565b50925092505061070d828461067b8b8b8661133e565b5f60405180602001604052805f8152507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa1580156106e6573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261024591908101906127c1565b505050509695505050505050565b60408051808201909152606080825260208201525f5b8251518110156108ce575f835f015182815181106107515761075161258e565b6020026020010151905060408160600151165f1461076f57506108c6565b60608101516030165f03610819575f61078a825f01516113d9565b610795576010610798565b60205b9050825b85515181101561081657825f01516001600160a01b0316865f015182815181106107c8576107c861258e565b60200260200101515f01516001600160a01b03160361080e5781865f015182815181106107f7576107f761258e565b602002602001015160600181815117915081815250505b60010161079c565b50505b5f60208260600151165f1490505f8061083b8315855f0151866020015161140b565b91509150811580156108655750630556f18360e41b610859826127f3565b6001600160e01b031916145b1561087a5760608401805160011790526108ba565b606084018051604017905282801561089157508051155b6108a657816108a65760608401805160021790525b80515f036108ba5760608401805160081790525b60409093019290925250505b600101610731565b506108d88261149e565b5090565b60408051808201909152606080825260208201525f806108fe868801886128a5565b9150915080518251146109245760405163252e18f560e11b815260040160405180910390fd5b61093084860186612191565b92505f805b845151811015610b00575f855f015182815181106109555761095561258e565b6020026020010151905060408160600151165f03610af7578351831015610aeb575f8484815181106109895761098961258e565b602002602001015190508584815181106109a5576109a561258e565b6020026020010151156109c2576060820180516044179052610ae5565b5f6109d08360400151611689565b90505f815f01516001600160a01b031682606001518484608001516040516024016109fc929190612957565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051610a3a919061297b565b5f60405180830381855afa9150503d805f8114610a72576040519150601f19603f3d011682016040523d82523d5f602084013e610a77565b606091505b50935090508080610aa15750630556f18360e41b610a94846127f3565b6001600160e01b03191614155b15610ae2576060840180516040179052801580610abd57508251155b15610ace5760608401805160021790525b82515f03610ae25760608401805160081790525b50505b60408201525b610af483612986565b92505b50600101610935565b5081518114610b225760405163252e18f560e11b815260040160405180910390fd5b61042d8461149e565b5f81806020019051810190610b4091906129b4565b9050610bab815f01518260200151858460400151604051602401610b65929190612957565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a08601516116cd565b505050565b6060866001600160a01b03163b5f03610bf757856040517f5fe9a5df0000000000000000000000000000000000000000000000000000000081526004016105809190611e9d565b5f7fac9650d800000000000000000000000000000000000000000000000000000000610c22876127f3565b6001600160e01b0319161490505f858015610c495750610c498963477cc53f60e11b611890565b90505f8180610c645750610c648a639061b92360e01b611890565b9050610c778a63582de3e760e01b611890565b8015610cfb5750821580610cfb5750808015610cfb575060405163582de3e760e01b81526312d6c5b760e31b60048201526001600160a01b038b169063582de3e790602401602060405180830381865afa158015610cd7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cfb9190612a83565b15610d45578015610d2057610d1b8a610d16848c8c8b611916565b6119a8565b610d45565b610d458a89636d6dd54060e01b5f60e01b60405180602001604052805f8152506116cd565b60608315610d7f57610d65896004808c51610d609190612a9e565b6119cd565b806020019051810190610d789190612ab1565b9050610dca565b60408051600180825281830190925290816020015b6060815260200190600190039081610d9457905050905088815f81518110610dbe57610dbe61258e565b60200260200101819052505b8115610e27575f5b8151811015610e2557610e00848c848481518110610df257610df261258e565b60200260200101518b611916565b828281518110610e1257610e1261258e565b6020908102919091010152600101610dd2565b505b61070d3080639f28e99d610e3c8f868c611a22565b604051602401610e4c9190612351565b60408051601f19818403018152918152602080830180516001600160e01b031660e09590951b94909417909352519092507f491fc4f900000000000000000000000000000000000000000000000000000000915f91610ebc918b918a910191151582521515602082015260400190565b6040516020818303038152906040526116cd565b5f80610edc84866126f4565b90505b80851015610f4457826001600160f81b031916868681518110610f0457610f0461258e565b01602001517fff000000000000000000000000000000000000000000000000000000000000001603610f395784915050610431565b600190940193610edf565b505f1995945050505050565b80516060905f819003610f7857505060408051808201909152600181525f6020820152919050565b8060020167ffffffffffffffff811115610f9457610f94611f7d565b6040519080825280601f01601f191660200182016040528015610fbe576020820181803683370190505b509150610fd2602183016020850183611b37565b5f805f5b838110156110ab57858181518110610ff057610ff061258e565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f2e00000000000000000000000000000000000000000000000000000000000000036110a3578281039150815f1480611050575060ff82115b156110705785604051639a4c3e3b60e01b81526004016105809190611e9d565b8160f81b8584815181106110865761108661258e565b60200101906001600160f81b03191690815f1a9053508060010192505b600101610fd6565b5050808203828214806110be575060ff81115b156110de5784604051639a4c3e3b60e01b81526004016105809190611e9d565b8060f81b8483815181106110f4576110f461258e565b60200101906001600160f81b03191690815f1a905350505050919050565b5f61111d8383611b80565b925090508015610295576111436111348484611112565b825f9182526020526040902090565b9392505050565b5f805f805f8061115a8989611b80565b9092509050811561119c5761117089828961114a565b9298509096509450925086850361118c57600195508793508092505b5f85815260208390526040902094505b8685036111ae57600195508792508293505b505093509350935093565b5f805f805f806111c98888611b80565b9092509050816111e757508794505f93508392508591506113359050565b6111f28989836111b9565b929850909650945092506001600160a01b03861615611326575f6112168989611bad565b5090505f876001600160a01b031663e4ae7d77836040518263ffffffff1660e01b81526004016112469190611e9d565b602060405180830381865afa158015611261573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112859190612b5b565b90506001600160a01b0381161561129d578096508894505b6040517f35af62160000000000000000000000000000000000000000000000000000000081526001600160a01b038916906335af6216906112e2908590600401611e9d565b602060405180830381865afa1580156112fd573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113219190612b5b565b975050505b505f9283526020526040909120905b93509350935093565b606083838080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152509293506113cf92505050565b602081015160e01c63ac9650d88114611398575060240152565b602482810151830101805160051b5b80156113c8576113bf8582840151602085010161137e565b601f19016113a7565b5050505050565b611143828261137e565b5f306001600160a01b038316036113f257506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685611443577f0000000000000000000000000000000000000000000000000000000000000000611445565b5a5b84604051611453919061297b565b5f604051808303818686fa925050503d805f811461148c576040519150601f19603f3d011682016040523d82523d5f602084013e611491565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff8111156114bb576114bb611f7d565b60405190808252806020026020018201604052801561151857816020015b61150560405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b8152602001906001900390816114d95790505b5090505f805b8351518110156115c9575f845f0151828151811061153e5761153e61258e565b6020026020010151905060408160600151165f036115c0575f6115648260400151611689565b90506040518060600160405280825f01516001600160a01b031681526020018260200151815260200182604001518152508585806115a190612986565b9650815181106115b3576115b361258e565b6020026020010181905250505b5060010161151e565b508015610bab57808252308360200151836040516024016115ea9190612b76565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af76000000000000000000000000000000000000000000000000000000009161165e91899101612351565b60408051601f1981840301815290829052630556f18360e41b82526105809594939291600401612c10565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091526102956116c8836004808651610d609190612a9e565b611c2a565b5f806116e26116db886113d9565b888861140b565b915091508115801561170c5750630556f18360e41b611700826127f3565b6001600160e01b031916145b156117ba575f61171b82611689565b9050876001600160a01b0316815f01516001600160a01b0316036117b857308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b03191681526020018981525060405160200161165e9190612c73565b505b5f826117c657846117c8565b855b90506001600160e01b031981161561187a57306001600160a01b03168183866040516024016117f8929190612957565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051611836919061297b565b5f60405180830381855afa9150503d805f811461186e576040519150601f19603f3d011682016040523d82523d5f602084013e611873565b606091505b5090935091505b821561188857815160208301f35b815160208301fd5b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f519050828015611900575060208210155b801561190b57505f81115b979650505050505050565b60608461195f578383604051602401611930929190612957565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b17905261199f565b83838360405160240161197493929190612cef565b60408051601f198184030181529190526020810180516001600160e01b031663477cc53f60e11b1790525b95945050505050565b6119c982825f60e01b5f60e01b60405180602001604052805f8152506116cd565b5050565b60608167ffffffffffffffff8111156119e8576119e8611f7d565b6040519080825280601f01601f191660200182016040528015611a12576020820181803683370190505b5090506111438484835f86611c95565b60408051808201909152606080825260208201525f835167ffffffffffffffff811115611a5157611a51611f7d565b604051908082528060200260200182016040528015611ab457816020015b611aa160405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b815260200190600190039081611a6f5790505b5090505f5b8451811015611b1a575f828281518110611ad557611ad561258e565b60209081029190910101516001600160a01b03881681528651909150869083908110611b0357611b0361258e565b602090810291909101810151910152600101611ab9565b506040805180820190915290815260208101929092525092915050565b5b601f811115611b58578151835260209283019290910190601f1901611b38565b8015610bab5790518251600160209390930360031b9290921b5f190180199091169116179052565b5f805f611b8d8585611ccb565b9250905060ff811615611ba557806021858701012092505b509250929050565b60605f80611bbb8585611ccb565b925090505f60ff821667ffffffffffffffff811115611bdc57611bdc611f7d565b6040519080825280601f01601f191660200182016040528015611c06576020820181803683370190505b509050611c1f6020820160218888010160ff8516611b37565b959194509092505050565b6040805160a0810182525f80825260606020830181905292820183905282820152608081019190915281806020019051810190611c679190612d27565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b611ca885611ca383876126f4565b611d4f565b611cb683611ca383856126f4565b6113c882602085010185602088010183611b37565b5f8083518310611cf0578360405163ba4adc2360e01b81526004016105809190611e9d565b838381518110611d0257611d0261258e565b016020015160f81c91505081810160010181611d22578351811415611d28565b83518110155b15611d48578360405163ba4adc2360e01b81526004016105809190611e9d565b9250929050565b81518111156119c95781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610580918391600401918252602082015260400190565b6001600160e01b031981168114611dac575f80fd5b50565b5f60208284031215611dbf575f80fd5b813561114381611d97565b5f8083601f840112611dda575f80fd5b50813567ffffffffffffffff811115611df1575f80fd5b602083019150836020828501011115611d48575f80fd5b5f805f8060408587031215611e1b575f80fd5b843567ffffffffffffffff80821115611e32575f80fd5b611e3e88838901611dca565b90965094506020870135915080821115611e56575f80fd5b50611e6387828801611dca565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6111436020830184611e6f565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b602081525f610431602083018486611eaf565b5f805f805f8060608789031215611eff575f80fd5b863567ffffffffffffffff80821115611f16575f80fd5b611f228a838b01611dca565b90985096506020890135915080821115611f3a575f80fd5b611f468a838b01611dca565b90965094506040890135915080821115611f5e575f80fd5b50611f6b89828a01611dca565b979a9699509497509295939492505050565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff81118282101715611fb457611fb4611f7d565b60405290565b6040516080810167ffffffffffffffff81118282101715611fb457611fb4611f7d565b60405160c0810167ffffffffffffffff81118282101715611fb457611fb4611f7d565b604051601f8201601f1916810167ffffffffffffffff8111828210171561202957612029611f7d565b604052919050565b5f67ffffffffffffffff82111561204a5761204a611f7d565b5060051b60200190565b6001600160a01b0381168114611dac575f80fd5b803561207381612054565b919050565b5f67ffffffffffffffff82111561209157612091611f7d565b50601f01601f191660200190565b5f6120b16120ac84612078565b612000565b90508281528383830111156120c4575f80fd5b828260208301375f602084830101529392505050565b5f82601f8301126120e9575f80fd5b6111438383356020850161209f565b5f82601f830112612107575f80fd5b813560206121176120ac83612031565b82815260059290921b84018101918181019086841115612135575f80fd5b8286015b8481101561218657803567ffffffffffffffff811115612157575f80fd5b8701603f81018913612167575f80fd5b61217889868301356040840161209f565b845250918301918301612139565b509695505050505050565b5f60208083850312156121a2575f80fd5b823567ffffffffffffffff808211156121b9575f80fd5b90840190604082870312156121cc575f80fd5b6121d4611f91565b8235828111156121e2575f80fd5b8301601f810188136121f2575f80fd5b80356122006120ac82612031565b81815260059190911b8201860190868101908a83111561221e575f80fd5b8784015b838110156122c657803587811115612238575f80fd5b85016080818e03601f1901121561224d575f80fd5b612255611fba565b8a82013561226281612054565b8152604082013589811115612275575f80fd5b6122838f8d838601016120da565b8c83015250606082013589811115612299575f80fd5b6122a78f8d838601016120da565b6040830152506080919091013560608201528352918801918801612222565b50845250505082840135828111156122dc575f80fd5b6122e8888286016120f8565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b8481101561234457601f19868403018952612332838351611e6f565b98840198925090830190600101612316565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b828110156123ef57607f198b830301845285516001600160a01b03815116835289810151888b8501526123ba89850182611e6f565b905086820151848203888601526123d18282611e6f565b928b0151948b01949094525095890195938901939150600101612385565b50968a0151898803601f190160408b01529661240b81896122f9565b9b9a5050505050505050505050565b5f806040838503121561242b575f80fd5b823567ffffffffffffffff80821115612442575f80fd5b61244e868387016120da565b93506020850135915080821115612463575f80fd5b50612470858286016120da565b9150509250929050565b8015158114611dac575f80fd5b80356120738161247a565b5f805f805f8060c087890312156124a7575f80fd5b6124b087612068565b9550602087013567ffffffffffffffff808211156124cc575f80fd5b6124d88a838b016120da565b965060408901359150808211156124ed575f80fd5b6124f98a838b016120da565b955061250760608a01612487565b9450608089013591508082111561251c575f80fd5b6125288a838b016120da565b935060a089013591508082111561253d575f80fd5b5061254a89828a016120f8565b9150509295509295509295565b5f8060408385031215612568575f80fd5b82356125738161247a565b915060208301356125838161247a565b809150509250929050565b634e487b7160e01b5f52603260045260245ffd5b5f6125af6120ac84612078565b90508281528383830111156125c2575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f8301126125e7575f80fd5b611143838351602085016125a2565b5f60208284031215612606575f80fd5b815167ffffffffffffffff81111561261c575f80fd5b610431848285016125d8565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561267d57603f1988860301845261266b858351611e6f565b9450928501929085019060010161264f565b5092979650505050505050565b5f8085851115612698575f80fd5b838611156126a4575f80fd5b5050820193919092039150565b604081525f6126c4604083018587611eaf565b82810360208401526126d68185611e6f565b9695505050505050565b634e487b7160e01b5f52601160045260245ffd5b80820180821115610295576102956126e0565b5f81518060208401855e5f93019283525090919050565b828482375f8382015f81526126d68185612707565b5f82601f830112612742575f80fd5b815160206127526120ac83612031565b82815260059290921b84018101918181019086841115612770575f80fd5b8286015b8481101561218657805167ffffffffffffffff811115612792575f80fd5b8701603f810189136127a2575f80fd5b6127b38986830151604084016125a2565b845250918301918301612774565b5f602082840312156127d1575f80fd5b815167ffffffffffffffff8111156127e7575f80fd5b61043184828501612733565b5f815160208301516001600160e01b0319808216935060048310156128225780818460040360031b1b83161693505b505050919050565b5f82601f830112612839575f80fd5b813560206128496120ac83612031565b82815260059290921b84018101918181019086841115612867575f80fd5b8286015b8481101561218657803567ffffffffffffffff811115612889575f80fd5b6128978986838b01016120da565b84525091830191830161286b565b5f80604083850312156128b6575f80fd5b823567ffffffffffffffff808211156128cd575f80fd5b818501915085601f8301126128e0575f80fd5b813560206128f06120ac83612031565b82815260059290921b8401810191818101908984111561290e575f80fd5b948201945b838610156129355785356129268161247a565b82529482019490820190612913565b9650508601359250508082111561294a575f80fd5b506124708582860161282a565b604081525f6129696040830185611e6f565b828103602084015261199f8185611e6f565b5f6111438284612707565b5f60018201612997576129976126e0565b5060010190565b805161207381612054565b805161207381611d97565b5f602082840312156129c4575f80fd5b815167ffffffffffffffff808211156129db575f80fd5b9083019060c082860312156129ee575f80fd5b6129f6611fdd565b6129ff8361299e565b8152612a0d602084016129a9565b6020820152604083015182811115612a23575f80fd5b612a2f878286016125d8565b604083015250612a41606084016129a9565b6060820152612a52608084016129a9565b608082015260a083015182811115612a68575f80fd5b612a74878286016125d8565b60a08301525095945050505050565b5f60208284031215612a93575f80fd5b81516111438161247a565b81810381811115610295576102956126e0565b5f6020808385031215612ac2575f80fd5b825167ffffffffffffffff80821115612ad9575f80fd5b818501915085601f830112612aec575f80fd5b8151612afa6120ac82612031565b81815260059190911b83018401908481019088831115612b18575f80fd5b8585015b83811015612b4e57805185811115612b32575f80fd5b612b408b89838a01016125d8565b845250918601918601612b1c565b5098975050505050505050565b5f60208284031215612b6b575f80fd5b815161114381612054565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b83811015612c0257603f19898403018552815160606001600160a01b03825116855288820151818a870152612bd4828701826122f9565b91505087820151915084810388860152612bee8183611e6f565b968901969450505090860190600101612b9d565b509098975050505050505050565b6001600160a01b038616815260a060208201525f612c3160a08301876122f9565b8281036040840152612c438187611e6f565b90506001600160e01b0319851660608401528281036080840152612c678185611e6f565b98975050505050505050565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c06060850152612cb960e0850183611e6f565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c085015261199f8282611e6f565b606081525f612d016060830186611e6f565b8281036020840152612d138186611e6f565b905082810360408401526126d68185611e6f565b5f805f805f60a08688031215612d3b575f80fd5b8551612d4681612054565b602087015190955067ffffffffffffffff80821115612d63575f80fd5b612d6f89838a01612733565b95506040880151915080821115612d84575f80fd5b612d9089838a016125d8565b945060608801519150612da282611d97565b608088015191935080821115612db6575f80fd5b50612dc3888289016125d8565b915050929550929590935056fea26469706673582212201aac98bc4a75beb832065fea83727dc5f1bb2e8ccad0c02cee5e3c642e5ee10164736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b50600436106100cf575f3560e01c80638ef98a7e1161007d578063c92cc49a11610058578063c92cc49a146101fb578063ef46c0b814610222578063f394443a14610237575f80fd5b80638ef98a7e146101b55780639f28e99d146101c8578063b536af76146101e8575f80fd5b806361c23266116100ad57806361c232661461013f5780636ccb8660146101525780636d6dd54014610191575f80fd5b806301ffc9a7146100d3578063491fc4f9146100fb578063582de3e71461011b575b5f80fd5b6100e66100e1366004611daf565b61024a565b60405190151581526020015b60405180910390f35b61010e610109366004611e08565b61029b565b6040516100f29190611e9d565b6100e6610129366004611daf565b6001600160e01b0319166312d6c5b760e31b1490565b61010e61014d366004611e08565b610439565b6101797f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100f2565b6101a761019f366004611e08565b509192909150565b6040516100f2929190611ed7565b61010e6101c3366004611eea565b610627565b6101db6101d6366004612191565b61071b565b6040516100f29190612351565b6101db6101f6366004611e08565b6108dc565b6101797f000000000000000000000000000000000000000000000000000000000000000081565b61023561023036600461241a565b610b2b565b005b61010e610245366004612492565b610bb0565b5f63477cc53f60e11b6001600160e01b03198316148061027a575063582de3e760e01b6001600160e01b03198316145b8061029557506301ffc9a760e01b6001600160e01b03198316145b92915050565b60605f6102aa85870187612191565b5190505f806102bb85870187612557565b9150915081156103c8575f835167ffffffffffffffff8111156102e0576102e0611f7d565b60405190808252806020026020018201604052801561031357816020015b60608152602001906001900390816102fe5790505b5090505f5b845181101561039c575f8582815181106103345761033461258e565b602002602001015190505f8160400151905084801561035857506060820151600e16155b15610374578080602001905181019061037191906125f6565b90505b808484815181106103875761038761258e565b60209081029190910101525050600101610318565b50806040516020016103ae9190612628565b604051602081830303815290604052945050505050610431565b5f835f815181106103db576103db61258e565b60209081029190910101516040810151606082015191925090600e161561040457805160208201fd5b8215610421578080602001905181019061041e91906125f6565b90505b94506104319350505050565b5050505b949350505050565b60605f61049d84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92018290525092508791507f20000000000000000000000000000000000000000000000000000000000000009050610ed0565b9050828110156105e1575f6104f06104b78383878961268a565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610f5092505050565b90505f8061053d89898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250610538915087905082611112565b61114a565b93505050915081610589578888846040517f017817ea000000000000000000000000000000000000000000000000000000008152600401610580939291906126b1565b60405180910390fd5b5f6105a5888861059a8860016126f4565b6104b792829061268a565b90506105b3825f8b8d61268a565b826040516020016105c69392919061271e565b60405160208183030381529060405295505050505050610431565b61061f84848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610f5092505050565b915050610431565b60605f61063688888686610439565b90505f806106657f0000000000000000000000000000000000000000000000000000000000000000845f6111b9565b50925092505061070d828461067b8b8b8661133e565b5f60405180602001604052805f8152507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663093a86d36040518163ffffffff1660e01b81526004015f60405180830381865afa1580156106e6573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261024591908101906127c1565b505050509695505050505050565b60408051808201909152606080825260208201525f5b8251518110156108ce575f835f015182815181106107515761075161258e565b6020026020010151905060408160600151165f1461076f57506108c6565b60608101516030165f03610819575f61078a825f01516113d9565b610795576010610798565b60205b9050825b85515181101561081657825f01516001600160a01b0316865f015182815181106107c8576107c861258e565b60200260200101515f01516001600160a01b03160361080e5781865f015182815181106107f7576107f761258e565b602002602001015160600181815117915081815250505b60010161079c565b50505b5f60208260600151165f1490505f8061083b8315855f0151866020015161140b565b91509150811580156108655750630556f18360e41b610859826127f3565b6001600160e01b031916145b1561087a5760608401805160011790526108ba565b606084018051604017905282801561089157508051155b6108a657816108a65760608401805160021790525b80515f036108ba5760608401805160081790525b60409093019290925250505b600101610731565b506108d88261149e565b5090565b60408051808201909152606080825260208201525f806108fe868801886128a5565b9150915080518251146109245760405163252e18f560e11b815260040160405180910390fd5b61093084860186612191565b92505f805b845151811015610b00575f855f015182815181106109555761095561258e565b6020026020010151905060408160600151165f03610af7578351831015610aeb575f8484815181106109895761098961258e565b602002602001015190508584815181106109a5576109a561258e565b6020026020010151156109c2576060820180516044179052610ae5565b5f6109d08360400151611689565b90505f815f01516001600160a01b031682606001518484608001516040516024016109fc929190612957565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051610a3a919061297b565b5f60405180830381855afa9150503d805f8114610a72576040519150601f19603f3d011682016040523d82523d5f602084013e610a77565b606091505b50935090508080610aa15750630556f18360e41b610a94846127f3565b6001600160e01b03191614155b15610ae2576060840180516040179052801580610abd57508251155b15610ace5760608401805160021790525b82515f03610ae25760608401805160081790525b50505b60408201525b610af483612986565b92505b50600101610935565b5081518114610b225760405163252e18f560e11b815260040160405180910390fd5b61042d8461149e565b5f81806020019051810190610b4091906129b4565b9050610bab815f01518260200151858460400151604051602401610b65929190612957565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526060840151608085015160a08601516116cd565b505050565b6060866001600160a01b03163b5f03610bf757856040517f5fe9a5df0000000000000000000000000000000000000000000000000000000081526004016105809190611e9d565b5f7fac9650d800000000000000000000000000000000000000000000000000000000610c22876127f3565b6001600160e01b0319161490505f858015610c495750610c498963477cc53f60e11b611890565b90505f8180610c645750610c648a639061b92360e01b611890565b9050610c778a63582de3e760e01b611890565b8015610cfb5750821580610cfb5750808015610cfb575060405163582de3e760e01b81526312d6c5b760e31b60048201526001600160a01b038b169063582de3e790602401602060405180830381865afa158015610cd7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cfb9190612a83565b15610d45578015610d2057610d1b8a610d16848c8c8b611916565b6119a8565b610d45565b610d458a89636d6dd54060e01b5f60e01b60405180602001604052805f8152506116cd565b60608315610d7f57610d65896004808c51610d609190612a9e565b6119cd565b806020019051810190610d789190612ab1565b9050610dca565b60408051600180825281830190925290816020015b6060815260200190600190039081610d9457905050905088815f81518110610dbe57610dbe61258e565b60200260200101819052505b8115610e27575f5b8151811015610e2557610e00848c848481518110610df257610df261258e565b60200260200101518b611916565b828281518110610e1257610e1261258e565b6020908102919091010152600101610dd2565b505b61070d3080639f28e99d610e3c8f868c611a22565b604051602401610e4c9190612351565b60408051601f19818403018152918152602080830180516001600160e01b031660e09590951b94909417909352519092507f491fc4f900000000000000000000000000000000000000000000000000000000915f91610ebc918b918a910191151582521515602082015260400190565b6040516020818303038152906040526116cd565b5f80610edc84866126f4565b90505b80851015610f4457826001600160f81b031916868681518110610f0457610f0461258e565b01602001517fff000000000000000000000000000000000000000000000000000000000000001603610f395784915050610431565b600190940193610edf565b505f1995945050505050565b80516060905f819003610f7857505060408051808201909152600181525f6020820152919050565b8060020167ffffffffffffffff811115610f9457610f94611f7d565b6040519080825280601f01601f191660200182016040528015610fbe576020820181803683370190505b509150610fd2602183016020850183611b37565b5f805f5b838110156110ab57858181518110610ff057610ff061258e565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f2e00000000000000000000000000000000000000000000000000000000000000036110a3578281039150815f1480611050575060ff82115b156110705785604051639a4c3e3b60e01b81526004016105809190611e9d565b8160f81b8584815181106110865761108661258e565b60200101906001600160f81b03191690815f1a9053508060010192505b600101610fd6565b5050808203828214806110be575060ff81115b156110de5784604051639a4c3e3b60e01b81526004016105809190611e9d565b8060f81b8483815181106110f4576110f461258e565b60200101906001600160f81b03191690815f1a905350505050919050565b5f61111d8383611b80565b925090508015610295576111436111348484611112565b825f9182526020526040902090565b9392505050565b5f805f805f8061115a8989611b80565b9092509050811561119c5761117089828961114a565b9298509096509450925086850361118c57600195508793508092505b5f85815260208390526040902094505b8685036111ae57600195508792508293505b505093509350935093565b5f805f805f806111c98888611b80565b9092509050816111e757508794505f93508392508591506113359050565b6111f28989836111b9565b929850909650945092506001600160a01b03861615611326575f6112168989611bad565b5090505f876001600160a01b031663e4ae7d77836040518263ffffffff1660e01b81526004016112469190611e9d565b602060405180830381865afa158015611261573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112859190612b5b565b90506001600160a01b0381161561129d578096508894505b6040517f35af62160000000000000000000000000000000000000000000000000000000081526001600160a01b038916906335af6216906112e2908590600401611e9d565b602060405180830381865afa1580156112fd573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113219190612b5b565b975050505b505f9283526020526040909120905b93509350935093565b606083838080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152509293506113cf92505050565b602081015160e01c63ac9650d88114611398575060240152565b602482810151830101805160051b5b80156113c8576113bf8582840151602085010161137e565b601f19016113a7565b5050505050565b611143828261137e565b5f306001600160a01b038316036113f257506001919050565b6113885a5f805f808786fa50815a909103109392505050565b5f6060836001600160a01b031685611443577f0000000000000000000000000000000000000000000000000000000000000000611445565b5a5b84604051611453919061297b565b5f604051808303818686fa925050503d805f811461148c576040519150601f19603f3d011682016040523d82523d5f602084013e611491565b606091505b5090969095509350505050565b8051515f9067ffffffffffffffff8111156114bb576114bb611f7d565b60405190808252806020026020018201604052801561151857816020015b61150560405180606001604052805f6001600160a01b0316815260200160608152602001606081525090565b8152602001906001900390816114d95790505b5090505f805b8351518110156115c9575f845f0151828151811061153e5761153e61258e565b6020026020010151905060408160600151165f036115c0575f6115648260400151611689565b90506040518060600160405280825f01516001600160a01b031681526020018260200151815260200182604001518152508585806115a190612986565b9650815181106115b3576115b361258e565b6020026020010181905250505b5060010161151e565b508015610bab57808252308360200151836040516024016115ea9190612b76565b60408051601f19818403018152918152602080830180516001600160e01b03167fa780bab60000000000000000000000000000000000000000000000000000000017905290517fb536af76000000000000000000000000000000000000000000000000000000009161165e91899101612351565b60408051601f1981840301815290829052630556f18360e41b82526105809594939291600401612c10565b6040805160a0810182525f8082526060602083018190529282018390528282015260808101919091526102956116c8836004808651610d609190612a9e565b611c2a565b5f806116e26116db886113d9565b888861140b565b915091508115801561170c5750630556f18360e41b611700826127f3565b6001600160e01b031916145b156117ba575f61171b82611689565b9050876001600160a01b0316815f01516001600160a01b0316036117b857308160200151826040015163ef46c0b860e01b6040518060c001604052808d6001600160a01b0316815260200186606001516001600160e01b0319168152602001866080015181526020018b6001600160e01b03191681526020018a6001600160e01b03191681526020018981525060405160200161165e9190612c73565b505b5f826117c657846117c8565b855b90506001600160e01b031981161561187a57306001600160a01b03168183866040516024016117f8929190612957565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051611836919061297b565b5f60405180830381855afa9150503d805f811461186e576040519150601f19603f3d011682016040523d82523d5f602084013e611873565b606091505b5090935091505b821561188857815160208301f35b815160208301fd5b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b17815282515f9392849283928392918391908a617530fa92503d91505f519050828015611900575060208210155b801561190b57505f81115b979650505050505050565b60608461195f578383604051602401611930929190612957565b60408051601f198184030181529190526020810180516001600160e01b0316639061b92360e01b17905261199f565b83838360405160240161197493929190612cef565b60408051601f198184030181529190526020810180516001600160e01b031663477cc53f60e11b1790525b95945050505050565b6119c982825f60e01b5f60e01b60405180602001604052805f8152506116cd565b5050565b60608167ffffffffffffffff8111156119e8576119e8611f7d565b6040519080825280601f01601f191660200182016040528015611a12576020820181803683370190505b5090506111438484835f86611c95565b60408051808201909152606080825260208201525f835167ffffffffffffffff811115611a5157611a51611f7d565b604051908082528060200260200182016040528015611ab457816020015b611aa160405180608001604052805f6001600160a01b0316815260200160608152602001606081526020015f81525090565b815260200190600190039081611a6f5790505b5090505f5b8451811015611b1a575f828281518110611ad557611ad561258e565b60209081029190910101516001600160a01b03881681528651909150869083908110611b0357611b0361258e565b602090810291909101810151910152600101611ab9565b506040805180820190915290815260208101929092525092915050565b5b601f811115611b58578151835260209283019290910190601f1901611b38565b8015610bab5790518251600160209390930360031b9290921b5f190180199091169116179052565b5f805f611b8d8585611ccb565b9250905060ff811615611ba557806021858701012092505b509250929050565b60605f80611bbb8585611ccb565b925090505f60ff821667ffffffffffffffff811115611bdc57611bdc611f7d565b6040519080825280601f01601f191660200182016040528015611c06576020820181803683370190505b509050611c1f6020820160218888010160ff8516611b37565b959194509092505050565b6040805160a0810182525f80825260606020830181905292820183905282820152608081019190915281806020019051810190611c679190612d27565b60808601526001600160e01b0319166060850152604084015260208301526001600160a01b03168152919050565b611ca885611ca383876126f4565b611d4f565b611cb683611ca383856126f4565b6113c882602085010185602088010183611b37565b5f8083518310611cf0578360405163ba4adc2360e01b81526004016105809190611e9d565b838381518110611d0257611d0261258e565b016020015160f81c91505081810160010181611d22578351811415611d28565b83518110155b15611d48578360405163ba4adc2360e01b81526004016105809190611e9d565b9250929050565b81518111156119c95781516040517f8a3c1cfb000000000000000000000000000000000000000000000000000000008152610580918391600401918252602082015260400190565b6001600160e01b031981168114611dac575f80fd5b50565b5f60208284031215611dbf575f80fd5b813561114381611d97565b5f8083601f840112611dda575f80fd5b50813567ffffffffffffffff811115611df1575f80fd5b602083019150836020828501011115611d48575f80fd5b5f805f8060408587031215611e1b575f80fd5b843567ffffffffffffffff80821115611e32575f80fd5b611e3e88838901611dca565b90965094506020870135915080821115611e56575f80fd5b50611e6387828801611dca565b95989497509550505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6111436020830184611e6f565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b602081525f610431602083018486611eaf565b5f805f805f8060608789031215611eff575f80fd5b863567ffffffffffffffff80821115611f16575f80fd5b611f228a838b01611dca565b90985096506020890135915080821115611f3a575f80fd5b611f468a838b01611dca565b90965094506040890135915080821115611f5e575f80fd5b50611f6b89828a01611dca565b979a9699509497509295939492505050565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff81118282101715611fb457611fb4611f7d565b60405290565b6040516080810167ffffffffffffffff81118282101715611fb457611fb4611f7d565b60405160c0810167ffffffffffffffff81118282101715611fb457611fb4611f7d565b604051601f8201601f1916810167ffffffffffffffff8111828210171561202957612029611f7d565b604052919050565b5f67ffffffffffffffff82111561204a5761204a611f7d565b5060051b60200190565b6001600160a01b0381168114611dac575f80fd5b803561207381612054565b919050565b5f67ffffffffffffffff82111561209157612091611f7d565b50601f01601f191660200190565b5f6120b16120ac84612078565b612000565b90508281528383830111156120c4575f80fd5b828260208301375f602084830101529392505050565b5f82601f8301126120e9575f80fd5b6111438383356020850161209f565b5f82601f830112612107575f80fd5b813560206121176120ac83612031565b82815260059290921b84018101918181019086841115612135575f80fd5b8286015b8481101561218657803567ffffffffffffffff811115612157575f80fd5b8701603f81018913612167575f80fd5b61217889868301356040840161209f565b845250918301918301612139565b509695505050505050565b5f60208083850312156121a2575f80fd5b823567ffffffffffffffff808211156121b9575f80fd5b90840190604082870312156121cc575f80fd5b6121d4611f91565b8235828111156121e2575f80fd5b8301601f810188136121f2575f80fd5b80356122006120ac82612031565b81815260059190911b8201860190868101908a83111561221e575f80fd5b8784015b838110156122c657803587811115612238575f80fd5b85016080818e03601f1901121561224d575f80fd5b612255611fba565b8a82013561226281612054565b8152604082013589811115612275575f80fd5b6122838f8d838601016120da565b8c83015250606082013589811115612299575f80fd5b6122a78f8d838601016120da565b6040830152506080919091013560608201528352918801918801612222565b50845250505082840135828111156122dc575f80fd5b6122e8888286016120f8565b948201949094529695505050505050565b5f8282518085526020808601955060208260051b840101602086015f5b8481101561234457601f19868403018952612332838351611e6f565b98840198925090830190600101612316565b5090979650505050505050565b5f602080835260608084018551604080858801528282518085526080945060808901915060808160051b8a010187850194505f5b828110156123ef57607f198b830301845285516001600160a01b03815116835289810151888b8501526123ba89850182611e6f565b905086820151848203888601526123d18282611e6f565b928b0151948b01949094525095890195938901939150600101612385565b50968a0151898803601f190160408b01529661240b81896122f9565b9b9a5050505050505050505050565b5f806040838503121561242b575f80fd5b823567ffffffffffffffff80821115612442575f80fd5b61244e868387016120da565b93506020850135915080821115612463575f80fd5b50612470858286016120da565b9150509250929050565b8015158114611dac575f80fd5b80356120738161247a565b5f805f805f8060c087890312156124a7575f80fd5b6124b087612068565b9550602087013567ffffffffffffffff808211156124cc575f80fd5b6124d88a838b016120da565b965060408901359150808211156124ed575f80fd5b6124f98a838b016120da565b955061250760608a01612487565b9450608089013591508082111561251c575f80fd5b6125288a838b016120da565b935060a089013591508082111561253d575f80fd5b5061254a89828a016120f8565b9150509295509295509295565b5f8060408385031215612568575f80fd5b82356125738161247a565b915060208301356125838161247a565b809150509250929050565b634e487b7160e01b5f52603260045260245ffd5b5f6125af6120ac84612078565b90508281528383830111156125c2575f80fd5b8282602083015e5f602084830101529392505050565b5f82601f8301126125e7575f80fd5b611143838351602085016125a2565b5f60208284031215612606575f80fd5b815167ffffffffffffffff81111561261c575f80fd5b610431848285016125d8565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561267d57603f1988860301845261266b858351611e6f565b9450928501929085019060010161264f565b5092979650505050505050565b5f8085851115612698575f80fd5b838611156126a4575f80fd5b5050820193919092039150565b604081525f6126c4604083018587611eaf565b82810360208401526126d68185611e6f565b9695505050505050565b634e487b7160e01b5f52601160045260245ffd5b80820180821115610295576102956126e0565b5f81518060208401855e5f93019283525090919050565b828482375f8382015f81526126d68185612707565b5f82601f830112612742575f80fd5b815160206127526120ac83612031565b82815260059290921b84018101918181019086841115612770575f80fd5b8286015b8481101561218657805167ffffffffffffffff811115612792575f80fd5b8701603f810189136127a2575f80fd5b6127b38986830151604084016125a2565b845250918301918301612774565b5f602082840312156127d1575f80fd5b815167ffffffffffffffff8111156127e7575f80fd5b61043184828501612733565b5f815160208301516001600160e01b0319808216935060048310156128225780818460040360031b1b83161693505b505050919050565b5f82601f830112612839575f80fd5b813560206128496120ac83612031565b82815260059290921b84018101918181019086841115612867575f80fd5b8286015b8481101561218657803567ffffffffffffffff811115612889575f80fd5b6128978986838b01016120da565b84525091830191830161286b565b5f80604083850312156128b6575f80fd5b823567ffffffffffffffff808211156128cd575f80fd5b818501915085601f8301126128e0575f80fd5b813560206128f06120ac83612031565b82815260059290921b8401810191818101908984111561290e575f80fd5b948201945b838610156129355785356129268161247a565b82529482019490820190612913565b9650508601359250508082111561294a575f80fd5b506124708582860161282a565b604081525f6129696040830185611e6f565b828103602084015261199f8185611e6f565b5f6111438284612707565b5f60018201612997576129976126e0565b5060010190565b805161207381612054565b805161207381611d97565b5f602082840312156129c4575f80fd5b815167ffffffffffffffff808211156129db575f80fd5b9083019060c082860312156129ee575f80fd5b6129f6611fdd565b6129ff8361299e565b8152612a0d602084016129a9565b6020820152604083015182811115612a23575f80fd5b612a2f878286016125d8565b604083015250612a41606084016129a9565b6060820152612a52608084016129a9565b608082015260a083015182811115612a68575f80fd5b612a74878286016125d8565b60a08301525095945050505050565b5f60208284031215612a93575f80fd5b81516111438161247a565b81810381811115610295576102956126e0565b5f6020808385031215612ac2575f80fd5b825167ffffffffffffffff80821115612ad9575f80fd5b818501915085601f830112612aec575f80fd5b8151612afa6120ac82612031565b81815260059190911b83018401908481019088831115612b18575f80fd5b8585015b83811015612b4e57805185811115612b32575f80fd5b612b408b89838a01016125d8565b845250918601918601612b1c565b5098975050505050505050565b5f60208284031215612b6b575f80fd5b815161114381612054565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b83811015612c0257603f19898403018552815160606001600160a01b03825116855288820151818a870152612bd4828701826122f9565b91505087820151915084810388860152612bee8183611e6f565b968901969450505090860190600101612b9d565b509098975050505050505050565b6001600160a01b038616815260a060208201525f612c3160a08301876122f9565b8281036040840152612c438187611e6f565b90506001600160e01b0319851660608401528281036080840152612c678185611e6f565b98975050505050505050565b602081526001600160a01b0382511660208201525f60208301516001600160e01b031980821660408501526040850151915060c06060850152612cb960e0850183611e6f565b91508060608601511660808501528060808601511660a08501525060a0840151601f198483030160c085015261199f8282611e6f565b606081525f612d016060830186611e6f565b8281036020840152612d138186611e6f565b905082810360408401526126d68185611e6f565b5f805f805f60a08688031215612d3b575f80fd5b8551612d4681612054565b602087015190955067ffffffffffffffff80821115612d63575f80fd5b612d6f89838a01612733565b95506040880151915080821115612d84575f80fd5b612d9089838a016125d8565b945060608801519150612da282611d97565b608088015191935080821115612db6575f80fd5b50612dc3888289016125d8565b915050929550929590935056fea26469706673582212201aac98bc4a75beb832065fea83727dc5f1bb2e8ccad0c02cee5e3c642e5ee10164736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "667": [
      {
        "length": 32,
        "start": 5151
      }
    ],
    "24998": [
      {
        "length": 32,
        "start": 512
      },
      {
        "length": 32,
        "start": 1599
      }
    ],
    "25001": [
      {
        "length": 32,
        "start": 343
      },
      {
        "length": 32,
        "start": 1677
      }
    ]
  },
  "inputSourceName": "project/src/dns/DNSAliasResolver.sol",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed.      Error selector: `0xba4adc23`"
        }
      ],
      "DNSEncodingFailed(string)": [
        {
          "details": "A label of the ENS name has an invalid size.      Error selector: `0x9a4c3e3b`"
        }
      ],
      "InvalidBatchGatewayResponse()": [
        {
          "details": "Error selector: `0x4a5c31ea`"
        }
      ],
      "NoSuffixMatch(bytes,bytes)": [
        {
          "params": {
            "name": "The DNS-encoded name.",
            "suffix": "THe DNS-encoded suffix."
          }
        }
      ],
      "OffchainLookup(address,string[],bytes,bytes4,bytes)": [
        {
          "details": "https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`"
        }
      ],
      "OffsetOutOfBoundsError(uint256,uint256)": [
        {
          "details": "`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`"
        }
      ],
      "UnreachableName(bytes)": [
        {
          "details": "`name` cannot be resolved.      Error selector: `0x5fe9a5df`",
          "params": {
            "name": "The DNS-encoded ENS name."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "callResolver(address,bytes,bytes,bool,bytes,string[])": {
        "details": "Reverts `UnreachableName` if resolver is not a contract.      This function never returns normally.      The return type is necessary to define the result of the callback.      Call this function externally or with `ccipRead()` to intercept the response.",
        "params": {
          "batchGateways": "The batch gateway URLs.",
          "context": "The context for `IExtendedDNSResolver`.",
          "data": "The calldata for the resolution.",
          "hasContext": "True if `IExtendedDNSResolver` should be considered.",
          "name": "The DNS-encoded ENS name.",
          "resolver": "The resolver to call."
        }
      },
      "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": {
        "details": "Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`."
      },
      "ccipBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \"done\".",
        "params": {
          "extraData": "The contextual data passed from `ccipBatch()`.",
          "response": "The response from the batch gateway."
        },
        "returns": {
          "batch": "The batch where every lookup is \"done\"."
        }
      },
      "ccipReadCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.",
        "params": {
          "extraData": "The contextual data passed from `ccipRead()`.",
          "response": "The response from offchain."
        }
      },
      "resolve(bytes,bytes,bytes)": {
        "details": "Apply rewrite rule to name and resolve it instead. The operating assumption is that this contract is never called directly, and instead only invoked by DNSTLDResolver in response to an TXT record."
      },
      "resolveBatchCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `callResolver()` from batch calling a resolver.",
        "params": {
          "extraData": "The abi-encoded properties of the call.",
          "response": "The response data from the batch gateway."
        },
        "returns": {
          "_0": "result The response from the resolver."
        }
      },
      "resolveDirectImmediateCallback(bytes,bytes)": {
        "details": "CCIP-Read callback for `callResolver()` from direct calling an immediate resolver."
      },
      "rewriteNameWithContext(bytes,bytes)": {
        "details": "Modify `name` using rewrite rule in `context`.",
        "params": {
          "context": "The rewrite rule.",
          "name": "The DNS-encoded name."
        },
        "returns": {
          "_0": "The modified DNS-encoded name."
        }
      },
      "supportsFeature(bytes4)": {
        "params": {
          "featureId": "The feature identifier."
        },
        "returns": {
          "_0": "`true` if the feature is supported by the contract."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "2356400",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "BATCH_GATEWAY_PROVIDER()": "infinite",
        "ROOT_REGISTRY()": "infinite",
        "callResolver(address,bytes,bytes,bool,bytes,string[])": "infinite",
        "ccipBatch(((address,bytes,bytes,uint256)[],string[]))": "infinite",
        "ccipBatchCallback(bytes,bytes)": "infinite",
        "ccipReadCallback(bytes,bytes)": "infinite",
        "resolve(bytes,bytes,bytes)": "infinite",
        "resolveBatchCallback(bytes,bytes)": "infinite",
        "resolveDirectImmediateCallback(bytes,bytes)": "infinite",
        "rewriteNameWithContext(bytes,bytes)": "infinite",
        "supportsFeature(bytes4)": "441",
        "supportsInterface(bytes4)": "531"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"rootRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayProvider\",\"name\":\"batchGatewayProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ens\",\"type\":\"string\"}],\"name\":\"DNSEncodingFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchGatewayResponse\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"suffix\",\"type\":\"bytes\"}],\"name\":\"NoSuffixMatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OffsetOutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"UnreachableName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BATCH_GATEWAY_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IGatewayProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasContext\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"string[]\",\"name\":\"batchGateways\",\"type\":\"string[]\"}],\"name\":\"callResolver\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"ccipBatch\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipBatchCallback\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct CCIPBatcher.Lookup[]\",\"name\":\"lookups\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"gateways\",\"type\":\"string[]\"}],\"internalType\":\"struct CCIPBatcher.Batch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ccipReadCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"resolveBatchCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"resolveDirectImmediateCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"rewriteNameWithContext\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"feature\",\"type\":\"bytes4\"}],\"name\":\"supportsFeature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.      Error selector: `0xba4adc23`\"}],\"DNSEncodingFailed(string)\":[{\"details\":\"A label of the ENS name has an invalid size.      Error selector: `0x9a4c3e3b`\"}],\"InvalidBatchGatewayResponse()\":[{\"details\":\"Error selector: `0x4a5c31ea`\"}],\"NoSuffixMatch(bytes,bytes)\":[{\"params\":{\"name\":\"The DNS-encoded name.\",\"suffix\":\"THe DNS-encoded suffix.\"}}],\"OffchainLookup(address,string[],bytes,bytes4,bytes)\":[{\"details\":\"https://eips.ethereum.org/EIPS/eip-3668 Error selector: `0x556f1830`\"}],\"OffsetOutOfBoundsError(uint256,uint256)\":[{\"details\":\"`offset` was beyond `length`.       Error selector: `0x8a3c1cfb`\"}],\"UnreachableName(bytes)\":[{\"details\":\"`name` cannot be resolved.      Error selector: `0x5fe9a5df`\",\"params\":{\"name\":\"The DNS-encoded ENS name.\"}}]},\"kind\":\"dev\",\"methods\":{\"callResolver(address,bytes,bytes,bool,bytes,string[])\":{\"details\":\"Reverts `UnreachableName` if resolver is not a contract.      This function never returns normally.      The return type is necessary to define the result of the callback.      Call this function externally or with `ccipRead()` to intercept the response.\",\"params\":{\"batchGateways\":\"The batch gateway URLs.\",\"context\":\"The context for `IExtendedDNSResolver`.\",\"data\":\"The calldata for the resolution.\",\"hasContext\":\"True if `IExtendedDNSResolver` should be considered.\",\"name\":\"The DNS-encoded ENS name.\",\"resolver\":\"The resolver to call.\"}},\"ccipBatch(((address,bytes,bytes,uint256)[],string[]))\":{\"details\":\"Use `ccipRead()` to call this function with a batch.      The callback response will be `abi.encode(batch)`.\"},\"ccipBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipBatch()`.      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\",\"params\":{\"extraData\":\"The contextual data passed from `ccipBatch()`.\",\"response\":\"The response from the batch gateway.\"},\"returns\":{\"batch\":\"The batch where every lookup is \\\"done\\\".\"}},\"ccipReadCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `ccipRead()`.The return type of this function is polymorphic depending on the caller.\",\"params\":{\"extraData\":\"The contextual data passed from `ccipRead()`.\",\"response\":\"The response from offchain.\"}},\"resolve(bytes,bytes,bytes)\":{\"details\":\"Apply rewrite rule to name and resolve it instead. The operating assumption is that this contract is never called directly, and instead only invoked by DNSTLDResolver in response to an TXT record.\"},\"resolveBatchCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `callResolver()` from batch calling a resolver.\",\"params\":{\"extraData\":\"The abi-encoded properties of the call.\",\"response\":\"The response data from the batch gateway.\"},\"returns\":{\"_0\":\"result The response from the resolver.\"}},\"resolveDirectImmediateCallback(bytes,bytes)\":{\"details\":\"CCIP-Read callback for `callResolver()` from direct calling an immediate resolver.\"},\"rewriteNameWithContext(bytes,bytes)\":{\"details\":\"Modify `name` using rewrite rule in `context`.\",\"params\":{\"context\":\"The rewrite rule.\",\"name\":\"The DNS-encoded name.\"},\"returns\":{\"_0\":\"The modified DNS-encoded name.\"}},\"supportsFeature(bytes4)\":{\"params\":{\"featureId\":\"The feature identifier.\"},\"returns\":{\"_0\":\"`true` if the feature is supported by the contract.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidBatchGatewayResponse()\":[{\"notice\":\"The batch gateway supplied an incorrect number of responses.\"}],\"NoSuffixMatch(bytes,bytes)\":[{\"notice\":\"The `name` did not end with `suffix`.\"}]},\"kind\":\"user\",\"methods\":{\"callResolver(address,bytes,bytes,bool,bytes,string[])\":{\"notice\":\"Perform forward resolution. Call this function with `ccipRead()` to intercept the response. Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers. - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,   the call is performed directly without the batch gateway. - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,   the call is performed directly without the batch gateway. - Otherwise, the call is performed with the batch gateway.   The batch gateway is only invoked if any call reverts `OffchainLookup`.   If the calldata is `multicall()` it is disassembled, called separately, and reassembled.\"},\"supportsFeature(bytes4)\":{\"notice\":\"Check if a feature is supported.\"}},\"notice\":\"Gasless DNSSEC resolver that forwards to another name. Format: `ENS1 <this> <context>` 1. Rewrite: `context = <oldSuffix> <newSuffix>`    eg. `*.nick.com` + `ENS1 <this> com base.eth` &rarr; `*.nick.base.eth` 2. Replace: `context = <newName>`    eg. `notdot.net` + `ENS1 <this> nick.eth` &rarr; `nick.eth`\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/dns/DNSAliasResolver.sol\":\"DNSAliasResolver\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\"project/:@ens/contracts/=project/lib/ens-contracts/contracts/\",\"project/:@ensdomains/verifiable-factory/=project/lib/verifiable-factory/src/\",\"project/:@openzeppelin/contracts-upgradeable/=project/lib/openzeppelin-contracts-upgradeable/contracts/\",\"project/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts/contracts/\",\"project/:@unruggable/gateways/=project/lib/unruggable-gateways/\",\"project/:forge-std/=project/lib/forge-std/src/\",\"project/lib/ens-contracts/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-v4/contracts/\",\"project/lib/openzeppelin-contracts-upgradeable/:@openzeppelin/contracts/=project/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\"project/lib/verifiable-factory/:@openzeppelin/contracts/=project/lib/verifiable-factory/lib/openzeppelin-contracts/contracts/\"]},\"sources\":{\"project/lib/ens-contracts/contracts/ccipRead/CCIPBatcher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IBatchGateway} from \\\"./IBatchGateway.sol\\\";\\nimport {CCIPReader, EIP3668, OffchainLookup} from \\\"./CCIPReader.sol\\\";\\n\\nabstract contract CCIPBatcher is CCIPReader {\\n    /// @notice The batch gateway supplied an incorrect number of responses.\\n    /// @dev Error selector: `0x4a5c31ea`\\n    error InvalidBatchGatewayResponse();\\n\\n    uint256 constant FLAG_OFFCHAIN = 1 << 0; // the lookup reverted `OffchainLookup`\\n    uint256 constant FLAG_CALL_ERROR = 1 << 1; // the initial call or callback reverted\\n    uint256 constant FLAG_BATCH_ERROR = 1 << 2; // `OffchainLookup` failed on the batch gateway\\n    uint256 constant FLAG_EMPTY_RESPONSE = 1 << 3; // the initial call or callback returned `0x`\\n    uint256 constant FLAG_EIP140_BEFORE = 1 << 4; // does not have revert op code\\n    uint256 constant FLAG_EIP140_AFTER = 1 << 5; // has revert op code\\n    uint256 constant FLAG_DONE = 1 << 6; // the lookup has finished processing (private)\\n\\n    uint256 constant FLAGS_ANY_ERROR =\\n        FLAG_CALL_ERROR | FLAG_BATCH_ERROR | FLAG_EMPTY_RESPONSE;\\n    uint256 constant FLAGS_ANY_EIP140 = FLAG_EIP140_BEFORE | FLAG_EIP140_AFTER;\\n\\n    /// @dev An independent `OffchainLookup` session.\\n    struct Lookup {\\n        address target; // contract to call\\n        bytes call; // initial calldata\\n        bytes data; // response or error\\n        uint256 flags; // see: FLAG_*\\n    }\\n\\n    /// @dev A batch gateway session.\\n    struct Batch {\\n        Lookup[] lookups;\\n        string[] gateways;\\n    }\\n\\n    /// @dev Create a batch for a single target with multiple calls.\\n    /// @param target The target contract.\\n    /// @param calls The list of calldata.\\n    /// @param gateways The batch gateway URLs.\\n    function createBatch(\\n        address target,\\n        bytes[] memory calls,\\n        string[] memory gateways\\n    ) internal pure returns (Batch memory) {\\n        Lookup[] memory lookups = new Lookup[](calls.length);\\n        for (uint256 i; i < calls.length; ++i) {\\n            Lookup memory lu = lookups[i];\\n            lu.target = target;\\n            lu.call = calls[i];\\n        }\\n        return Batch(lookups, gateways);\\n    }\\n\\n    /// @dev Use `ccipRead()` to call this function with a batch.\\n    ///      The callback response will be `abi.encode(batch)`.\\n    function ccipBatch(\\n        Batch memory batch\\n    ) external view returns (Batch memory) {\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) != 0) {\\n                continue; // don't call a lookup that's already done\\n            }\\n            if ((lu.flags & FLAGS_ANY_EIP140) == 0) {\\n                uint256 flags = detectEIP140(lu.target)\\n                    ? FLAG_EIP140_AFTER\\n                    : FLAG_EIP140_BEFORE;\\n                for (uint256 j = i; j < batch.lookups.length; ++j) {\\n                    if (batch.lookups[j].target == lu.target) {\\n                        batch.lookups[j].flags |= flags;\\n                    }\\n                }\\n            }\\n            bool unsafe = (lu.flags & FLAG_EIP140_AFTER) == 0;\\n            (bool ok, bytes memory v) = safeCall(!unsafe, lu.target, lu.call);\\n            if (!ok && bytes4(v) == OffchainLookup.selector) {\\n                lu.flags |= FLAG_OFFCHAIN;\\n            } else {\\n                lu.flags |= FLAG_DONE;\\n                if (unsafe && v.length == 0) {\\n                    // unsafe contracts appear the same for throw and unimplemented fallback\\n                    // decision: interpret like an unimplemented function selector response\\n                } else if (!ok) {\\n                    lu.flags |= FLAG_CALL_ERROR;\\n                }\\n                if (v.length == 0) {\\n                    lu.flags |= FLAG_EMPTY_RESPONSE;\\n                }\\n            }\\n            lu.data = v;\\n        }\\n        _revertBatchGateway(batch); // reverts if any offchain\\n        return batch;\\n    }\\n\\n    /// @dev Check if the batch is \\\"done\\\".  If not, revert `OffchainLookup` for batch gateway.\\n    function _revertBatchGateway(Batch memory batch) internal view {\\n        IBatchGateway.Request[] memory requests = new IBatchGateway.Request[](\\n            batch.lookups.length\\n        );\\n        uint256 count;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                requests[count++] = IBatchGateway.Request(\\n                    p.sender,\\n                    p.urls,\\n                    p.callData\\n                );\\n            }\\n        }\\n        if (count > 0) {\\n            assembly {\\n                mstore(requests, count) // truncate to number of offchain requests\\n            }\\n            revert OffchainLookup(\\n                address(this),\\n                batch.gateways,\\n                abi.encodeCall(IBatchGateway.query, (requests)),\\n                this.ccipBatchCallback.selector,\\n                abi.encode(batch)\\n            );\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipBatch()`.\\n    ///      Updates `batch` using the batch gateway response. Reverts again if not \\\"done\\\".\\n    /// @param response The response from the batch gateway.\\n    /// @param extraData The contextual data passed from `ccipBatch()`.\\n    /// @return batch The batch where every lookup is \\\"done\\\".\\n    function ccipBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (Batch memory batch) {\\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\\n            response,\\n            (bool[], bytes[])\\n        );\\n        if (failures.length != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        batch = abi.decode(extraData, (Batch));\\n        uint256 expected;\\n        for (uint256 i; i < batch.lookups.length; ++i) {\\n            Lookup memory lu = batch.lookups[i];\\n            if ((lu.flags & FLAG_DONE) == 0) {\\n                if (expected < responses.length) {\\n                    bytes memory v = responses[expected];\\n                    if (failures[expected]) {\\n                        lu.flags |= FLAG_DONE | FLAG_BATCH_ERROR;\\n                    } else {\\n                        EIP3668.Params memory p = decodeOffchainLookup(lu.data);\\n                        bool ok;\\n                        // assumption: unsafe contracts don't revert OffchainLookup()\\n                        (ok, v) = p.sender.staticcall(\\n                            abi.encodeWithSelector(\\n                                p.callbackFunction,\\n                                v,\\n                                p.extraData\\n                            )\\n                        );\\n                        if (ok || bytes4(v) != OffchainLookup.selector) {\\n                            lu.flags |= FLAG_DONE;\\n                            // decision: promote empty response from the callback => call error\\n                            // ie. the initial function was implemented but the callback was not\\n                            // this can be detected via FLAG_OFFCHAIN\\n                            if (!ok || v.length == 0) {\\n                                lu.flags |= FLAG_CALL_ERROR;\\n                            }\\n                            if (v.length == 0) {\\n                                lu.flags |= FLAG_EMPTY_RESPONSE;\\n                            }\\n                        }\\n                    }\\n                    lu.data = v;\\n                }\\n                ++expected;\\n            }\\n        }\\n        if (expected != responses.length) {\\n            revert InvalidBatchGatewayResponse();\\n        }\\n        _revertBatchGateway(batch);\\n    }\\n}\\n\",\"keccak256\":\"0x8315d7930568e488eac59ac205e4ed20a3ebf19445358b4218c62a49f2e5ebf6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/CCIPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @author Modified from https://github.com/unruggable-labs/CCIPReader.sol/blob/341576fe7ff2b6e0c93fc08f37740cf6439f5873/contracts/CCIPReader.sol\\n\\n/// MIT License\\n/// Portions Copyright (c) 2025 Unruggable\\n/// Portions Copyright (c) 2025 ENS Labs Ltd\\n\\n/// @dev Instructions:\\n/// 1. inherit this contract\\n/// 2. call `ccipRead()` similar to `staticcall()`\\n/// 3. do not put logic after this invocation\\n/// 4. implement all response logic in callback\\n/// 5. ensure that return type of calling function == callback function\\n\\nimport {EIP3668, OffchainLookup} from \\\"./EIP3668.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\n\\ncontract CCIPReader {\\n    /// @dev Default unsafe call gas (sufficient for legacy ENS resolver profiles).\\n    uint256 constant DEFAULT_UNSAFE_CALL_GAS = 50000;\\n\\n    /// @dev Special-purpose value for identity callback: `f(x) = x`.\\n    bytes4 constant IDENTITY_FUNCTION = bytes4(0);\\n\\n    /// @dev The gas limit for calling functions on unsafe contracts.\\n    uint256 immutable unsafeCallGas;\\n\\n    constructor(uint256 _unsafeCallGas) {\\n        unsafeCallGas = _unsafeCallGas;\\n    }\\n\\n    /// @dev A recursive CCIP-Read session.\\n    struct Context {\\n        address target;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n        bytes4 successCallbackFunction;\\n        bytes4 failureCallbackFunction;\\n        bytes myExtraData;\\n    }\\n\\n    /// @dev Same as `ccipRead()` but the callback function is the identity.\\n    function ccipRead(address target, bytes memory call) internal view {\\n        ccipRead(target, call, IDENTITY_FUNCTION, IDENTITY_FUNCTION, \\\"\\\");\\n    }\\n\\n    /// @dev Performs a CCIP-Read and handles internal recursion.\\n    ///      Reverts `OffchainLookup` if necessary.\\n    ///      Use `IDENTITY_FUNCTION` as the callback function selector for return/revert behavior.\\n    /// @param target The contract address.\\n    /// @param call The calldata to `staticcall()` on `target`.\\n    /// @param successCallbackFunction The function selector of callback on success.\\n    /// @param failureCallbackFunction The function selector of callback on failure.\\n    /// @param extraData The contextual data relayed to callback function.\\n    function ccipRead(\\n        address target,\\n        bytes memory call,\\n        bytes4 successCallbackFunction,\\n        bytes4 failureCallbackFunction,\\n        bytes memory extraData\\n    ) internal view {\\n        // We call the intended function that **could** revert with an `OffchainLookup`\\n        // We destructure the response into an execution status bool and our return bytes\\n        (bool ok, bytes memory v) = safeCall(\\n            detectEIP140(target),\\n            target,\\n            call\\n        );\\n        // IF the function reverted with an `OffchainLookup`\\n        if (!ok && bytes4(v) == OffchainLookup.selector) {\\n            // We decode the response error into a tuple\\n            // tuples allow flexibility noting stack too deep constraints\\n            EIP3668.Params memory p = decodeOffchainLookup(v);\\n            if (p.sender == target) {\\n                // We then wrap the error data in an `OffchainLookup` sent/'owned' by this contract\\n                revert OffchainLookup(\\n                    address(this),\\n                    p.urls,\\n                    p.callData,\\n                    this.ccipReadCallback.selector,\\n                    abi.encode(\\n                        Context(\\n                            target,\\n                            p.callbackFunction,\\n                            p.extraData,\\n                            successCallbackFunction,\\n                            failureCallbackFunction,\\n                            extraData\\n                        )\\n                    )\\n                );\\n            }\\n        }\\n        // IF we have gotten here, the 'real' target does not revert with an `OffchainLookup` error\\n        // figure out what callback to call\\n        bytes4 callbackFunction = ok\\n            ? successCallbackFunction\\n            : failureCallbackFunction;\\n        if (callbackFunction != IDENTITY_FUNCTION) {\\n            // The exit point of this architecture is OUR callback in the 'real'\\n            // We pass through the response to that callback\\n            (ok, v) = address(this).staticcall(\\n                abi.encodeWithSelector(callbackFunction, v, extraData)\\n            );\\n        }\\n        // OR the call to the 'real' target reverts with a different error selector\\n        // OR the call to OUR callback reverts with ANY error selector\\n        if (ok) {\\n            assembly {\\n                return(add(v, 32), mload(v))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(v, 32), mload(v))\\n            }\\n        }\\n    }\\n\\n    /// @dev CCIP-Read callback for `ccipRead()`.\\n    /// @param response The response from offchain.\\n    /// @param extraData The contextual data passed from `ccipRead()`.\\n    /// @dev The return type of this function is polymorphic depending on the caller.\\n    function ccipReadCallback(\\n        bytes memory response,\\n        bytes memory extraData\\n    ) external view {\\n        Context memory ctx = abi.decode(extraData, (Context));\\n        // Since the callback can revert too (but has the same return structure)\\n        // We can reuse the calling infrastructure to call the callback\\n        ccipRead(\\n            ctx.target,\\n            abi.encodeWithSelector(\\n                ctx.callbackFunction,\\n                response,\\n                ctx.extraData\\n            ),\\n            ctx.successCallbackFunction,\\n            ctx.failureCallbackFunction,\\n            ctx.myExtraData\\n        );\\n    }\\n\\n    /// @dev Decode `OffchainLookup` error data into a struct.\\n    /// @param v The error data of the revert.\\n    /// @return p The decoded `OffchainLookup` params.\\n    function decodeOffchainLookup(\\n        bytes memory v\\n    ) internal pure returns (EIP3668.Params memory p) {\\n        p = EIP3668.decode(BytesUtils.substring(v, 4, v.length - 4));\\n    }\\n\\n    /// @dev Determine if `target` uses `revert()` instead of `invalid()`.\\n    //       Assumption: only newer contracts revert `OffchainLookup`.\\n    /// @param target The contract to test.\\n    /// @return safe True if safe to call.\\n    function detectEIP140(address target) internal view returns (bool safe) {\\n        if (target == address(this)) return true;\\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md\\n        assembly {\\n            let G := 5000\\n            let g := gas()\\n            pop(staticcall(G, target, 0, 0, 0, 0))\\n            safe := lt(sub(g, gas()), G)\\n        }\\n    }\\n\\n    /// @dev Same as `staticcall()` but prevents OOG when not `safe`.\\n    function safeCall(\\n        bool safe,\\n        address target,\\n        bytes memory call\\n    ) internal view returns (bool ok, bytes memory v) {\\n        (ok, v) = target.staticcall{gas: safe ? gasleft() : unsafeCallGas}(\\n            call\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xa6f483e89e779385c2b7ea6376d92cd3c05c98f91d1a3c7c43dc7422fe6b014f\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/EIP3668.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev https://eips.ethereum.org/EIPS/eip-3668\\n/// Error selector: `0x556f1830`\\nerror OffchainLookup(\\n    address sender,\\n    string[] urls,\\n    bytes callData,\\n    bytes4 callbackFunction,\\n    bytes extraData\\n);\\n\\n/// @dev Simple library for decoding `OffchainLookup` error data.\\n/// Avoids \\\"stack too deep\\\" issues as the natural decoding consumes 5 variables.\\nlibrary EIP3668 {\\n    /// @dev Struct with members matching `OffchainLookup`.\\n    struct Params {\\n        address sender;\\n        string[] urls;\\n        bytes callData;\\n        bytes4 callbackFunction;\\n        bytes extraData;\\n    }\\n\\n    /// @dev Decode an `OffchainLookup` into a struct from the data after the error selector.\\n    function decode(bytes memory v) internal pure returns (Params memory p) {\\n        (p.sender, p.urls, p.callData, p.callbackFunction, p.extraData) = abi\\n            .decode(v, (address, string[], bytes, bytes4, bytes));\\n    }\\n}\\n\",\"keccak256\":\"0x14619de0f3d9f085e6209767b35c2888b8d2af6d787af535f30db7b51e843bf8\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IBatchGateway.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for Batch Gateway Offchain Lookup Protocol.\\n///         https://docs.ens.domains/ensip/21/\\n/// @dev Interface selector: `0xa780bab6`\\ninterface IBatchGateway {\\n    /// @notice An HTTP error occurred.\\n    /// @dev Error selector: `0x01800152`\\n    error HttpError(uint16 status, string message);\\n\\n    /// @dev Information extracted from an `OffchainLookup` revert.\\n    struct Request {\\n        address sender;\\n        string[] urls;\\n        bytes data;\\n    }\\n\\n    /// @notice Perform multiple `OffchainLookup` in parallel.\\n    ///         Callers should enable EIP-3668.\\n    /// @param requests The array of requests to lookup in parallel.\\n    /// @return failures The failure status of the corresponding request.\\n    /// @return responses The response or error data of the corresponding request.\\n    function query(\\n        Request[] memory requests\\n    ) external view returns (bool[] memory failures, bytes[] memory responses);\\n}\\n\",\"keccak256\":\"0xfd7f0c7bdc29fc732ec54da2ebaea241873e55082e484729901811bc9374d6f6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/ccipRead/IGatewayProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for shared gateway URLs.\\n/// @dev Interface selector: `0x093a86d3`\\ninterface IGatewayProvider {\\n    /// @notice Get the gateways.\\n    /// @return The gateway URLs.\\n    function gateways() external view returns (string[] memory);\\n}\\n\",\"keccak256\":\"0x7c169843cfb65657a88fb4d5f7ec44612994d7d87cb7b1a67cbfdb18758823e0\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/IMulticallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n\\n    function multicallWithNodeCheck(\\n        bytes32,\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x0334202e20bb11995997083d05963f5e8e7ed6194cba494e7f9371ab7bf4e2c3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/ResolverFeatures.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary ResolverFeatures {\\n    /// @notice Implements `resolve(multicall([...]))`.\\n    /// @dev Feature: `0x96b62db8`\\n    bytes4 constant RESOLVE_MULTICALL =\\n        bytes4(keccak256(\\\"eth.ens.resolver.extended.multicall\\\"));\\n\\n    /// @notice Returns the same records independent of name or node.\\n    /// @dev Feature: `0x86fb8da8`\\n    bytes4 constant SINGULAR = bytes4(keccak256(\\\"eth.ens.resolver.singular\\\"));\\n}\\n\",\"keccak256\":\"0x87d131fcbdd7951a17b0a94f7f02470ec3f62c6004cf91c2d2acc54098373be6\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedDNSResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedDNSResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data,\\n        bytes memory context\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x541f8799c34ff9e7035d09f06ae0f0f8a16b6065e9b60a15670b957321630f72\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/universalResolver/ResolverCaller.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ERC165Checker\\n} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {CCIPBatcher} from \\\"../ccipRead/CCIPBatcher.sol\\\";\\nimport {BytesUtils} from \\\"../utils/BytesUtils.sol\\\";\\nimport {IERC7996} from \\\"../utils/IERC7996.sol\\\";\\nimport {ResolverFeatures} from \\\"../resolvers/ResolverFeatures.sol\\\";\\n\\n// resolver profiles\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {\\n    IExtendedDNSResolver\\n} from \\\"../resolvers/profiles/IExtendedDNSResolver.sol\\\";\\nimport {IMulticallable} from \\\"../resolvers/IMulticallable.sol\\\";\\n\\nabstract contract ResolverCaller is CCIPBatcher {\\n    /// @dev `name` cannot be resolved.\\n    ///      Error selector: `0x5fe9a5df`\\n    /// @param name The DNS-encoded ENS name.\\n    error UnreachableName(bytes name);\\n\\n    /// @notice Perform forward resolution.\\n    ///\\n    /// Call this function with `ccipRead()` to intercept the response.\\n    /// Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers.\\n    ///\\n    /// - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,\\n    ///   the call is performed directly without the batch gateway.\\n    /// - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,\\n    ///   the call is performed directly without the batch gateway.\\n    /// - Otherwise, the call is performed with the batch gateway.\\n    ///   The batch gateway is only invoked if any call reverts `OffchainLookup`.\\n    ///   If the calldata is `multicall()` it is disassembled, called separately, and reassembled.\\n    ///\\n    /// @dev Reverts `UnreachableName` if resolver is not a contract.\\n\\t///      This function never returns normally.\\n\\t///      The return type is necessary to define the result of the callback.\\n\\t///      Call this function externally or with `ccipRead()` to intercept the response.\\n    /// @param resolver The resolver to call.\\n    /// @param name The DNS-encoded ENS name.\\n    /// @param data The calldata for the resolution.\\n    /// @param hasContext True if `IExtendedDNSResolver` should be considered.\\n    /// @param context The context for `IExtendedDNSResolver`.\\n    /// @param batchGateways The batch gateway URLs.\\n    function callResolver(\\n        address resolver,\\n        bytes memory name,\\n        bytes memory data,\\n        bool hasContext,\\n        bytes memory context,\\n        string[] memory batchGateways\\n    ) public view returns (bytes memory) {\\n        if (resolver.code.length == 0) {\\n            revert UnreachableName(name);\\n        }\\n        bool multi = bytes4(data) == IMulticallable.multicall.selector;\\n        bool extendedDNS = hasContext &&\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IExtendedDNSResolver).interfaceId\\n            );\\n        bool extended = extendedDNS ||\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IExtendedResolver).interfaceId\\n            );\\n        if (\\n            ERC165Checker.supportsERC165InterfaceUnchecked(\\n                resolver,\\n                type(IERC7996).interfaceId\\n            ) &&\\n            (!multi ||\\n                (extended &&\\n                    IERC7996(resolver).supportsFeature(\\n                        ResolverFeatures.RESOLVE_MULTICALL\\n                    )))\\n        ) {\\n            if (extended) {\\n                // resolve() has the same return signature as callResolver()\\n                ccipRead(\\n                    resolver,\\n                    _makeExtendedCall(extendedDNS, name, data, context)\\n                );\\n            } else {\\n                ccipRead(\\n                    resolver,\\n                    data,\\n                    this.resolveDirectImmediateCallback.selector, // ==> step 2\\n                    IDENTITY_FUNCTION,\\n                    \\\"\\\"\\n                );\\n            }\\n        }\\n        bytes[] memory calls;\\n        if (multi) {\\n            calls = abi.decode(\\n                BytesUtils.substring(data, 4, data.length - 4),\\n                (bytes[])\\n            );\\n        } else {\\n            calls = new bytes[](1);\\n            calls[0] = data;\\n        }\\n        if (extended) {\\n            for (uint256 i; i < calls.length; ++i) {\\n                calls[i] = _makeExtendedCall(\\n                    extendedDNS,\\n                    name,\\n                    calls[i],\\n                    context\\n                );\\n            }\\n        }\\n        ccipRead(\\n            address(this),\\n            abi.encodeCall(\\n                this.ccipBatch,\\n                (createBatch(resolver, calls, batchGateways))\\n            ),\\n            this.resolveBatchCallback.selector, // ==> step 2\\n            IDENTITY_FUNCTION,\\n            abi.encode(multi, extended)\\n        );\\n    }\\n\\n    /// @dev CCIP-Read callback for `callResolver()` from direct calling an immediate resolver.\\n    function resolveDirectImmediateCallback(\\n        bytes calldata response,\\n        bytes calldata\\n    ) external pure returns (bytes calldata) {\\n        return response; // the calldata was direct, so wrap it\\n    }\\n\\n    /// @dev CCIP-Read callback for `callResolver()` from batch calling a resolver.\\n    /// @param response The response data from the batch gateway.\\n    /// @param extraData The abi-encoded properties of the call.\\n    /// @return result The response from the resolver.\\n    function resolveBatchCallback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external pure returns (bytes memory) {\\n        Lookup[] memory lookups = abi.decode(response, (Batch)).lookups;\\n        (bool multi, bool extended) = abi.decode(extraData, (bool, bool));\\n        if (multi) {\\n            bytes[] memory m = new bytes[](lookups.length);\\n            for (uint256 i; i < lookups.length; ++i) {\\n                Lookup memory lu = lookups[i];\\n                bytes memory v = lu.data;\\n                if (extended && (lu.flags & FLAGS_ANY_ERROR) == 0) {\\n                    v = abi.decode(v, (bytes)); // unwrap resolve()\\n                }\\n                m[i] = v;\\n            }\\n            return abi.encode(m);\\n        } else {\\n            Lookup memory lu = lookups[0];\\n            bytes memory v = lu.data;\\n            if ((lu.flags & FLAGS_ANY_ERROR) != 0) {\\n                assembly {\\n                    revert(add(v, 32), mload(v))\\n                }\\n            }\\n            if (extended) {\\n                v = abi.decode(v, (bytes)); // unwrap resolve()\\n            }\\n            return v;\\n        }\\n    }\\n\\n    /// @dev Create extended resolver calldata.\\n    function _makeExtendedCall(\\n        bool extendedDNS,\\n        bytes memory name,\\n        bytes memory call,\\n        bytes memory context\\n    ) internal pure returns (bytes memory) {\\n        return\\n            extendedDNS\\n                ? abi.encodeCall(\\n                    IExtendedDNSResolver.resolve,\\n                    (name, call, context)\\n                )\\n                : abi.encodeCall(IExtendedResolver.resolve, (name, call));\\n    }\\n}\\n\",\"keccak256\":\"0x38307321fb62ccee51f3ea2241c018aba1822e758c05ae7e228a760949c26848\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\n\\nlibrary BytesUtils {\\n    /// @dev `offset` was beyond `length`.\\n    ///       Error selector: `0x8a3c1cfb`\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /// @dev Assert `end` is not beyond the length of `v`.\\n    function _checkBound(bytes memory v, uint256 end) internal pure {\\n        if (end > v.length) {\\n            revert OffsetOutOfBoundsError(end, v.length);\\n        }\\n    }\\n\\n    /// @dev Compute `keccak256(v[off:off+len])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to hash.\\n    /// @return ret The corresponding hash.\\n    function keccak(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(add(add(v, 32), off), len)\\n        }\\n    }\\n\\n    /// @dev Lexicographically compare two byte strings.\\n    /// @param vA The first bytes to compare.\\n    /// @param vB The second bytes to compare.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (int256) {\\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\\n    }\\n\\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset of the first bytes.\\n    /// @param lenA The length of the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset of the second bytes.\\n    /// @param lenB The length of the second bytes.\\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\\n    function compare(\\n        bytes memory vA,\\n        uint256 offA,\\n        uint256 lenA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 lenB\\n    ) internal pure returns (int256) {\\n        _checkBound(vA, offA + lenA);\\n        _checkBound(vB, offB + lenB);\\n        unchecked {\\n            uint256 ptrA = LibMem.ptr(vA) + offA;\\n            uint256 ptrB = LibMem.ptr(vB) + offB;\\n            uint256 shortest = lenA < lenB ? lenA : lenB;\\n            for (uint256 i; i < shortest; i += 32) {\\n                uint256 a = LibMem.load(ptrA + i);\\n                uint256 b = LibMem.load(ptrB + i);\\n                if (a != b) {\\n                    uint256 rest = shortest - i;\\n                    if (rest < 32) {\\n                        rest = (32 - rest) << 3; // bits to drop\\n                        a >>= rest; // shift out the\\n                        b >>= rest; // irrelevant bits\\n                    }\\n                    if (a < b) {\\n                        return -1;\\n                    } else if (a > b) {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return int256(lenA) - int256(lenB);\\n    }\\n\\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @param len The number of bytes to compare.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b[offB:]`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @param offB The offset into the second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB,\\n        uint256 offB\\n    ) internal pure returns (bool) {\\n        _checkBound(vA, offA);\\n        _checkBound(vB, offB);\\n        unchecked {\\n            return\\n                keccak(vA, offA, vA.length - offA) ==\\n                keccak(vB, offB, vB.length - offB);\\n        }\\n    }\\n\\n    /// @dev Determine if `a[offA:] == b`.\\n    /// @param vA The first bytes.\\n    /// @param offA The offset into the first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the byte ranges are equal.\\n    function equals(\\n        bytes memory vA,\\n        uint256 offA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return\\n            vA.length == offA + vB.length &&\\n            keccak(vA, offA, vB.length) == keccak256(vB);\\n    }\\n\\n    /// @dev Determine if `a == b`.\\n    /// @param vA The first bytes.\\n    /// @param vB The second bytes.\\n    /// @return True if the bytes are equal.\\n    function equals(\\n        bytes memory vA,\\n        bytes memory vB\\n    ) internal pure returns (bool) {\\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\\n    }\\n\\n    /// @dev Returns `uint8(v[off])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return The corresponding `uint8`.\\n    function readUint8(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint8) {\\n        _checkBound(v, off + 1);\\n        unchecked {\\n            return uint8(v[off]);\\n        }\\n    }\\n\\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint16`.\\n    function readUint16(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint16 ret) {\\n        _checkBound(v, off + 2);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(240, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `uint32`.\\n    function readUint32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (uint32 ret) {\\n        _checkBound(v, off + 4);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shr(224, mload(add(add(v, 32), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes20(v[off:off+20])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes20`.\\n    function readBytes20(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes20 ret) {\\n        _checkBound(v, off + 20);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := shl(96, mload(add(add(v, 20), off)))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(v[off:off+32])`.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @return ret The corresponding `bytes32`.\\n    function readBytes32(\\n        bytes memory v,\\n        uint256 off\\n    ) internal pure returns (bytes32 ret) {\\n        _checkBound(v, off + 32);\\n        assembly (\\\"memory-safe\\\") {\\n            ret := mload(add(add(v, 32), off))\\n        }\\n    }\\n\\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\\n    ///      Accepts 0-32 bytes or reverts.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes.\\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\\n    function readBytesN(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        assert(len <= 32);\\n        _checkBound(v, off + len);\\n        assembly (\\\"memory-safe\\\") {\\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\\n            ret := and(mload(add(add(v, 32), off)), not(mask))\\n        }\\n    }\\n\\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\\n    /// @param vSrc The source bytes.\\n    /// @param offSrc The offset into the source to begin the copy.\\n    /// @param vDst The destination bytes.\\n    /// @param offDst The offset into the destination to place the copy.\\n    /// @param len The number of bytes to copy.\\n    function copyBytes(\\n        bytes memory vSrc,\\n        uint256 offSrc,\\n        bytes memory vDst,\\n        uint256 offDst,\\n        uint256 len\\n    ) internal pure {\\n        _checkBound(vSrc, offSrc + len);\\n        _checkBound(vDst, offDst + len);\\n        unchecked {\\n            LibMem.copy(\\n                LibMem.ptr(vDst) + offDst,\\n                LibMem.ptr(vSrc) + offSrc,\\n                len\\n            );\\n        }\\n    }\\n\\n    /// @dev Copies a substring into a new byte string.\\n    /// @param vSrc The byte string to copy from.\\n    /// @param off The offset to start copying at.\\n    /// @param len The number of bytes to copy.\\n    /// @return vDst The copied substring.\\n    function substring(\\n        bytes memory vSrc,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes memory vDst) {\\n        vDst = new bytes(len);\\n        copyBytes(vSrc, off, vDst, 0, len);\\n    }\\n\\n    /// @dev Find the first occurrence of `needle`.\\n    /// @param v The bytes to search.\\n    /// @param off The offset to start searching.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\\n    function find(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 end = off + len; off < end; off++) {\\n            if (v[off] == needle) {\\n                return off;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    /// @dev Returns `true` if word contains a zero byte.\\n    function hasZeroByte(uint256 word) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                ((~word &\\n                    (word -\\n                        0x0101010101010101010101010101010101010101010101010101010101010101)) &\\n                    0x8080808080808080808080808080808080808080808080808080808080808080) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Efficiently check if `v[off:off+len]` contains `needle` byte.\\n    /// @param v The source bytes.\\n    /// @param off The offset into the source.\\n    /// @param len The number of bytes to search.\\n    /// @param needle The byte to search for.\\n    /// @return found `true` if `needle` was found.\\n    function includes(\\n        bytes memory v,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (bool found) {\\n        _checkBound(v, off + len);\\n        unchecked {\\n            uint256 wide = uint8(needle);\\n            wide |= wide << 8;\\n            wide |= wide << 16;\\n            wide |= wide << 32;\\n            wide |= wide << 64;\\n            wide |= wide << 128; // broadcast byte across word\\n            off += LibMem.ptr(v);\\n            len += off;\\n            while (off < len) {\\n                uint256 word = LibMem.load(off) ^ wide; // zero needle byte\\n                off += 32;\\n                if (hasZeroByte(word)) {\\n                    return\\n                        off <= len ||\\n                        hasZeroByte(\\n                            word | ((1 << ((off - len) << 3)) - 1) // recheck overflow by making it nonzero\\n                        );\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcda2585a719e1a8974b5b44357e5d21417e1308b1d1f4d26b244d4ff0bb5b02d\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/IERC7996.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for expressing contract features not visible from the ABI.\\n/// @dev Interface selector: `0x582de3e7`\\ninterface IERC7996 {\\n    /// @notice Check if a feature is supported.\\n    /// @param featureId The feature identifier.\\n    /// @return `true` if the feature is supported by the contract.\\n    function supportsFeature(bytes4 featureId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf499a48e4e879ec7775f375d2cb5af047720ab6ae4b6f89a40a578c4e0f51631\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/LibMem/LibMem.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary LibMem {\\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\\n    ///      Equivalent to `mcopy()`.\\n    ///\\n    /// @param src The source memory offset.\\n    /// @param dst The destination memory offset.\\n    /// @param len The number of bytes to copy.\\n    function copy(uint256 dst, uint256 src, uint256 len) internal pure {\\n        assembly {\\n            // Copy word-length chunks while possible\\n            // prettier-ignore\\n            for {} gt(len, 31) {} {\\n                mstore(dst, mload(src))\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n                len := sub(len, 32)\\n            }\\n            // Copy remaining bytes\\n            if len {\\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1)\\n                let wSrc := and(mload(src), not(mask))\\n                let wDst := and(mload(dst), mask)\\n                mstore(dst, or(wSrc, wDst))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert bytes to a memory offset.\\n    ///\\n    /// @param v The bytes to convert.\\n    ///\\n    /// @return ret The corresponding memory offset.\\n    function ptr(bytes memory v) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := add(v, 32)\\n        }\\n    }\\n\\n    /// @dev Read word at memory offset.\\n    ///\\n    /// @param src The memory offset.\\n    ///\\n    /// @return ret The read word.\\n    function load(uint256 src) internal pure returns (uint256 ret) {\\n        assembly {\\n            ret := mload(src)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x066f29ad3a39392786ff3caf9ba120104ffaa55502f71158631411db46d1ec89\",\"license\":\"MIT\"},\"project/lib/ens-contracts/contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {LibMem} from \\\"./LibMem/LibMem.sol\\\";\\nimport {BytesUtils} from \\\"./BytesUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n///\\n/// * maximum label length is 255 bytes.\\n/// * length = 0 is reserved for the terminator (root).\\n/// * `dns.length == 2 + ens.length` and the mapping is injective.\\n///\\nlibrary NameCoder {\\n    /// @dev The namehash of \\\"eth\\\".\\n    bytes32 public constant ETH_NODE =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    /// @dev The label was empty.\\n    ///      Error selector: `0xbf9a2740`\\n    error LabelIsEmpty();\\n\\n    /// @dev The label was more than 255 bytes.\\n    ///      Error selector: `0xdab6c73c`\\n    error LabelIsTooLong(string label);\\n\\n    /// @dev The DNS-encoded name is malformed.\\n    ///      Error selector: `0xba4adc23`\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    ///      Error selector: `0x9a4c3e3b`\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix The DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    /// @dev Read the `size` of the label at `offset`.\\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return size The size of the label in bytes.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function nextLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\\n        unchecked {\\n            if (offset >= name.length) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            size = uint8(name[offset]);\\n            nextOffset = offset + 1 + size;\\n            if (\\n                size > 0 ? nextOffset >= name.length : nextOffset != name.length\\n            ) {\\n                revert DNSDecodingFailed(name);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the offset of the label before `offset` in `name`.\\n    ///      * `prevOffset(name, 0)` reverts\\n    ///      * `prevOffset(name, name.length + 1)` reverts\\n    ///      * `prevOffset(name, name.length) = name.length - 1`\\n    ///      * `prevOffset(name, name.length - 1) = <tld>`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading backwards.\\n    ///\\n    /// @return prevOffset The offset into `name` of the previous label.\\n    function prevLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 prevOffset) {\\n        while (true) {\\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\\n            if (nextOffset == offset) break;\\n            if (nextOffset > offset) {\\n                revert DNSDecodingFailed(name);\\n            }\\n            prevOffset = nextOffset;\\n        }\\n    }\\n\\n    /// @dev Count number of labels in `name`.\\n    ///      * `countLabels(\\\"\\\\x03eth\\\\x00\\\") = 1`\\n    ///      * `countLabels(\\\"\\\\x00\\\") = 0`\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return count The number of labels.\\n    function countLabels(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (uint256 count) {\\n        uint8 size;\\n        while (true) {\\n            (size, offset) = nextLabel(name, offset);\\n            if (size == 0) break;\\n            ++count;\\n        }\\n    }\\n\\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return labelHash The resulting labelhash.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        if (size > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, offset), 33), size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Read label at offset from a DNS-encoded name and the offset for the next label.\\n    ///      * `readLabel(\\\"\\\\x03abc\\\\x00\\\", 0) = (\\\"abc\\\", 4)`\\n    ///      * `readLabel(\\\"\\\\x00\\\", 0) = (\\\"\\\", 1)`\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start reading.\\n    ///\\n    /// @return label The label corresponding to `offset`.\\n    /// @return nextOffset The offset into `name` of the next label.\\n    function extractLabel(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (string memory label, uint256 nextOffset) {\\n        uint8 size;\\n        (size, nextOffset) = nextLabel(name, offset);\\n        bytes memory v = new bytes(size);\\n        unchecked {\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(name) + offset + 1, size);\\n        }\\n        label = string(v);\\n    }\\n\\n    /// @dev Reads first label from a DNS-encoded name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///      Reverts `LabelIsEmpty` if the label was empty.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    ///\\n    /// @return The first label.\\n    function firstLabel(\\n        bytes memory name\\n    ) internal pure returns (string memory) {\\n        (string memory label, ) = extractLabel(name, 0);\\n        if (bytes(label).length == 0) {\\n            revert LabelIsEmpty();\\n        }\\n        return label;\\n    }\\n\\n    /// @dev Compute the namehash of `name[:offset]`.\\n    ///      Reverts `DNSDecodingFailed`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to start hashing.\\n    ///\\n    /// @return hash The namehash of `name[:offset]`.\\n    function namehash(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, offset) = readLabel(name, offset);\\n        if (hash != bytes32(0)) {\\n            hash = namehash(namehash(name, offset), hash);\\n        }\\n    }\\n\\n    /// @dev Compute a child namehash from a parent namehash and child labelhash.\\n    ///\\n    /// @param parentNode The namehash of the parent.\\n    /// @param labelHash The labelhash of the child.\\n    ///\\n    /// @return node The namehash of the child.\\n    function namehash(\\n        bytes32 parentNode,\\n        bytes32 labelHash\\n    ) internal pure returns (bytes32 node) {\\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\\n        assembly {\\n            mstore(0, parentNode)\\n            mstore(32, labelHash)\\n            node := keccak256(0, 64)\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      * `decode(\\\"\\\\x00\\\") = \\\"\\\"`\\n    ///      * `decode(\\\"\\\\x03eth\\\\x00\\\") = \\\"eth\\\"`\\n    ///      * `decode(\\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\") = \\\"aa.bb.c\\\"`\\n    ///      * `decode(\\\"\\\\x03a.b\\\\x00\\\")` reverts\\n    ///      Reverts like `nextLabel()`.\\n    ///\\n    /// @param dns The DNS-encoded name to convert.\\n    ///\\n    /// @return ens The equivalent ENS name.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            LibMem.copy(LibMem.ptr(v), LibMem.ptr(dns) + 1, n - 2); // shift by -1 byte\\n            uint256 offset;\\n            while (true) {\\n                (uint8 size, uint256 nextOffset) = nextLabel(dns, offset);\\n                if (size == 0) break;\\n                if (BytesUtils.includes(v, offset, size, \\\".\\\")) {\\n                    revert DNSDecodingFailed(dns); // malicious label\\n                }\\n                if (offset > 0) {\\n                    v[offset - 1] = \\\".\\\";\\n                }\\n                offset = nextOffset;\\n            }\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      * `encode(\\\"aaa.bb.c\\\") = \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\"`\\n    ///      * `encode(\\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `encode(\\\"\\\") = \\\"\\\\x00\\\"`\\n    ///      Reverts `DNSEncodingFailed`.\\n    ///\\n    /// @param ens The ENS name to convert.\\n    ///\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2); // always 2-longer\\n            LibMem.copy(LibMem.ptr(dns) + 1, LibMem.ptr(bytes(ens)), n); // shift by +1 byte\\n            uint256 start; // remember position to write length\\n            uint256 size;\\n            for (uint256 i; i < n; ++i) {\\n                if (bytes(ens)[i] == \\\".\\\") {\\n                    size = i - start;\\n                    if (size == 0 || size > 255) {\\n                        revert DNSEncodingFailed(ens);\\n                    }\\n                    dns[start] = bytes1(uint8(size));\\n                    start = i + 1;\\n                }\\n            }\\n            size = n - start;\\n            if (size == 0 || size > 255) {\\n                revert DNSEncodingFailed(ens);\\n            }\\n            dns[start] = bytes1(uint8(size));\\n        }\\n    }\\n\\n    /// @dev Find the offset into `name` that namehashes to `nodeSuffix`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param nodeSuffix The namehash to match.\\n    ///\\n    /// @return matched True if `name` ends with `nodeSuffix`.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return prevOffset The offset into `name` of the label before `nodeSuffix`, or `matchOffset` if no match or no prior label.\\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\\n    function matchSuffix(\\n        bytes memory name,\\n        uint256 offset,\\n        bytes32 nodeSuffix\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool matched,\\n            bytes32 node,\\n            uint256 prevOffset,\\n            uint256 matchOffset\\n        )\\n    {\\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\\n                name,\\n                next,\\n                nodeSuffix\\n            );\\n            if (node == nodeSuffix) {\\n                matched = true;\\n                prevOffset = offset;\\n                matchOffset = next;\\n            }\\n            node = namehash(node, labelHash);\\n        }\\n        if (node == nodeSuffix) {\\n            matched = true;\\n            prevOffset = matchOffset = offset;\\n        }\\n    }\\n\\n    /// @dev Assert `label` is an encodable size.\\n    ///\\n    /// @param label The label to check.\\n    ///\\n    /// @return The size of the label.\\n    function assertLabelSize(\\n        string memory label\\n    ) internal pure returns (uint8) {\\n        uint256 n = bytes(label).length;\\n        if (n == 0) revert LabelIsEmpty();\\n        if (n > 255) revert LabelIsTooLong(label);\\n        return uint8(n);\\n    }\\n\\n    /// @dev Prepend `label` to DNS-encoded `name`.\\n    ///      * `addLabel(\\\"\\\\x03eth\\\\x00\\\", \\\"test\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\\x00\\\", \\\"eth\\\") = \\\"\\\\x03eth\\\\x00\\\"`\\n    ///      * `addLabel(\\\"\\\", \\\"abc\\\") = \\\"\\\\x03abc\\\"` invalid\\n    ///      * `addLabel(\\\"\\\", \\\"\\\")` reverts\\n    ///      Assumes `name` is properly encoded.\\n    ///      Reverts like `assertLabelSize()`.\\n    ///\\n    /// @param name The DNS-encoded parent name.\\n    /// @param label The child label to prepend.\\n    ///\\n    /// @return The DNS-encoded child name.\\n    function addLabel(\\n        bytes memory name,\\n        string memory label\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(assertLabelSize(label), label, name);\\n    }\\n\\n    /// @dev Transform `label` to DNS-encoded `{label}.eth`.\\n    ///      * `ethName(\\\"eth\\\") = \\\"\\\\x04test\\\\x03eth\\\\x00\\\"`\\n    ///      Behaves like `addLabel()`.\\n    ///\\n    /// @param label The label to encode.\\n    ///\\n    /// @return The DNS-encoded name.\\n    function ethName(string memory label) internal pure returns (bytes memory) {\\n        return addLabel(\\\"\\\\x03eth\\\\x00\\\", label);\\n    }\\n}\\n\",\"keccak256\":\"0xe2152baacde56f8725de800767c8155f916b6e18c1348cdec82e16d2d3bee35a\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5a08ad61f4e82b8a3323562661a86fb10b10190848073fdc13d4ac43710ffba5\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the zero address.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1d7a05b3219532ea5ece50a80cf390cac9109dc74e07763adfa463ab5a3af0dc\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"project/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"project/src/dns/DNSAliasResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {CCIPReader} from \\\"@ens/contracts/ccipRead/CCIPReader.sol\\\";\\nimport {IGatewayProvider} from \\\"@ens/contracts/ccipRead/IGatewayProvider.sol\\\";\\nimport {IExtendedDNSResolver} from \\\"@ens/contracts/resolvers/profiles/IExtendedDNSResolver.sol\\\";\\nimport {ResolverFeatures} from \\\"@ens/contracts/resolvers/ResolverFeatures.sol\\\";\\nimport {ResolverCaller} from \\\"@ens/contracts/universalResolver/ResolverCaller.sol\\\";\\nimport {BytesUtils} from \\\"@ens/contracts/utils/BytesUtils.sol\\\";\\nimport {IERC7996} from \\\"@ens/contracts/utils/IERC7996.sol\\\";\\nimport {NameCoder} from \\\"@ens/contracts/utils/NameCoder.sol\\\";\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport {ResolverProfileRewriterLib} from \\\"../resolver/libraries/ResolverProfileRewriterLib.sol\\\";\\nimport {LibRegistry, IRegistry} from \\\"../universalResolver/libraries/LibRegistry.sol\\\";\\n\\n/// @notice Gasless DNSSEC resolver that forwards to another name.\\n///\\n/// Format: `ENS1 <this> <context>`\\n///\\n/// 1. Rewrite: `context = <oldSuffix> <newSuffix>`\\n///    eg. `*.nick.com` + `ENS1 <this> com base.eth` &rarr; `*.nick.base.eth`\\n/// 2. Replace: `context = <newName>`\\n///    eg. `notdot.net` + `ENS1 <this> nick.eth` &rarr; `nick.eth`\\n///\\ncontract DNSAliasResolver is ERC165, ResolverCaller, IERC7996, IExtendedDNSResolver {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Constants\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    IRegistry public immutable ROOT_REGISTRY;\\n\\n    IGatewayProvider public immutable BATCH_GATEWAY_PROVIDER;\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Errors\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice The `name` did not end with `suffix`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param suffix THe DNS-encoded suffix.\\n    error NoSuffixMatch(bytes name, bytes suffix);\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Initialization\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        IRegistry rootRegistry,\\n        IGatewayProvider batchGatewayProvider\\n    ) CCIPReader(DEFAULT_UNSAFE_CALL_GAS) {\\n        ROOT_REGISTRY = rootRegistry;\\n        BATCH_GATEWAY_PROVIDER = batchGatewayProvider;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165) returns (bool) {\\n        return\\n            type(IExtendedDNSResolver).interfaceId == interfaceId ||\\n            type(IERC7996).interfaceId == interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc IERC7996\\n    function supportsFeature(bytes4 feature) external pure returns (bool) {\\n        return ResolverFeatures.RESOLVE_MULTICALL == feature;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Implementation\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Apply rewrite rule to name and resolve it instead.\\n    ///\\n    /// The operating assumption is that this contract is never called directly,\\n    /// and instead only invoked by DNSTLDResolver in response to an TXT record.\\n    ///\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data,\\n        bytes calldata context\\n    ) external view returns (bytes memory) {\\n        bytes memory newName = rewriteNameWithContext(name, context);\\n        (, address resolver, bytes32 node, ) = LibRegistry.findResolver(ROOT_REGISTRY, newName, 0);\\n        callResolver(\\n            resolver,\\n            newName,\\n            ResolverProfileRewriterLib.replaceNode(data, node),\\n            false,\\n            \\\"\\\",\\n            BATCH_GATEWAY_PROVIDER.gateways()\\n        );\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Internal Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Modify `name` using rewrite rule in `context`.\\n    ///\\n    /// @param name The DNS-encoded name.\\n    /// @param context The rewrite rule.\\n    ///\\n    /// @return The modified DNS-encoded name.\\n    function rewriteNameWithContext(\\n        bytes calldata name,\\n        bytes calldata context\\n    ) public pure returns (bytes memory) {\\n        uint256 sep = BytesUtils.find(context, 0, context.length, \\\" \\\");\\n        if (sep < context.length) {\\n            bytes memory oldSuffix = NameCoder.encode(string(context[:sep]));\\n            (bool matched, , , uint256 offset) = NameCoder.matchSuffix(\\n                name,\\n                0,\\n                NameCoder.namehash(oldSuffix, 0)\\n            );\\n            if (!matched) {\\n                revert NoSuffixMatch(name, oldSuffix);\\n            }\\n            bytes memory newSuffix = NameCoder.encode(string(context[sep + 1:]));\\n            return abi.encodePacked(name[:offset], newSuffix); // rewrite\\n        } else {\\n            return NameCoder.encode(string(context)); // replace\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x28d7a58671c460f5a8faf8bae7091b884cd17ec175a6ce22480cbc1e27306071\",\"license\":\"MIT\"},\"project/src/erc1155/interfaces/IERC1155Singleton.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IERC1155Singleton is IERC1155 {\\n    function ownerOf(uint256 id) external view returns (address owner);\\n}\\n\",\"keccak256\":\"0xbfa4f4f1da56c42a6e878895cbcfc50d0d612ca9d75dda04c6df1ca0fdb72494\",\"license\":\"MIT\"},\"project/src/registry/interfaces/IRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport {IERC1155Singleton} from \\\"../../erc1155/interfaces/IERC1155Singleton.sol\\\";\\n\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\ninterface IRegistry is IERC1155Singleton {\\n    ////////////////////////////////////////////////////////////////////////\\n    // Events\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev SHOULD be emitted when a new label is registered\\n    event NameRegistered(\\n        uint256 indexed tokenId,\\n        string label,\\n        uint64 expiry,\\n        address registeredBy\\n    );\\n\\n    /// @notice Expiry was changed.\\n    /// @dev Error selector: `0x`\\n    event ExpiryUpdated(uint256 indexed tokenId, uint64 newExpiry, address changedBy);\\n\\n    /// @notice Subregistry was changed.\\n    event SubregistryUpdated(uint256 indexed tokenId, IRegistry subregistry);\\n\\n    /// @notice Resolver was changed.\\n    event ResolverUpdated(uint256 indexed tokenId, address resolver);\\n\\n    /// @notice Token was regenerated with a new token ID.\\n    ///         This occurs when roles are granted or revoked to maintain ERC1155 compliance.\\n    event TokenRegenerated(\\n        uint256 indexed oldTokenId,\\n        uint256 indexed newTokenId,\\n        uint256 resource\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////\\n    // Functions\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Fetches the registry for a subdomain.\\n     * @param label The label to resolve.\\n     * @return The address of the registry for this subdomain, or `address(0)` if none exists.\\n     */\\n    function getSubregistry(string calldata label) external view returns (IRegistry);\\n\\n    /**\\n     * @dev Fetches the resolver responsible for the specified label.\\n     * @param label The label to fetch a resolver for.\\n     * @return resolver The address of a resolver responsible for this name, or `address(0)` if none exists.\\n     */\\n    function getResolver(string calldata label) external view returns (address);\\n}\\n\",\"keccak256\":\"0xc3c7b964bbaadd35412ce44163ab335f802ac9b5f19d72b0fbb64bf772f63634\",\"license\":\"MIT\"},\"project/src/resolver/libraries/ResolverProfileRewriterLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nlibrary ResolverProfileRewriterLib {\\n    /// @dev Replace the node in the calldata with a new node.\\n    ///      Supports `multicall()` to arbirary depth.\\n    /// @param call The calldata for a resolver.\\n    /// @param newNode The replacement node.\\n    /// @return copy A copy of the calldata with node replaced.\\n    function replaceNode(\\n        bytes calldata call,\\n        bytes32 newNode\\n    ) internal pure returns (bytes memory copy) {\\n        copy = call; // make a copy\\n        assembly {\\n            function replace(ptr, node) {\\n                switch shr(224, mload(add(ptr, 32))) // call selector\\n                case 0xac9650d8 {\\n                    // multicall(bytes[])\\n                    let off := add(ptr, 36)\\n                    off := add(off, mload(off))\\n                    let size := shl(5, mload(off))\\n                    // prettier-ignore\\n                    for { } size { size := sub(size, 32) } {\\n                        replace(add(add(off, 32), mload(add(off, size))), node)\\n                    }\\n                }\\n                default {\\n                    mstore(add(ptr, 36), node) // replace node\\n                }\\n            }\\n            replace(copy, newNode)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe65086f7cda4cf55ed6ed360254011fd5b03acd02846b4a76bef2f868d2d9fcb\",\"license\":\"MIT\"},\"project/src/universalResolver/libraries/LibRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.24;\\n\\nimport {NameCoder} from \\\"@ens/contracts/utils/NameCoder.sol\\\";\\n\\nimport {IRegistry} from \\\"../../registry/interfaces/IRegistry.sol\\\";\\n\\nlibrary LibRegistry {\\n    /// @dev Find the resolver address for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    ///\\n    /// @return exactRegistry The exact registry or null if not exact.\\n    /// @return resolver The resolver or null if not found.\\n    /// @return node The namehash of `name[offset:]`.\\n    /// @return resolverOffset The offset into `name` corresponding to `resolver`.\\n    function findResolver(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    )\\n        internal\\n        view\\n        returns (IRegistry exactRegistry, address resolver, bytes32 node, uint256 resolverOffset)\\n    {\\n        // supply <root> if end of name\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash == bytes32(0)) {\\n            return (rootRegistry, address(0), bytes32(0), offset);\\n        }\\n        // lookup parent name\\n        (exactRegistry, resolver, node, resolverOffset) = findResolver(rootRegistry, name, next);\\n        // if there was a parent registry...\\n        if (address(exactRegistry) != address(0)) {\\n            (string memory label, ) = NameCoder.extractLabel(name, offset);\\n            // remember the resolver (if it exists)\\n            address res = exactRegistry.getResolver(label);\\n            if (res != address(0)) {\\n                resolver = res;\\n                resolverOffset = offset;\\n            }\\n            exactRegistry = exactRegistry.getSubregistry(label);\\n        }\\n        node = NameCoder.namehash(node, labelHash); // update namehash\\n    }\\n\\n    /// @notice Find (registry, resolver) for `name[offset:]` starting from\\n    ///         (parentRegistry, parentRegistry) for `name[:parentOffset]`.\\n    ///\\n    /// @param name The DNS-encoded name to search.\\n    /// @param offset The offset into `name` to begin the search.\\n    /// @param parentOffset The offset into `name` to use parent values.\\n    /// @param parentRegistry The registry at `name[length:]`.\\n    /// @param parentResolver The resolver at `name[length:]`.\\n    ///\\n    /// @return registry The exact registry or null if not exact.\\n    /// @return resolver The resolver or null if not found.\\n    function findResolverFromParent(\\n        bytes memory name,\\n        uint256 offset,\\n        uint256 parentOffset,\\n        IRegistry parentRegistry,\\n        address parentResolver\\n    ) internal view returns (IRegistry registry, address resolver) {\\n        if (offset > parentOffset) {\\n            revert NameCoder.DNSDecodingFailed(name);\\n        } else if (offset == parentOffset) {\\n            return (parentRegistry, parentResolver);\\n        } else {\\n            string memory label;\\n            (label, offset) = NameCoder.extractLabel(name, offset);\\n            (registry, resolver) = findResolverFromParent(\\n                name,\\n                offset,\\n                parentOffset,\\n                parentRegistry,\\n                parentResolver\\n            );\\n            if (address(registry) != address(0)) {\\n                address res = registry.getResolver(label);\\n                if (res != address(0)) {\\n                    resolver = res;\\n                }\\n                registry = registry.getSubregistry(label);\\n            }\\n        }\\n    }\\n\\n    /// @dev Find the exact registry for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    ///\\n    /// @return exactRegistry The exact registry or null if not found.\\n    function findExactRegistry(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry exactRegistry) {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash == bytes32(0)) {\\n            return rootRegistry;\\n        }\\n        IRegistry parent = findExactRegistry(rootRegistry, name, next);\\n        if (address(parent) != address(0)) {\\n            (string memory label, ) = NameCoder.extractLabel(name, offset);\\n            exactRegistry = parent.getSubregistry(label);\\n        }\\n    }\\n\\n    /// @dev Find the parent registry for `name[offset:]`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name to search.\\n    ///\\n    /// @return parentRegistry The parent registry or null if not found.\\n    function findParentRegistry(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry parentRegistry) {\\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) {\\n            parentRegistry = findExactRegistry(rootRegistry, name, next);\\n        }\\n    }\\n\\n    /// @notice Find all registries in the ancestry of `name`.\\n    ///\\n    /// @param rootRegistry The root ENS registry.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset into `name` to begin the search.\\n    ///\\n    /// @return registries Array of registries in label-order.\\n    function findRegistries(\\n        IRegistry rootRegistry,\\n        bytes memory name,\\n        uint256 offset\\n    ) internal view returns (IRegistry[] memory registries) {\\n        registries = new IRegistry[](1 + NameCoder.countLabels(name, offset));\\n        registries[registries.length - 1] = rootRegistry;\\n        _findRegistries(name, offset, registries, 0);\\n    }\\n\\n    /// @dev Recursive function for building ancestory.\\n    function _findRegistries(\\n        bytes memory name,\\n        uint256 offset,\\n        IRegistry[] memory registries,\\n        uint256 index\\n    ) private view returns (IRegistry registry) {\\n        (string memory label, uint256 nextOffset) = NameCoder.extractLabel(name, offset);\\n        if (bytes(label).length == 0) {\\n            return registries[registries.length - 1];\\n        }\\n        registry = _findRegistries(name, nextOffset, registries, index + 1);\\n        if (address(registry) != address(0)) {\\n            registry = registry.getSubregistry(label);\\n            registries[index] = registry;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd80793afdb36a5f7a2c7556a0dbcc1a4fefcdfb89357579b77cd31390fd1988d\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "InvalidBatchGatewayResponse()": [
        {
          "notice": "The batch gateway supplied an incorrect number of responses."
        }
      ],
      "NoSuffixMatch(bytes,bytes)": [
        {
          "notice": "The `name` did not end with `suffix`."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "callResolver(address,bytes,bytes,bool,bytes,string[])": {
        "notice": "Perform forward resolution. Call this function with `ccipRead()` to intercept the response. Supports extended (`IExtendedDNSResolver` and `IExtendedResolver`) and immediate resolvers. - If extended, the calldata is not `multicall()`, and the resolver supports ENSIP-22 features,   the call is performed directly without the batch gateway. - If extended, the calldata is `multicall()`, and the resolver supports `eth.ens.resolver.extended.multicall` feature,   the call is performed directly without the batch gateway. - Otherwise, the call is performed with the batch gateway.   The batch gateway is only invoked if any call reverts `OffchainLookup`.   If the calldata is `multicall()` it is disassembled, called separately, and reassembled."
      },
      "supportsFeature(bytes4)": {
        "notice": "Check if a feature is supported."
      }
    },
    "notice": "Gasless DNSSEC resolver that forwards to another name. Format: `ENS1 <this> <context>` 1. Rewrite: `context = <oldSuffix> <newSuffix>`    eg. `*.nick.com` + `ENS1 <this> com base.eth` &rarr; `*.nick.base.eth` 2. Replace: `context = <newName>`    eg. `notdot.net` + `ENS1 <this> nick.eth` &rarr; `nick.eth`",
    "version": 1
  },
  "argsData": "0x000000000000000000000000610178da211fef7d417bc0e6fed39f05609ad788000000000000000000000000dc64a140aa3e981100a9beca4e685f962f0cf6c9",
  "transaction": {
    "hash": "0xff9a4aaa3beefd0c613942cae954a4fe3828ee5e03449d587d9cf90ded1990af",
    "nonce": "0xb",
    "origin": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"
  },
  "receipt": {
    "blockHash": "0x954433329549711c6da71eaa09ca67733154d47f9536039c148d9cb5e285ef68",
    "blockNumber": "0xc",
    "transactionIndex": "0x0"
  }
}